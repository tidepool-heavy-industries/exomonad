// Auto-generated by generate-ts-package - DO NOT EDIT

import type { SerializableEffect, EffectResult } from './protocol.js';
import { errorResult } from './protocol.js';

// Internal effect types (handled by StateMachineDO, not yielded to caller)
export type InternalEffectType = "Log" | "LLM" | "State" | "Random" | "Time" | "ChatHistory";

/**
 * Handler interface for internal effects.
 *
 * TEnv is the environment type (e.g., Cloudflare Worker Env).
 * Each handler receives the specific effect type and environment.
 */
export interface InternalEffectHandlers<TEnv> {
  Log: (effect: Extract<SerializableEffect, { type: "Log" }>, env: TEnv) => Promise<EffectResult>;
  LLM: (effect: Extract<SerializableEffect, { type: "LLM" }>, env: TEnv) => Promise<EffectResult>;
  State: (effect: Extract<SerializableEffect, { type: "State" }>, env: TEnv) => Promise<EffectResult>;
  Random: (effect: Extract<SerializableEffect, { type: "Random" }>, env: TEnv) => Promise<EffectResult>;
  Time: (effect: Extract<SerializableEffect, { type: "Time" }>, env: TEnv) => Promise<EffectResult>;
  ChatHistory: (effect: Extract<SerializableEffect, { type: "ChatHistory" }>, env: TEnv) => Promise<EffectResult>;
}

/**
 * Dispatch an internal effect to the appropriate handler.
 *
 * @param effect - The effect to execute
 * @param handlers - Registry of handler functions
 * @param env - Environment with bindings
 * @returns Promise resolving to success/error result
 */
export function dispatchInternalEffect<TEnv>(
  effect: SerializableEffect,
  handlers: InternalEffectHandlers<TEnv>,
  env: TEnv
): Promise<EffectResult> {
  switch (effect.type) {
    case "Log":
      return handlers.Log(
        effect as Extract<SerializableEffect, { type: "Log" }>,
        env
      );

    case "LLM":
      return handlers.LLM(
        effect as Extract<SerializableEffect, { type: "LLM" }>,
        env
      );

    case "State":
      return handlers.State(
        effect as Extract<SerializableEffect, { type: "State" }>,
        env
      );

    case "Random":
      return handlers.Random(
        effect as Extract<SerializableEffect, { type: "Random" }>,
        env
      );

    case "Time":
      return handlers.Time(
        effect as Extract<SerializableEffect, { type: "Time" }>,
        env
      );

    case "ChatHistory":
      return handlers.ChatHistory(
        effect as Extract<SerializableEffect, { type: "ChatHistory" }>,
        env
      );

    default:
      return Promise.resolve(errorResult(
        `Unknown internal effect type: ${(effect as { type: string }).type}`
      ));
  }
}
