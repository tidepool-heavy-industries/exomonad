/**
 * Cross-language protocol conformance tests.
 *
 * These tests verify that JSON generated by Haskell WireTypes
 * can be parsed by TypeScript using Zod schemas.
 *
 * Flow:
 * 1. Haskell generates fixtures: `cabal run generate-fixtures`
 * 2. This test parses them with Zod schemas
 * 3. If Zod fails → types don't match → test fails
 */

import { describe, it, expect, beforeAll } from "vitest";
import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";
import {
  SerializableEffectZ,
  EffectResultZ,
  ExecutionPhaseZ,
  GraphStateZ,
  StepOutputZ,
} from "../src/protocol.schema";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const FIXTURES_DIR = path.join(__dirname, "../../fixtures/protocol");

function loadFixture(name: string): unknown {
  const filepath = path.join(FIXTURES_DIR, `${name}.json`);
  return JSON.parse(fs.readFileSync(filepath, "utf-8"));
}

describe("Protocol conformance: Haskell → TypeScript", () => {
  beforeAll(() => {
    // Verify fixtures directory exists
    if (!fs.existsSync(FIXTURES_DIR)) {
      throw new Error(
        `Fixtures not found at ${FIXTURES_DIR}. Run 'cabal run generate-fixtures' first.`
      );
    }
  });

  describe("SerializableEffect", () => {
    it("parses LlmComplete", () => {
      const result = SerializableEffectZ.safeParse(
        loadFixture("effect-llm-complete")
      );
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("LlmComplete");
        expect(result.data.eff_node).toBe("classify");
      }
    });

    it("parses HttpFetch", () => {
      const result = SerializableEffectZ.safeParse(
        loadFixture("effect-http-fetch")
      );
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("HttpFetch");
      }
    });

    it("parses LogInfo", () => {
      const result = SerializableEffectZ.safeParse(
        loadFixture("effect-log-info")
      );
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("LogInfo");
        expect(result.data.eff_message).toBe("test message");
      }
    });

    it("parses LogError", () => {
      const result = SerializableEffectZ.safeParse(
        loadFixture("effect-log-error")
      );
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("LogError");
      }
    });
  });

  describe("EffectResult", () => {
    it("parses success", () => {
      const result = EffectResultZ.safeParse(loadFixture("result-success"));
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("success");
        expect(result.data.value).toBe(42);
      }
    });

    it("parses error", () => {
      const result = EffectResultZ.safeParse(loadFixture("result-error"));
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("error");
        expect(result.data.message).toBe("something failed");
      }
    });
  });

  describe("ExecutionPhase", () => {
    it("parses idle", () => {
      const result = ExecutionPhaseZ.safeParse(loadFixture("phase-idle"));
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("idle");
      }
    });

    it("parses in_node", () => {
      const result = ExecutionPhaseZ.safeParse(loadFixture("phase-in-node"));
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("in_node");
        expect(result.data.nodeName).toBe("classify");
      }
    });

    it("parses transitioning", () => {
      const result = ExecutionPhaseZ.safeParse(
        loadFixture("phase-transitioning")
      );
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("transitioning");
        expect(result.data.fromNode).toBe("a");
        expect(result.data.toNode).toBe("b");
      }
    });

    it("parses completed", () => {
      const result = ExecutionPhaseZ.safeParse(loadFixture("phase-completed"));
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("completed");
      }
    });

    it("parses failed", () => {
      const result = ExecutionPhaseZ.safeParse(loadFixture("phase-failed"));
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.type).toBe("failed");
        expect(result.data.error).toBe("timeout");
      }
    });
  });

  describe("GraphState", () => {
    it("parses graph state", () => {
      const result = GraphStateZ.safeParse(loadFixture("graph-state"));
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.phase.type).toBe("in_node");
        expect(result.data.completedNodes).toEqual(["a", "b"]);
      }
    });
  });

  describe("StepOutput", () => {
    it("parses step with effect", () => {
      const result = StepOutputZ.safeParse(loadFixture("step-output-effect"));
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.done).toBe(false);
        expect(result.data.effect).not.toBeNull();
        expect(result.data.graphState).toBeDefined();
        expect(result.data.graphState.phase.type).toBe("idle");
      }
    });

    it("parses completed step", () => {
      const result = StepOutputZ.safeParse(loadFixture("step-output-done"));
      expect(result.success).toBe(true);
      if (result.success) {
        expect(result.data.done).toBe(true);
        expect(result.data.effect).toBeNull();
        expect(result.data.stepResult).toBe(42);
        expect(result.data.graphState.phase.type).toBe("completed");
      }
    });
  });
});
