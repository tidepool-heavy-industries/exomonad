/**
 * Cross-language protocol verification script.
 *
 * This script reads golden JSON samples generated by Haskell and validates
 * that TypeScript can correctly parse them according to protocol.ts types.
 *
 * Run with: npx ts-node test/verify-protocol.ts
 * Or via justfile: just test-protocol-conformance
 */

import * as fs from "fs";
import * as path from "path";
import { fileURLToPath } from "url";
import type {
  SerializableEffect,
  EffectResult,
  ExecutionPhase,
  GraphState,
  StepOutput,
} from "../src/protocol.js";

// ═══════════════════════════════════════════════════════════════════════════
// Type Guards for SerializableEffect variants
// ═══════════════════════════════════════════════════════════════════════════

function isLlmCompleteEffect(
  eff: SerializableEffect
): eff is SerializableEffect & { type: "LlmComplete" } {
  return (
    eff.type === "LlmComplete" &&
    typeof (eff as { eff_node?: unknown }).eff_node === "string" &&
    typeof (eff as { eff_system_prompt?: unknown }).eff_system_prompt ===
      "string" &&
    typeof (eff as { eff_user_content?: unknown }).eff_user_content === "string"
  );
}

function isHttpFetchEffect(
  eff: SerializableEffect
): eff is SerializableEffect & { type: "HttpFetch" } {
  return (
    eff.type === "HttpFetch" &&
    typeof (eff as { eff_url?: unknown }).eff_url === "string" &&
    typeof (eff as { eff_method?: unknown }).eff_method === "string"
  );
}

function isLogInfoEffect(
  eff: SerializableEffect
): eff is SerializableEffect & { type: "LogInfo" } {
  return (
    eff.type === "LogInfo" &&
    typeof (eff as { eff_message?: unknown }).eff_message === "string"
  );
}

function isLogErrorEffect(
  eff: SerializableEffect
): eff is SerializableEffect & { type: "LogError" } {
  return (
    eff.type === "LogError" &&
    typeof (eff as { eff_message?: unknown }).eff_message === "string"
  );
}

function isHabiticaEffect(
  eff: SerializableEffect
): eff is SerializableEffect & { type: "Habitica" } {
  return (
    eff.type === "Habitica" &&
    typeof (eff as { eff_hab_op?: unknown }).eff_hab_op === "string" &&
    (eff as { eff_hab_payload?: unknown }).eff_hab_payload !== undefined
  );
}

function validateSerializableEffect(eff: unknown, index: number): boolean {
  const e = eff as SerializableEffect;
  if (!e || typeof e !== "object" || !("type" in e)) {
    console.error(`  [${index}] Invalid: missing type field`);
    return false;
  }

  switch (e.type) {
    case "LlmComplete":
      if (!isLlmCompleteEffect(e)) {
        console.error(`  [${index}] LlmComplete: missing required fields`);
        return false;
      }
      break;
    case "HttpFetch":
      if (!isHttpFetchEffect(e)) {
        console.error(`  [${index}] HttpFetch: missing required fields`);
        return false;
      }
      break;
    case "LogInfo":
      if (!isLogInfoEffect(e)) {
        console.error(`  [${index}] LogInfo: missing required fields`);
        return false;
      }
      break;
    case "LogError":
      if (!isLogErrorEffect(e)) {
        console.error(`  [${index}] LogError: missing required fields`);
        return false;
      }
      break;
    case "Habitica":
      if (!isHabiticaEffect(e)) {
        console.error(`  [${index}] Habitica: missing required fields`);
        return false;
      }
      break;
    default:
      console.error(`  [${index}] Unknown effect type: ${(e as { type: string }).type}`);
      return false;
  }
  return true;
}

// ═══════════════════════════════════════════════════════════════════════════
// Type Guards for EffectResult
// ═══════════════════════════════════════════════════════════════════════════

function validateEffectResult(result: unknown, index: number): boolean {
  const r = result as EffectResult;
  if (!r || typeof r !== "object" || !("type" in r)) {
    console.error(`  [${index}] Invalid: missing type field`);
    return false;
  }

  if (r.type === "success") {
    // Success can have any value (including null/undefined)
    return true;
  } else if (r.type === "error") {
    if (typeof (r as { message?: unknown }).message !== "string") {
      console.error(`  [${index}] Error result: message must be string`);
      return false;
    }
    return true;
  } else {
    console.error(`  [${index}] Unknown result type: ${(r as { type: string }).type}`);
    return false;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Type Guards for ExecutionPhase
// ═══════════════════════════════════════════════════════════════════════════

function validateExecutionPhase(phase: unknown, index: number): boolean {
  const p = phase as ExecutionPhase;
  if (!p || typeof p !== "object" || !("type" in p)) {
    console.error(`  [${index}] Invalid: missing type field`);
    return false;
  }

  switch (p.type) {
    case "idle":
      return true;
    case "in_node":
      if (typeof (p as { nodeName?: unknown }).nodeName !== "string") {
        console.error(`  [${index}] in_node: nodeName must be string`);
        return false;
      }
      return true;
    case "transitioning":
      if (
        typeof (p as { fromNode?: unknown }).fromNode !== "string" ||
        typeof (p as { toNode?: unknown }).toNode !== "string"
      ) {
        console.error(`  [${index}] transitioning: fromNode and toNode must be strings`);
        return false;
      }
      return true;
    case "completed":
      // result can be any value
      return true;
    case "failed":
      if (typeof (p as { error?: unknown }).error !== "string") {
        console.error(`  [${index}] failed: error must be string`);
        return false;
      }
      return true;
    default:
      console.error(`  [${index}] Unknown phase type: ${(p as { type: string }).type}`);
      return false;
  }
}

// ═══════════════════════════════════════════════════════════════════════════
// Type Guards for GraphState
// ═══════════════════════════════════════════════════════════════════════════

function validateGraphState(state: unknown, index: number): boolean {
  const s = state as GraphState;
  if (!s || typeof s !== "object") {
    console.error(`  [${index}] Invalid: not an object`);
    return false;
  }

  if (!("phase" in s)) {
    console.error(`  [${index}] Missing phase field`);
    return false;
  }

  if (!("completedNodes" in s) || !Array.isArray(s.completedNodes)) {
    console.error(`  [${index}] Missing or invalid completedNodes field`);
    return false;
  }

  // Validate that completedNodes contains only strings
  for (let i = 0; i < s.completedNodes.length; i++) {
    if (typeof s.completedNodes[i] !== "string") {
      console.error(`  [${index}] completedNodes[${i}] is not a string`);
      return false;
    }
  }

  // Validate the phase
  if (!validateExecutionPhase(s.phase, index)) {
    console.error(`  [${index}] Invalid phase in GraphState`);
    return false;
  }

  return true;
}

// ═══════════════════════════════════════════════════════════════════════════
// Type Guards for StepOutput
// ═══════════════════════════════════════════════════════════════════════════

function validateStepOutput(output: unknown, index: number): boolean {
  const o = output as StepOutput;
  if (!o || typeof o !== "object") {
    console.error(`  [${index}] Invalid: not an object`);
    return false;
  }

  // Required fields
  if (!("done" in o) || typeof o.done !== "boolean") {
    console.error(`  [${index}] Missing or invalid done field`);
    return false;
  }

  if (!("graphState" in o)) {
    console.error(`  [${index}] Missing graphState field`);
    return false;
  }

  // Validate graphState
  if (!validateGraphState(o.graphState, index)) {
    console.error(`  [${index}] Invalid graphState`);
    return false;
  }

  // If not done, must have an effect
  if (!o.done) {
    if (!o.effect || o.effect === null) {
      console.error(`  [${index}] done=false but no effect`);
      return false;
    }
    if (!validateSerializableEffect(o.effect, index)) {
      console.error(`  [${index}] Invalid effect`);
      return false;
    }
    // stepResult should be null when not done
    if ("stepResult" in o && o.stepResult !== null) {
      console.error(`  [${index}] done=false but stepResult is not null`);
      return false;
    }
  } else {
    // done=true: effect should be null
    if (o.effect !== null) {
      console.error(`  [${index}] done=true but effect is not null`);
      return false;
    }
    // stepResult field should be present when done
    if (!("stepResult" in o)) {
      console.error(`  [${index}] done=true but stepResult field missing`);
      return false;
    }
  }

  return true;
}

// ═══════════════════════════════════════════════════════════════════════════
// Main Verification
// ═══════════════════════════════════════════════════════════════════════════

interface GoldenSamples {
  serializableEffects: unknown[];
  effectResults: unknown[];
  executionPhases: unknown[];
  graphStates: unknown[];
  stepOutputs: unknown[];
  _metadata?: {
    generatedBy?: string;
    purpose?: string;
    usage?: string;
  };
}

function main(): void {
  const __dirname = path.dirname(fileURLToPath(import.meta.url));
  const samplesPath = path.join(__dirname, "golden-samples.json");

  if (!fs.existsSync(samplesPath)) {
    console.error(`Golden samples file not found: ${samplesPath}`);
    console.error("Run 'cabal run generate-golden-samples' first.");
    process.exit(1);
  }

  const content = fs.readFileSync(samplesPath, "utf-8");
  let samples: GoldenSamples;
  try {
    samples = JSON.parse(content) as GoldenSamples;
  } catch (e) {
    console.error("Failed to parse golden samples JSON:", e);
    process.exit(1);
  }

  console.log("Verifying protocol conformance...\n");

  let totalErrors = 0;

  // Verify SerializableEffect samples
  console.log(
    `SerializableEffect (${samples.serializableEffects.length} samples):`
  );
  let errors = 0;
  for (let i = 0; i < samples.serializableEffects.length; i++) {
    if (!validateSerializableEffect(samples.serializableEffects[i], i)) {
      errors++;
    }
  }
  if (errors === 0) {
    console.log("  All samples valid");
  }
  totalErrors += errors;

  // Verify EffectResult samples
  console.log(`\nEffectResult (${samples.effectResults.length} samples):`);
  errors = 0;
  for (let i = 0; i < samples.effectResults.length; i++) {
    if (!validateEffectResult(samples.effectResults[i], i)) {
      errors++;
    }
  }
  if (errors === 0) {
    console.log("  All samples valid");
  }
  totalErrors += errors;

  // Verify ExecutionPhase samples
  console.log(`\nExecutionPhase (${samples.executionPhases.length} samples):`);
  errors = 0;
  for (let i = 0; i < samples.executionPhases.length; i++) {
    if (!validateExecutionPhase(samples.executionPhases[i], i)) {
      errors++;
    }
  }
  if (errors === 0) {
    console.log("  All samples valid");
  }
  totalErrors += errors;

  // Verify GraphState samples
  console.log(`\nGraphState (${samples.graphStates.length} samples):`);
  errors = 0;
  for (let i = 0; i < samples.graphStates.length; i++) {
    if (!validateGraphState(samples.graphStates[i], i)) {
      errors++;
    }
  }
  if (errors === 0) {
    console.log("  All samples valid");
  }
  totalErrors += errors;

  // Verify StepOutput samples
  console.log(`\nStepOutput (${samples.stepOutputs.length} samples):`);
  errors = 0;
  for (let i = 0; i < samples.stepOutputs.length; i++) {
    if (!validateStepOutput(samples.stepOutputs[i], i)) {
      errors++;
    }
  }
  if (errors === 0) {
    console.log("  All samples valid");
  }
  totalErrors += errors;

  // Summary
  console.log("\n" + "=".repeat(60));
  if (totalErrors === 0) {
    console.log("Protocol conformance verified successfully!");
    console.log(
      `Total samples validated: ${samples.serializableEffects.length + samples.effectResults.length + samples.executionPhases.length + samples.graphStates.length + samples.stepOutputs.length}`
    );
    process.exit(0);
  } else {
    console.error(`Protocol conformance FAILED: ${totalErrors} error(s)`);
    process.exit(1);
  }
}

main();
