{"example_id": "0001", "variation": "positive_structure", "code": "forkHandler interpret handler = NodeHandler $ \\router jsonPayload ->\n  case parseEither parseJSON jsonPayload of\n    Left err -> error $ \"ForkNode: Failed to parse input: \" <> err\n    Right input -> do\n      -- Run handler to get HList of payloads\n      hlist <- interpret (handler input)\n      -- Extract targets and route to each worker\n      let targets = extractSpawnTargets @targets @payloads hlist\n      putStrLn $ \"[FORK] Dispatching to: \" <> show (map fst targets)\n      hFlush stdout\n      forM_ targets $ \\(target, payload) ->\n        router target payload\n", "criteria": "CRITERIA_0001", "selected": "SELECTED_0001", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Fork.hs", "name": "forkHandler", "range": {"end": {"character": 11, "line": 123}, "start": {"character": 0, "line": 123}}}
{"example_id": "0002", "variation": "positive_semantic", "code": "forkHandler interpret handler = NodeHandler $ \\router jsonPayload ->\n  case parseEither parseJSON jsonPayload of\n    Left err -> error $ \"ForkNode: Failed to parse input: \" <> err\n    Right input -> do\n      -- Run handler to get HList of payloads\n      hlist <- interpret (handler input)\n      -- Extract targets and route to each worker\n      let targets = extractSpawnTargets @targets @payloads hlist\n      putStrLn $ \"[FORK] Dispatching to: \" <> show (map fst targets)\n      hFlush stdout\n      forM_ targets $ \\(target, payload) ->\n        router target payload\n", "criteria": "CRITERIA_0002", "selected": "SELECTED_0002", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Fork.hs", "name": "forkHandler", "range": {"end": {"character": 11, "line": 123}, "start": {"character": 0, "line": 123}}}
{"example_id": "0003", "variation": "negative_1", "code": "forkHandler interpret handler = NodeHandler $ \\router jsonPayload ->\n  case parseEither parseJSON jsonPayload of\n    Left err -> error $ \"ForkNode: Failed to parse input: \" <> err\n    Right input -> do\n      -- Run handler to get HList of payloads\n      hlist <- interpret (handler input)\n      -- Extract targets and route to each worker\n      let targets = extractSpawnTargets @targets @payloads hlist\n      putStrLn $ \"[FORK] Dispatching to: \" <> show (map fst targets)\n      hFlush stdout\n      forM_ targets $ \\(target, payload) ->\n        router target payload\n", "criteria": "CRITERIA_0003", "selected": "SELECTED_0003", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Fork.hs", "name": "forkHandler", "range": {"end": {"character": 11, "line": 123}, "start": {"character": 0, "line": 123}}}
{"example_id": "0004", "variation": "negative_2", "code": "forkHandler interpret handler = NodeHandler $ \\router jsonPayload ->\n  case parseEither parseJSON jsonPayload of\n    Left err -> error $ \"ForkNode: Failed to parse input: \" <> err\n    Right input -> do\n      -- Run handler to get HList of payloads\n      hlist <- interpret (handler input)\n      -- Extract targets and route to each worker\n      let targets = extractSpawnTargets @targets @payloads hlist\n      putStrLn $ \"[FORK] Dispatching to: \" <> show (map fst targets)\n      hFlush stdout\n      forM_ targets $ \\(target, payload) ->\n        router target payload\n", "criteria": "CRITERIA_0004", "selected": "SELECTED_0004", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Fork.hs", "name": "forkHandler", "range": {"end": {"character": 11, "line": 123}, "start": {"character": 0, "line": 123}}}
{"example_id": "0005", "variation": "positive_structure", "code": "empty = undefined\n\n-- | Push an element onto the top of the stack.\n--\n-- The pushed element becomes the first element to be popped.\n-- Stack size increases by one.\n--\n-- === Law\n-- > pop (push x s) == Just (x, s)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0005", "selected": "SELECTED_0005", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "empty", "range": {"end": {"character": 5, "line": 57}, "start": {"character": 0, "line": 57}}}
{"example_id": "0006", "variation": "positive_semantic", "code": "empty = undefined\n\n-- | Push an element onto the top of the stack.\n--\n-- The pushed element becomes the first element to be popped.\n-- Stack size increases by one.\n--\n-- === Law\n-- > pop (push x s) == Just (x, s)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0006", "selected": "SELECTED_0006", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "empty", "range": {"end": {"character": 5, "line": 57}, "start": {"character": 0, "line": 57}}}
{"example_id": "0007", "variation": "negative_1", "code": "empty = undefined\n\n-- | Push an element onto the top of the stack.\n--\n-- The pushed element becomes the first element to be popped.\n-- Stack size increases by one.\n--\n-- === Law\n-- > pop (push x s) == Just (x, s)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0007", "selected": "SELECTED_0007", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "empty", "range": {"end": {"character": 5, "line": 57}, "start": {"character": 0, "line": 57}}}
{"example_id": "0008", "variation": "negative_2", "code": "empty = undefined\n\n-- | Push an element onto the top of the stack.\n--\n-- The pushed element becomes the first element to be popped.\n-- Stack size increases by one.\n--\n-- === Law\n-- > pop (push x s) == Just (x, s)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0008", "selected": "SELECTED_0008", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "empty", "range": {"end": {"character": 5, "line": 57}, "start": {"character": 0, "line": 57}}}
{"example_id": "0009", "variation": "positive_structure", "code": "isEmpty = undefined\n", "criteria": "CRITERIA_0009", "selected": "SELECTED_0009", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "isEmpty", "range": {"end": {"character": 7, "line": 111}, "start": {"character": 0, "line": 111}}}
{"example_id": "0010", "variation": "positive_semantic", "code": "isEmpty = undefined\n", "criteria": "CRITERIA_0010", "selected": "SELECTED_0010", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "isEmpty", "range": {"end": {"character": 7, "line": 111}, "start": {"character": 0, "line": 111}}}
{"example_id": "0011", "variation": "negative_1", "code": "isEmpty = undefined\n", "criteria": "CRITERIA_0011", "selected": "SELECTED_0011", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "isEmpty", "range": {"end": {"character": 7, "line": 111}, "start": {"character": 0, "line": 111}}}
{"example_id": "0012", "variation": "negative_2", "code": "isEmpty = undefined\n", "criteria": "CRITERIA_0012", "selected": "SELECTED_0012", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "isEmpty", "range": {"end": {"character": 7, "line": 111}, "start": {"character": 0, "line": 111}}}
{"example_id": "0013", "variation": "positive_structure", "code": "peek = undefined\n\n-- | Check if the stack is empty.\n--\n-- === Laws\n-- > isEmpty empty == True\n-- > isEmpty (push x s) == False\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0013", "selected": "SELECTED_0013", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "peek", "range": {"end": {"character": 4, "line": 100}, "start": {"character": 0, "line": 100}}}
{"example_id": "0014", "variation": "positive_semantic", "code": "peek = undefined\n\n-- | Check if the stack is empty.\n--\n-- === Laws\n-- > isEmpty empty == True\n-- > isEmpty (push x s) == False\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0014", "selected": "SELECTED_0014", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "peek", "range": {"end": {"character": 4, "line": 100}, "start": {"character": 0, "line": 100}}}
{"example_id": "0015", "variation": "negative_1", "code": "peek = undefined\n\n-- | Check if the stack is empty.\n--\n-- === Laws\n-- > isEmpty empty == True\n-- > isEmpty (push x s) == False\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0015", "selected": "SELECTED_0015", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "peek", "range": {"end": {"character": 4, "line": 100}, "start": {"character": 0, "line": 100}}}
{"example_id": "0016", "variation": "negative_2", "code": "peek = undefined\n\n-- | Check if the stack is empty.\n--\n-- === Laws\n-- > isEmpty empty == True\n-- > isEmpty (push x s) == False\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0016", "selected": "SELECTED_0016", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "peek", "range": {"end": {"character": 4, "line": 100}, "start": {"character": 0, "line": 100}}}
{"example_id": "0017", "variation": "positive_structure", "code": "pop = undefined\n\n-- | View the top element without removing it.\n--\n-- Returns 'Nothing' if the stack is empty.\n-- The stack is not modified.\n--\n-- === Laws\n-- > peek empty == Nothing\n-- > peek (push x s) == Just x\n-- > peek s == fst <$> pop s  (ignores the rest)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0017", "selected": "SELECTED_0017", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "pop", "range": {"end": {"character": 3, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0018", "variation": "positive_semantic", "code": "pop = undefined\n\n-- | View the top element without removing it.\n--\n-- Returns 'Nothing' if the stack is empty.\n-- The stack is not modified.\n--\n-- === Laws\n-- > peek empty == Nothing\n-- > peek (push x s) == Just x\n-- > peek s == fst <$> pop s  (ignores the rest)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0018", "selected": "SELECTED_0018", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "pop", "range": {"end": {"character": 3, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0019", "variation": "negative_1", "code": "pop = undefined\n\n-- | View the top element without removing it.\n--\n-- Returns 'Nothing' if the stack is empty.\n-- The stack is not modified.\n--\n-- === Laws\n-- > peek empty == Nothing\n-- > peek (push x s) == Just x\n-- > peek s == fst <$> pop s  (ignores the rest)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0019", "selected": "SELECTED_0019", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "pop", "range": {"end": {"character": 3, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0020", "variation": "negative_2", "code": "pop = undefined\n\n-- | View the top element without removing it.\n--\n-- Returns 'Nothing' if the stack is empty.\n-- The stack is not modified.\n--\n-- === Laws\n-- > peek empty == Nothing\n-- > peek (push x s) == Just x\n-- > peek s == fst <$> pop s  (ignores the rest)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0020", "selected": "SELECTED_0020", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "pop", "range": {"end": {"character": 3, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0021", "variation": "positive_structure", "code": "push = undefined\n\n-- | Remove and return the top element of the stack.\n--\n-- Returns 'Nothing' if the stack is empty.\n-- Returns 'Just (x, s')' where x is the top element and s' is the\n-- remaining stack.\n--\n-- === Laws\n-- > pop empty == Nothing\n-- > pop (push x s) == Just (x, s)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0021", "selected": "SELECTED_0021", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "push", "range": {"end": {"character": 4, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0022", "variation": "positive_semantic", "code": "push = undefined\n\n-- | Remove and return the top element of the stack.\n--\n-- Returns 'Nothing' if the stack is empty.\n-- Returns 'Just (x, s')' where x is the top element and s' is the\n-- remaining stack.\n--\n-- === Laws\n-- > pop empty == Nothing\n-- > pop (push x s) == Just (x, s)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0022", "selected": "SELECTED_0022", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "push", "range": {"end": {"character": 4, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0023", "variation": "negative_1", "code": "push = undefined\n\n-- | Remove and return the top element of the stack.\n--\n-- Returns 'Nothing' if the stack is empty.\n-- Returns 'Just (x, s')' where x is the top element and s' is the\n-- remaining stack.\n--\n-- === Laws\n-- > pop empty == Nothing\n-- > pop (push x s) == Just (x, s)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0023", "selected": "SELECTED_0023", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "push", "range": {"end": {"character": 4, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0024", "variation": "negative_2", "code": "push = undefined\n\n-- | Remove and return the top element of the stack.\n--\n-- Returns 'Nothing' if the stack is empty.\n-- Returns 'Just (x, s')' where x is the top element and s' is the\n-- remaining stack.\n--\n-- === Laws\n-- > pop empty == Nothing\n-- > pop (push x s) == Just (x, s)\n--\n-- === Time Complexity\n-- O(1)\n", "criteria": "CRITERIA_0024", "selected": "SELECTED_0024", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Data/Stack.hs", "name": "push", "range": {"end": {"character": 4, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0025", "variation": "positive_structure", "code": "allEffectMeta =\n  -- Core IO-blind effects\n  [ EffectMeta \"Log\"             Internal FireAndForget  -- LogMsg with various levels\n  , EffectMeta \"LLM\"             Internal Blocking       -- RunTurnOp (tool-aware LLM calls)\n  , EffectMeta \"State\"           Internal Blocking       -- Get/Put for agent state\n  , EffectMeta \"Random\"          Internal Blocking       -- RandomInt/RandomDouble\n  , EffectMeta \"Time\"            Internal Blocking       -- GetCurrentTime\n  , EffectMeta \"ChatHistory\"     Internal Blocking       -- GetHistory/AppendMessages\n  , EffectMeta \"Emit\"            Yielded  FireAndForget  -- EmitEvent for observability\n  , EffectMeta \"RequestInput\"    Yielded  Blocking       -- RequestChoice/RequestText (user input)\n  , EffectMeta \"QuestionUI\"      Yielded  Blocking       -- AskQuestion (structured questions)\n  ]\n\n\n-- | Convert EffectCategory to Text for codegen.\n", "criteria": "CRITERIA_0025", "selected": "SELECTED_0025", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "allEffectMeta", "range": {"end": {"character": 13, "line": 93}, "start": {"character": 0, "line": 93}}}
{"example_id": "0026", "variation": "positive_semantic", "code": "allEffectMeta =\n  -- Core IO-blind effects\n  [ EffectMeta \"Log\"             Internal FireAndForget  -- LogMsg with various levels\n  , EffectMeta \"LLM\"             Internal Blocking       -- RunTurnOp (tool-aware LLM calls)\n  , EffectMeta \"State\"           Internal Blocking       -- Get/Put for agent state\n  , EffectMeta \"Random\"          Internal Blocking       -- RandomInt/RandomDouble\n  , EffectMeta \"Time\"            Internal Blocking       -- GetCurrentTime\n  , EffectMeta \"ChatHistory\"     Internal Blocking       -- GetHistory/AppendMessages\n  , EffectMeta \"Emit\"            Yielded  FireAndForget  -- EmitEvent for observability\n  , EffectMeta \"RequestInput\"    Yielded  Blocking       -- RequestChoice/RequestText (user input)\n  , EffectMeta \"QuestionUI\"      Yielded  Blocking       -- AskQuestion (structured questions)\n  ]\n\n\n-- | Convert EffectCategory to Text for codegen.\n", "criteria": "CRITERIA_0026", "selected": "SELECTED_0026", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "allEffectMeta", "range": {"end": {"character": 13, "line": 93}, "start": {"character": 0, "line": 93}}}
{"example_id": "0027", "variation": "negative_1", "code": "allEffectMeta =\n  -- Core IO-blind effects\n  [ EffectMeta \"Log\"             Internal FireAndForget  -- LogMsg with various levels\n  , EffectMeta \"LLM\"             Internal Blocking       -- RunTurnOp (tool-aware LLM calls)\n  , EffectMeta \"State\"           Internal Blocking       -- Get/Put for agent state\n  , EffectMeta \"Random\"          Internal Blocking       -- RandomInt/RandomDouble\n  , EffectMeta \"Time\"            Internal Blocking       -- GetCurrentTime\n  , EffectMeta \"ChatHistory\"     Internal Blocking       -- GetHistory/AppendMessages\n  , EffectMeta \"Emit\"            Yielded  FireAndForget  -- EmitEvent for observability\n  , EffectMeta \"RequestInput\"    Yielded  Blocking       -- RequestChoice/RequestText (user input)\n  , EffectMeta \"QuestionUI\"      Yielded  Blocking       -- AskQuestion (structured questions)\n  ]\n\n\n-- | Convert EffectCategory to Text for codegen.\n", "criteria": "CRITERIA_0027", "selected": "SELECTED_0027", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "allEffectMeta", "range": {"end": {"character": 13, "line": 93}, "start": {"character": 0, "line": 93}}}
{"example_id": "0028", "variation": "negative_2", "code": "allEffectMeta =\n  -- Core IO-blind effects\n  [ EffectMeta \"Log\"             Internal FireAndForget  -- LogMsg with various levels\n  , EffectMeta \"LLM\"             Internal Blocking       -- RunTurnOp (tool-aware LLM calls)\n  , EffectMeta \"State\"           Internal Blocking       -- Get/Put for agent state\n  , EffectMeta \"Random\"          Internal Blocking       -- RandomInt/RandomDouble\n  , EffectMeta \"Time\"            Internal Blocking       -- GetCurrentTime\n  , EffectMeta \"ChatHistory\"     Internal Blocking       -- GetHistory/AppendMessages\n  , EffectMeta \"Emit\"            Yielded  FireAndForget  -- EmitEvent for observability\n  , EffectMeta \"RequestInput\"    Yielded  Blocking       -- RequestChoice/RequestText (user input)\n  , EffectMeta \"QuestionUI\"      Yielded  Blocking       -- AskQuestion (structured questions)\n  ]\n\n\n-- | Convert EffectCategory to Text for codegen.\n", "criteria": "CRITERIA_0028", "selected": "SELECTED_0028", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "allEffectMeta", "range": {"end": {"character": 13, "line": 93}, "start": {"character": 0, "line": 93}}}
{"example_id": "0029", "variation": "positive_structure", "code": "categoryToText Internal = \"internal\"\n", "criteria": "CRITERIA_0029", "selected": "SELECTED_0029", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "categoryToText", "range": {"end": {"character": 14, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0030", "variation": "positive_semantic", "code": "categoryToText Internal = \"internal\"\n", "criteria": "CRITERIA_0030", "selected": "SELECTED_0030", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "categoryToText", "range": {"end": {"character": 14, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0031", "variation": "negative_1", "code": "categoryToText Internal = \"internal\"\n", "criteria": "CRITERIA_0031", "selected": "SELECTED_0031", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "categoryToText", "range": {"end": {"character": 14, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0032", "variation": "negative_2", "code": "categoryToText Internal = \"internal\"\n", "criteria": "CRITERIA_0032", "selected": "SELECTED_0032", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "categoryToText", "range": {"end": {"character": 14, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0033", "variation": "positive_structure", "code": "semanticsToText FireAndForget = \"fire_and_forget\"\n", "criteria": "CRITERIA_0033", "selected": "SELECTED_0033", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "semanticsToText", "range": {"end": {"character": 15, "line": 114}, "start": {"character": 0, "line": 114}}}
{"example_id": "0034", "variation": "positive_semantic", "code": "semanticsToText FireAndForget = \"fire_and_forget\"\n", "criteria": "CRITERIA_0034", "selected": "SELECTED_0034", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "semanticsToText", "range": {"end": {"character": 15, "line": 114}, "start": {"character": 0, "line": 114}}}
{"example_id": "0035", "variation": "negative_1", "code": "semanticsToText FireAndForget = \"fire_and_forget\"\n", "criteria": "CRITERIA_0035", "selected": "SELECTED_0035", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "semanticsToText", "range": {"end": {"character": 15, "line": 114}, "start": {"character": 0, "line": 114}}}
{"example_id": "0036", "variation": "negative_2", "code": "semanticsToText FireAndForget = \"fire_and_forget\"\n", "criteria": "CRITERIA_0036", "selected": "SELECTED_0036", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Metadata.hs", "name": "semanticsToText", "range": {"end": {"character": 15, "line": 114}, "start": {"character": 0, "line": 114}}}
{"example_id": "0037", "variation": "positive_structure", "code": "customError path msg = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = \"\"\n  , pdActual = \"\"\n  , pdMessage = msg\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- VALUE DESCRIPTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Describe a JSON value for error messages.\n--\n-- Truncates long strings and summarizes structures.\n", "criteria": "CRITERIA_0037", "selected": "SELECTED_0037", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "customError", "range": {"end": {"character": 11, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0038", "variation": "positive_semantic", "code": "customError path msg = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = \"\"\n  , pdActual = \"\"\n  , pdMessage = msg\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- VALUE DESCRIPTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Describe a JSON value for error messages.\n--\n-- Truncates long strings and summarizes structures.\n", "criteria": "CRITERIA_0038", "selected": "SELECTED_0038", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "customError", "range": {"end": {"character": 11, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0039", "variation": "negative_1", "code": "customError path msg = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = \"\"\n  , pdActual = \"\"\n  , pdMessage = msg\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- VALUE DESCRIPTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Describe a JSON value for error messages.\n--\n-- Truncates long strings and summarizes structures.\n", "criteria": "CRITERIA_0039", "selected": "SELECTED_0039", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "customError", "range": {"end": {"character": 11, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0040", "variation": "negative_2", "code": "customError path msg = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = \"\"\n  , pdActual = \"\"\n  , pdMessage = msg\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- VALUE DESCRIPTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Describe a JSON value for error messages.\n--\n-- Truncates long strings and summarizes structures.\n", "criteria": "CRITERIA_0040", "selected": "SELECTED_0040", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "customError", "range": {"end": {"character": 11, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0041", "variation": "positive_structure", "code": "describeValue = \\case\n  Object o -> \"object with \" <> T.pack (show (length o)) <> \" fields\"\n  Array a -> \"array with \" <> T.pack (show (length a)) <> \" items\"\n  String s\n    | T.length s <= 30 -> \"string: \\\"\" <> s <> \"\\\"\"\n    | otherwise -> \"string: \\\"\" <> T.take 30 s <> \"...\\\"\"\n  Number n -> case floatingOrInteger n of\n    Left (d :: Double) -> \"number: \" <> T.pack (show d)\n    Right (i :: Integer) -> \"integer: \" <> T.pack (show i)\n  Bool b -> \"boolean: \" <> if b then \"true\" else \"false\"\n  Null -> \"null\"\n", "criteria": "CRITERIA_0041", "selected": "SELECTED_0041", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "describeValue", "range": {"end": {"character": 13, "line": 126}, "start": {"character": 0, "line": 126}}}
{"example_id": "0042", "variation": "positive_semantic", "code": "describeValue = \\case\n  Object o -> \"object with \" <> T.pack (show (length o)) <> \" fields\"\n  Array a -> \"array with \" <> T.pack (show (length a)) <> \" items\"\n  String s\n    | T.length s <= 30 -> \"string: \\\"\" <> s <> \"\\\"\"\n    | otherwise -> \"string: \\\"\" <> T.take 30 s <> \"...\\\"\"\n  Number n -> case floatingOrInteger n of\n    Left (d :: Double) -> \"number: \" <> T.pack (show d)\n    Right (i :: Integer) -> \"integer: \" <> T.pack (show i)\n  Bool b -> \"boolean: \" <> if b then \"true\" else \"false\"\n  Null -> \"null\"\n", "criteria": "CRITERIA_0042", "selected": "SELECTED_0042", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "describeValue", "range": {"end": {"character": 13, "line": 126}, "start": {"character": 0, "line": 126}}}
{"example_id": "0043", "variation": "negative_1", "code": "describeValue = \\case\n  Object o -> \"object with \" <> T.pack (show (length o)) <> \" fields\"\n  Array a -> \"array with \" <> T.pack (show (length a)) <> \" items\"\n  String s\n    | T.length s <= 30 -> \"string: \\\"\" <> s <> \"\\\"\"\n    | otherwise -> \"string: \\\"\" <> T.take 30 s <> \"...\\\"\"\n  Number n -> case floatingOrInteger n of\n    Left (d :: Double) -> \"number: \" <> T.pack (show d)\n    Right (i :: Integer) -> \"integer: \" <> T.pack (show i)\n  Bool b -> \"boolean: \" <> if b then \"true\" else \"false\"\n  Null -> \"null\"\n", "criteria": "CRITERIA_0043", "selected": "SELECTED_0043", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "describeValue", "range": {"end": {"character": 13, "line": 126}, "start": {"character": 0, "line": 126}}}
{"example_id": "0044", "variation": "negative_2", "code": "describeValue = \\case\n  Object o -> \"object with \" <> T.pack (show (length o)) <> \" fields\"\n  Array a -> \"array with \" <> T.pack (show (length a)) <> \" items\"\n  String s\n    | T.length s <= 30 -> \"string: \\\"\" <> s <> \"\\\"\"\n    | otherwise -> \"string: \\\"\" <> T.take 30 s <> \"...\\\"\"\n  Number n -> case floatingOrInteger n of\n    Left (d :: Double) -> \"number: \" <> T.pack (show d)\n    Right (i :: Integer) -> \"integer: \" <> T.pack (show i)\n  Bool b -> \"boolean: \" <> if b then \"true\" else \"false\"\n  Null -> \"null\"\n", "criteria": "CRITERIA_0044", "selected": "SELECTED_0044", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "describeValue", "range": {"end": {"character": 13, "line": 126}, "start": {"character": 0, "line": 126}}}
{"example_id": "0045", "variation": "positive_structure", "code": "expectedArray path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"array\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected JSON array but got \" <> describeValue v\n  }\n\n-- | Error for when a string was expected.\n", "criteria": "CRITERIA_0045", "selected": "SELECTED_0045", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedArray", "range": {"end": {"character": 13, "line": 49}, "start": {"character": 0, "line": 49}}}
{"example_id": "0046", "variation": "positive_semantic", "code": "expectedArray path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"array\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected JSON array but got \" <> describeValue v\n  }\n\n-- | Error for when a string was expected.\n", "criteria": "CRITERIA_0046", "selected": "SELECTED_0046", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedArray", "range": {"end": {"character": 13, "line": 49}, "start": {"character": 0, "line": 49}}}
{"example_id": "0047", "variation": "negative_1", "code": "expectedArray path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"array\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected JSON array but got \" <> describeValue v\n  }\n\n-- | Error for when a string was expected.\n", "criteria": "CRITERIA_0047", "selected": "SELECTED_0047", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedArray", "range": {"end": {"character": 13, "line": 49}, "start": {"character": 0, "line": 49}}}
{"example_id": "0048", "variation": "negative_2", "code": "expectedArray path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"array\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected JSON array but got \" <> describeValue v\n  }\n\n-- | Error for when a string was expected.\n", "criteria": "CRITERIA_0048", "selected": "SELECTED_0048", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedArray", "range": {"end": {"character": 13, "line": 49}, "start": {"character": 0, "line": 49}}}
{"example_id": "0049", "variation": "positive_structure", "code": "expectedBool path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"boolean\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected boolean but got \" <> describeValue v\n  }\n\n-- | Error for a missing required field.\n", "criteria": "CRITERIA_0049", "selected": "SELECTED_0049", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedBool", "range": {"end": {"character": 12, "line": 76}, "start": {"character": 0, "line": 76}}}
{"example_id": "0050", "variation": "positive_semantic", "code": "expectedBool path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"boolean\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected boolean but got \" <> describeValue v\n  }\n\n-- | Error for a missing required field.\n", "criteria": "CRITERIA_0050", "selected": "SELECTED_0050", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedBool", "range": {"end": {"character": 12, "line": 76}, "start": {"character": 0, "line": 76}}}
{"example_id": "0051", "variation": "negative_1", "code": "expectedBool path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"boolean\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected boolean but got \" <> describeValue v\n  }\n\n-- | Error for a missing required field.\n", "criteria": "CRITERIA_0051", "selected": "SELECTED_0051", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedBool", "range": {"end": {"character": 12, "line": 76}, "start": {"character": 0, "line": 76}}}
{"example_id": "0052", "variation": "negative_2", "code": "expectedBool path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"boolean\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected boolean but got \" <> describeValue v\n  }\n\n-- | Error for a missing required field.\n", "criteria": "CRITERIA_0052", "selected": "SELECTED_0052", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedBool", "range": {"end": {"character": 12, "line": 76}, "start": {"character": 0, "line": 76}}}
{"example_id": "0053", "variation": "positive_structure", "code": "expectedNumber path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"number\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected number but got \" <> describeValue v\n  }\n\n-- | Error for when a boolean was expected.\n", "criteria": "CRITERIA_0053", "selected": "SELECTED_0053", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedNumber", "range": {"end": {"character": 14, "line": 67}, "start": {"character": 0, "line": 67}}}
{"example_id": "0054", "variation": "positive_semantic", "code": "expectedNumber path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"number\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected number but got \" <> describeValue v\n  }\n\n-- | Error for when a boolean was expected.\n", "criteria": "CRITERIA_0054", "selected": "SELECTED_0054", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedNumber", "range": {"end": {"character": 14, "line": 67}, "start": {"character": 0, "line": 67}}}
{"example_id": "0055", "variation": "negative_1", "code": "expectedNumber path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"number\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected number but got \" <> describeValue v\n  }\n\n-- | Error for when a boolean was expected.\n", "criteria": "CRITERIA_0055", "selected": "SELECTED_0055", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedNumber", "range": {"end": {"character": 14, "line": 67}, "start": {"character": 0, "line": 67}}}
{"example_id": "0056", "variation": "negative_2", "code": "expectedNumber path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"number\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected number but got \" <> describeValue v\n  }\n\n-- | Error for when a boolean was expected.\n", "criteria": "CRITERIA_0056", "selected": "SELECTED_0056", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedNumber", "range": {"end": {"character": 14, "line": 67}, "start": {"character": 0, "line": 67}}}
{"example_id": "0057", "variation": "positive_structure", "code": "expectedObject path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"object\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected JSON object but got \" <> describeValue v\n  }\n\n-- | Error for when an array was expected.\n", "criteria": "CRITERIA_0057", "selected": "SELECTED_0057", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedObject", "range": {"end": {"character": 14, "line": 40}, "start": {"character": 0, "line": 40}}}
{"example_id": "0058", "variation": "positive_semantic", "code": "expectedObject path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"object\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected JSON object but got \" <> describeValue v\n  }\n\n-- | Error for when an array was expected.\n", "criteria": "CRITERIA_0058", "selected": "SELECTED_0058", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedObject", "range": {"end": {"character": 14, "line": 40}, "start": {"character": 0, "line": 40}}}
{"example_id": "0059", "variation": "negative_1", "code": "expectedObject path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"object\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected JSON object but got \" <> describeValue v\n  }\n\n-- | Error for when an array was expected.\n", "criteria": "CRITERIA_0059", "selected": "SELECTED_0059", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedObject", "range": {"end": {"character": 14, "line": 40}, "start": {"character": 0, "line": 40}}}
{"example_id": "0060", "variation": "negative_2", "code": "expectedObject path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"object\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected JSON object but got \" <> describeValue v\n  }\n\n-- | Error for when an array was expected.\n", "criteria": "CRITERIA_0060", "selected": "SELECTED_0060", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedObject", "range": {"end": {"character": 14, "line": 40}, "start": {"character": 0, "line": 40}}}
{"example_id": "0061", "variation": "positive_structure", "code": "expectedString path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"string\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected string but got \" <> describeValue v\n  }\n\n-- | Error for when a number was expected.\n", "criteria": "CRITERIA_0061", "selected": "SELECTED_0061", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedString", "range": {"end": {"character": 14, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0062", "variation": "positive_semantic", "code": "expectedString path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"string\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected string but got \" <> describeValue v\n  }\n\n-- | Error for when a number was expected.\n", "criteria": "CRITERIA_0062", "selected": "SELECTED_0062", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedString", "range": {"end": {"character": 14, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0063", "variation": "negative_1", "code": "expectedString path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"string\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected string but got \" <> describeValue v\n  }\n\n-- | Error for when a number was expected.\n", "criteria": "CRITERIA_0063", "selected": "SELECTED_0063", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedString", "range": {"end": {"character": 14, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0064", "variation": "negative_2", "code": "expectedString path v = ParseDiagnostic\n  { pdPath = path\n  , pdExpected = \"string\"\n  , pdActual = describeValue v\n  , pdMessage = \"Expected string but got \" <> describeValue v\n  }\n\n-- | Error for when a number was expected.\n", "criteria": "CRITERIA_0064", "selected": "SELECTED_0064", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "expectedString", "range": {"end": {"character": 14, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0065", "variation": "positive_structure", "code": "missingField path = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = \"required field\"\n  , pdActual = \"missing\"\n  , pdMessage = \"Required field '\" <> fieldName <> \"' is missing\"\n  }\n  where\n    fieldName = case path of\n      [] -> \"(unknown)\"\n      ps -> last ps\n\n-- | Generic type mismatch error.\n", "criteria": "CRITERIA_0065", "selected": "SELECTED_0065", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "missingField", "range": {"end": {"character": 12, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0066", "variation": "positive_semantic", "code": "missingField path = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = \"required field\"\n  , pdActual = \"missing\"\n  , pdMessage = \"Required field '\" <> fieldName <> \"' is missing\"\n  }\n  where\n    fieldName = case path of\n      [] -> \"(unknown)\"\n      ps -> last ps\n\n-- | Generic type mismatch error.\n", "criteria": "CRITERIA_0066", "selected": "SELECTED_0066", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "missingField", "range": {"end": {"character": 12, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0067", "variation": "negative_1", "code": "missingField path = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = \"required field\"\n  , pdActual = \"missing\"\n  , pdMessage = \"Required field '\" <> fieldName <> \"' is missing\"\n  }\n  where\n    fieldName = case path of\n      [] -> \"(unknown)\"\n      ps -> last ps\n\n-- | Generic type mismatch error.\n", "criteria": "CRITERIA_0067", "selected": "SELECTED_0067", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "missingField", "range": {"end": {"character": 12, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0068", "variation": "negative_2", "code": "missingField path = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = \"required field\"\n  , pdActual = \"missing\"\n  , pdMessage = \"Required field '\" <> fieldName <> \"' is missing\"\n  }\n  where\n    fieldName = case path of\n      [] -> \"(unknown)\"\n      ps -> last ps\n\n-- | Generic type mismatch error.\n", "criteria": "CRITERIA_0068", "selected": "SELECTED_0068", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "missingField", "range": {"end": {"character": 12, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0069", "variation": "positive_structure", "code": "typeMismatch path expected v = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = expected\n  , pdActual = describeValue v\n  , pdMessage = \"Type mismatch: expected \" <> expected <> \" but got \" <> describeValue v\n  }\n\n-- | Custom error with user-provided message.\n", "criteria": "CRITERIA_0069", "selected": "SELECTED_0069", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "typeMismatch", "range": {"end": {"character": 12, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0070", "variation": "positive_semantic", "code": "typeMismatch path expected v = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = expected\n  , pdActual = describeValue v\n  , pdMessage = \"Type mismatch: expected \" <> expected <> \" but got \" <> describeValue v\n  }\n\n-- | Custom error with user-provided message.\n", "criteria": "CRITERIA_0070", "selected": "SELECTED_0070", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "typeMismatch", "range": {"end": {"character": 12, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0071", "variation": "negative_1", "code": "typeMismatch path expected v = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = expected\n  , pdActual = describeValue v\n  , pdMessage = \"Type mismatch: expected \" <> expected <> \" but got \" <> describeValue v\n  }\n\n-- | Custom error with user-provided message.\n", "criteria": "CRITERIA_0071", "selected": "SELECTED_0071", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "typeMismatch", "range": {"end": {"character": 12, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0072", "variation": "negative_2", "code": "typeMismatch path expected v = ParseDiagnostic\n  {\n    pdPath = path\n  , pdExpected = expected\n  , pdActual = describeValue v\n  , pdMessage = \"Type mismatch: expected \" <> expected <> \" but got \" <> describeValue v\n  }\n\n-- | Custom error with user-provided message.\n", "criteria": "CRITERIA_0072", "selected": "SELECTED_0072", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Error.hs", "name": "typeMismatch", "range": {"end": {"character": 12, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0073", "variation": "positive_structure", "code": "complete provider config msg tools = send (Complete provider config msg tools)\n\n-- | Call an LLM with provider-specific config, returning errors as 'Either'.\n--\n-- Use this when you want to handle errors gracefully:\n--\n-- @\n-- result <- completeTry SAnthropic config msg tools\n-- case result of\n--   Left LLMRateLimited -> do\n--     liftIO $ threadDelay 1000000\n--     completeTry SAnthropic config msg tools  -- retry\n--   Left err -> logError $ \"LLM failed: \" <> show err\n--   Right response -> processResponse response\n-- @\n", "criteria": "CRITERIA_0073", "selected": "SELECTED_0073", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/LLMProvider.hs", "name": "complete", "range": {"end": {"character": 8, "line": 341}, "start": {"character": 0, "line": 341}}}
{"example_id": "0074", "variation": "positive_semantic", "code": "complete provider config msg tools = send (Complete provider config msg tools)\n\n-- | Call an LLM with provider-specific config, returning errors as 'Either'.\n--\n-- Use this when you want to handle errors gracefully:\n--\n-- @\n-- result <- completeTry SAnthropic config msg tools\n-- case result of\n--   Left LLMRateLimited -> do\n--     liftIO $ threadDelay 1000000\n--     completeTry SAnthropic config msg tools  -- retry\n--   Left err -> logError $ \"LLM failed: \" <> show err\n--   Right response -> processResponse response\n-- @\n", "criteria": "CRITERIA_0074", "selected": "SELECTED_0074", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/LLMProvider.hs", "name": "complete", "range": {"end": {"character": 8, "line": 341}, "start": {"character": 0, "line": 341}}}
{"example_id": "0075", "variation": "negative_1", "code": "complete provider config msg tools = send (Complete provider config msg tools)\n\n-- | Call an LLM with provider-specific config, returning errors as 'Either'.\n--\n-- Use this when you want to handle errors gracefully:\n--\n-- @\n-- result <- completeTry SAnthropic config msg tools\n-- case result of\n--   Left LLMRateLimited -> do\n--     liftIO $ threadDelay 1000000\n--     completeTry SAnthropic config msg tools  -- retry\n--   Left err -> logError $ \"LLM failed: \" <> show err\n--   Right response -> processResponse response\n-- @\n", "criteria": "CRITERIA_0075", "selected": "SELECTED_0075", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/LLMProvider.hs", "name": "complete", "range": {"end": {"character": 8, "line": 341}, "start": {"character": 0, "line": 341}}}
{"example_id": "0076", "variation": "negative_2", "code": "complete provider config msg tools = send (Complete provider config msg tools)\n\n-- | Call an LLM with provider-specific config, returning errors as 'Either'.\n--\n-- Use this when you want to handle errors gracefully:\n--\n-- @\n-- result <- completeTry SAnthropic config msg tools\n-- case result of\n--   Left LLMRateLimited -> do\n--     liftIO $ threadDelay 1000000\n--     completeTry SAnthropic config msg tools  -- retry\n--   Left err -> logError $ \"LLM failed: \" <> show err\n--   Right response -> processResponse response\n-- @\n", "criteria": "CRITERIA_0076", "selected": "SELECTED_0076", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/LLMProvider.hs", "name": "complete", "range": {"end": {"character": 8, "line": 341}, "start": {"character": 0, "line": 341}}}
{"example_id": "0077", "variation": "positive_structure", "code": "completeTry provider config msg tools = send (CompleteTry provider config msg tools)\n", "criteria": "CRITERIA_0077", "selected": "SELECTED_0077", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/LLMProvider.hs", "name": "completeTry", "range": {"end": {"character": 11, "line": 363}, "start": {"character": 0, "line": 363}}}
{"example_id": "0078", "variation": "positive_semantic", "code": "completeTry provider config msg tools = send (CompleteTry provider config msg tools)\n", "criteria": "CRITERIA_0078", "selected": "SELECTED_0078", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/LLMProvider.hs", "name": "completeTry", "range": {"end": {"character": 11, "line": 363}, "start": {"character": 0, "line": 363}}}
{"example_id": "0079", "variation": "negative_1", "code": "completeTry provider config msg tools = send (CompleteTry provider config msg tools)\n", "criteria": "CRITERIA_0079", "selected": "SELECTED_0079", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/LLMProvider.hs", "name": "completeTry", "range": {"end": {"character": 11, "line": 363}, "start": {"character": 0, "line": 363}}}
{"example_id": "0080", "variation": "negative_2", "code": "completeTry provider config msg tools = send (CompleteTry provider config msg tools)\n", "criteria": "CRITERIA_0080", "selected": "SELECTED_0080", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/LLMProvider.hs", "name": "completeTry", "range": {"end": {"character": 11, "line": 363}, "start": {"character": 0, "line": 363}}}
{"example_id": "0081", "variation": "positive_structure", "code": "arraySchema items = (emptySchema TArray) { schemaItems = Just items }\n\n-- | Enum schema combinator\n", "criteria": "CRITERIA_0081", "selected": "SELECTED_0081", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "arraySchema", "range": {"end": {"character": 11, "line": 88}, "start": {"character": 0, "line": 88}}}
{"example_id": "0082", "variation": "positive_semantic", "code": "arraySchema items = (emptySchema TArray) { schemaItems = Just items }\n\n-- | Enum schema combinator\n", "criteria": "CRITERIA_0082", "selected": "SELECTED_0082", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "arraySchema", "range": {"end": {"character": 11, "line": 88}, "start": {"character": 0, "line": 88}}}
{"example_id": "0083", "variation": "negative_1", "code": "arraySchema items = (emptySchema TArray) { schemaItems = Just items }\n\n-- | Enum schema combinator\n", "criteria": "CRITERIA_0083", "selected": "SELECTED_0083", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "arraySchema", "range": {"end": {"character": 11, "line": 88}, "start": {"character": 0, "line": 88}}}
{"example_id": "0084", "variation": "negative_2", "code": "arraySchema items = (emptySchema TArray) { schemaItems = Just items }\n\n-- | Enum schema combinator\n", "criteria": "CRITERIA_0084", "selected": "SELECTED_0084", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "arraySchema", "range": {"end": {"character": 11, "line": 88}, "start": {"character": 0, "line": 88}}}
{"example_id": "0085", "variation": "positive_structure", "code": "deriveHasJSONSchema typeName = do\n  schemaExp <- deriveJSONSchema typeName\n  [d| instance HasJSONSchema $(conT typeName) where\n        jsonSchema = $(pure schemaExp)\n    |]\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- SCHEMA MARKER TRAITS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Marker class for types whose JSON schema uses oneOf.\n", "criteria": "CRITERIA_0085", "selected": "SELECTED_0085", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveHasJSONSchema", "range": {"end": {"character": 19, "line": 224}, "start": {"character": 0, "line": 224}}}
{"example_id": "0086", "variation": "positive_semantic", "code": "deriveHasJSONSchema typeName = do\n  schemaExp <- deriveJSONSchema typeName\n  [d| instance HasJSONSchema $(conT typeName) where\n        jsonSchema = $(pure schemaExp)\n    |]\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- SCHEMA MARKER TRAITS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Marker class for types whose JSON schema uses oneOf.\n", "criteria": "CRITERIA_0086", "selected": "SELECTED_0086", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveHasJSONSchema", "range": {"end": {"character": 19, "line": 224}, "start": {"character": 0, "line": 224}}}
{"example_id": "0087", "variation": "negative_1", "code": "deriveHasJSONSchema typeName = do\n  schemaExp <- deriveJSONSchema typeName\n  [d| instance HasJSONSchema $(conT typeName) where\n        jsonSchema = $(pure schemaExp)\n    |]\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- SCHEMA MARKER TRAITS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Marker class for types whose JSON schema uses oneOf.\n", "criteria": "CRITERIA_0087", "selected": "SELECTED_0087", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveHasJSONSchema", "range": {"end": {"character": 19, "line": 224}, "start": {"character": 0, "line": 224}}}
{"example_id": "0088", "variation": "negative_2", "code": "deriveHasJSONSchema typeName = do\n  schemaExp <- deriveJSONSchema typeName\n  [d| instance HasJSONSchema $(conT typeName) where\n        jsonSchema = $(pure schemaExp)\n    |]\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- SCHEMA MARKER TRAITS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Marker class for types whose JSON schema uses oneOf.\n", "criteria": "CRITERIA_0088", "selected": "SELECTED_0088", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveHasJSONSchema", "range": {"end": {"character": 19, "line": 224}, "start": {"character": 0, "line": 224}}}
{"example_id": "0089", "variation": "positive_structure", "code": "deriveJSONSchema typeName = do\n  info <- reify typeName\n  case info of\n    -- Single-constructor record\n    TyConI (DataD _ _ _ _ [RecC conName fields] _) -> deriveFromFields conName fields\n    -- Newtype with record syntax\n    TyConI (NewtypeD _ _ _ _ (RecC conName fields) _) -> deriveFromFields conName fields\n    -- Enum: all nullary constructors\n    TyConI (DataD _ _ _ _ cons _) | all isNullaryCon cons -> deriveEnum cons\n    -- Unsupported\n    _ -> fail $ \"deriveJSONSchema: \" ++ show typeName ++ \" must be a record type or enum (all nullary constructors)\"\n  where\n    deriveFromFields conName fields = do\n      -- Derive schemas for each field, requiring Haddock docs\n      fieldSchemas <- sequence\n        [ deriveFieldSchema typeName conName idx field\n        | (idx, field) <- zip [0..] fields ]\n      let fieldInfo = [(nameBase name, typ) | (name, _, typ) <- fields]\n          propsExpr = listE [ tupE [litE (stringL fn), pure fs]\n                            | ((fn, _), fs) <- zip fieldInfo fieldSchemas ]\n          -- Only require non-Maybe fields\n          reqExpr = listE [ litE (stringL fn)\n                          | (fn, typ) <- fieldInfo\n                          , not (isMaybeType typ) ]\n      [| objectSchema (map (\\(n, s) -> (T.pack n, s)) $propsExpr) (map T.pack $reqExpr) |]\n\n    deriveEnum cons = do\n      let names = [nameBase n | NormalC n [] <- cons]\n      [| enumSchema $(listE [litE (stringL n) | n <- names]) |]\n\n    isNullaryCon (NormalC _ []) = True\n", "criteria": "CRITERIA_0089", "selected": "SELECTED_0089", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveJSONSchema", "range": {"end": {"character": 16, "line": 141}, "start": {"character": 0, "line": 141}}}
{"example_id": "0090", "variation": "positive_semantic", "code": "deriveJSONSchema typeName = do\n  info <- reify typeName\n  case info of\n    -- Single-constructor record\n    TyConI (DataD _ _ _ _ [RecC conName fields] _) -> deriveFromFields conName fields\n    -- Newtype with record syntax\n    TyConI (NewtypeD _ _ _ _ (RecC conName fields) _) -> deriveFromFields conName fields\n    -- Enum: all nullary constructors\n    TyConI (DataD _ _ _ _ cons _) | all isNullaryCon cons -> deriveEnum cons\n    -- Unsupported\n    _ -> fail $ \"deriveJSONSchema: \" ++ show typeName ++ \" must be a record type or enum (all nullary constructors)\"\n  where\n    deriveFromFields conName fields = do\n      -- Derive schemas for each field, requiring Haddock docs\n      fieldSchemas <- sequence\n        [ deriveFieldSchema typeName conName idx field\n        | (idx, field) <- zip [0..] fields ]\n      let fieldInfo = [(nameBase name, typ) | (name, _, typ) <- fields]\n          propsExpr = listE [ tupE [litE (stringL fn), pure fs]\n                            | ((fn, _), fs) <- zip fieldInfo fieldSchemas ]\n          -- Only require non-Maybe fields\n          reqExpr = listE [ litE (stringL fn)\n                          | (fn, typ) <- fieldInfo\n                          , not (isMaybeType typ) ]\n      [| objectSchema (map (\\(n, s) -> (T.pack n, s)) $propsExpr) (map T.pack $reqExpr) |]\n\n    deriveEnum cons = do\n      let names = [nameBase n | NormalC n [] <- cons]\n      [| enumSchema $(listE [litE (stringL n) | n <- names]) |]\n\n    isNullaryCon (NormalC _ []) = True\n", "criteria": "CRITERIA_0090", "selected": "SELECTED_0090", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveJSONSchema", "range": {"end": {"character": 16, "line": 141}, "start": {"character": 0, "line": 141}}}
{"example_id": "0091", "variation": "negative_1", "code": "deriveJSONSchema typeName = do\n  info <- reify typeName\n  case info of\n    -- Single-constructor record\n    TyConI (DataD _ _ _ _ [RecC conName fields] _) -> deriveFromFields conName fields\n    -- Newtype with record syntax\n    TyConI (NewtypeD _ _ _ _ (RecC conName fields) _) -> deriveFromFields conName fields\n    -- Enum: all nullary constructors\n    TyConI (DataD _ _ _ _ cons _) | all isNullaryCon cons -> deriveEnum cons\n    -- Unsupported\n    _ -> fail $ \"deriveJSONSchema: \" ++ show typeName ++ \" must be a record type or enum (all nullary constructors)\"\n  where\n    deriveFromFields conName fields = do\n      -- Derive schemas for each field, requiring Haddock docs\n      fieldSchemas <- sequence\n        [ deriveFieldSchema typeName conName idx field\n        | (idx, field) <- zip [0..] fields ]\n      let fieldInfo = [(nameBase name, typ) | (name, _, typ) <- fields]\n          propsExpr = listE [ tupE [litE (stringL fn), pure fs]\n                            | ((fn, _), fs) <- zip fieldInfo fieldSchemas ]\n          -- Only require non-Maybe fields\n          reqExpr = listE [ litE (stringL fn)\n                          | (fn, typ) <- fieldInfo\n                          , not (isMaybeType typ) ]\n      [| objectSchema (map (\\(n, s) -> (T.pack n, s)) $propsExpr) (map T.pack $reqExpr) |]\n\n    deriveEnum cons = do\n      let names = [nameBase n | NormalC n [] <- cons]\n      [| enumSchema $(listE [litE (stringL n) | n <- names]) |]\n\n    isNullaryCon (NormalC _ []) = True\n", "criteria": "CRITERIA_0091", "selected": "SELECTED_0091", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveJSONSchema", "range": {"end": {"character": 16, "line": 141}, "start": {"character": 0, "line": 141}}}
{"example_id": "0092", "variation": "negative_2", "code": "deriveJSONSchema typeName = do\n  info <- reify typeName\n  case info of\n    -- Single-constructor record\n    TyConI (DataD _ _ _ _ [RecC conName fields] _) -> deriveFromFields conName fields\n    -- Newtype with record syntax\n    TyConI (NewtypeD _ _ _ _ (RecC conName fields) _) -> deriveFromFields conName fields\n    -- Enum: all nullary constructors\n    TyConI (DataD _ _ _ _ cons _) | all isNullaryCon cons -> deriveEnum cons\n    -- Unsupported\n    _ -> fail $ \"deriveJSONSchema: \" ++ show typeName ++ \" must be a record type or enum (all nullary constructors)\"\n  where\n    deriveFromFields conName fields = do\n      -- Derive schemas for each field, requiring Haddock docs\n      fieldSchemas <- sequence\n        [ deriveFieldSchema typeName conName idx field\n        | (idx, field) <- zip [0..] fields ]\n      let fieldInfo = [(nameBase name, typ) | (name, _, typ) <- fields]\n          propsExpr = listE [ tupE [litE (stringL fn), pure fs]\n                            | ((fn, _), fs) <- zip fieldInfo fieldSchemas ]\n          -- Only require non-Maybe fields\n          reqExpr = listE [ litE (stringL fn)\n                          | (fn, typ) <- fieldInfo\n                          , not (isMaybeType typ) ]\n      [| objectSchema (map (\\(n, s) -> (T.pack n, s)) $propsExpr) (map T.pack $reqExpr) |]\n\n    deriveEnum cons = do\n      let names = [nameBase n | NormalC n [] <- cons]\n      [| enumSchema $(listE [litE (stringL n) | n <- names]) |]\n\n    isNullaryCon (NormalC _ []) = True\n", "criteria": "CRITERIA_0092", "selected": "SELECTED_0092", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveJSONSchema", "range": {"end": {"character": 16, "line": 141}, "start": {"character": 0, "line": 141}}}
{"example_id": "0093", "variation": "positive_structure", "code": "deriveUsesEnum typeName = do\n  [d| instance UsesEnum $(conT typeName) |]\n", "criteria": "CRITERIA_0093", "selected": "SELECTED_0093", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveUsesEnum", "range": {"end": {"character": 14, "line": 264}, "start": {"character": 0, "line": 264}}}
{"example_id": "0094", "variation": "positive_semantic", "code": "deriveUsesEnum typeName = do\n  [d| instance UsesEnum $(conT typeName) |]\n", "criteria": "CRITERIA_0094", "selected": "SELECTED_0094", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveUsesEnum", "range": {"end": {"character": 14, "line": 264}, "start": {"character": 0, "line": 264}}}
{"example_id": "0095", "variation": "negative_1", "code": "deriveUsesEnum typeName = do\n  [d| instance UsesEnum $(conT typeName) |]\n", "criteria": "CRITERIA_0095", "selected": "SELECTED_0095", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveUsesEnum", "range": {"end": {"character": 14, "line": 264}, "start": {"character": 0, "line": 264}}}
{"example_id": "0096", "variation": "negative_2", "code": "deriveUsesEnum typeName = do\n  [d| instance UsesEnum $(conT typeName) |]\n", "criteria": "CRITERIA_0096", "selected": "SELECTED_0096", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveUsesEnum", "range": {"end": {"character": 14, "line": 264}, "start": {"character": 0, "line": 264}}}
{"example_id": "0097", "variation": "positive_structure", "code": "deriveUsesOneOf typeName = do\n  markerInst <- [d| instance UsesOneOf $(conT typeName) |]\n  let markedInst = TySynInstD (TySynEqn Nothing\n        (AppT (ConT ''IsMarkedOneOf) (ConT typeName))\n        (PromotedT 'True))\n  pure (markerInst ++ [markedInst])\n\n-- | Derive a 'UsesEnum' instance for a type.\n", "criteria": "CRITERIA_0097", "selected": "SELECTED_0097", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveUsesOneOf", "range": {"end": {"character": 15, "line": 255}, "start": {"character": 0, "line": 255}}}
{"example_id": "0098", "variation": "positive_semantic", "code": "deriveUsesOneOf typeName = do\n  markerInst <- [d| instance UsesOneOf $(conT typeName) |]\n  let markedInst = TySynInstD (TySynEqn Nothing\n        (AppT (ConT ''IsMarkedOneOf) (ConT typeName))\n        (PromotedT 'True))\n  pure (markerInst ++ [markedInst])\n\n-- | Derive a 'UsesEnum' instance for a type.\n", "criteria": "CRITERIA_0098", "selected": "SELECTED_0098", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveUsesOneOf", "range": {"end": {"character": 15, "line": 255}, "start": {"character": 0, "line": 255}}}
{"example_id": "0099", "variation": "negative_1", "code": "deriveUsesOneOf typeName = do\n  markerInst <- [d| instance UsesOneOf $(conT typeName) |]\n  let markedInst = TySynInstD (TySynEqn Nothing\n        (AppT (ConT ''IsMarkedOneOf) (ConT typeName))\n        (PromotedT 'True))\n  pure (markerInst ++ [markedInst])\n\n-- | Derive a 'UsesEnum' instance for a type.\n", "criteria": "CRITERIA_0099", "selected": "SELECTED_0099", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveUsesOneOf", "range": {"end": {"character": 15, "line": 255}, "start": {"character": 0, "line": 255}}}
{"example_id": "0100", "variation": "negative_2", "code": "deriveUsesOneOf typeName = do\n  markerInst <- [d| instance UsesOneOf $(conT typeName) |]\n  let markedInst = TySynInstD (TySynEqn Nothing\n        (AppT (ConT ''IsMarkedOneOf) (ConT typeName))\n        (PromotedT 'True))\n  pure (markerInst ++ [markedInst])\n\n-- | Derive a 'UsesEnum' instance for a type.\n", "criteria": "CRITERIA_0100", "selected": "SELECTED_0100", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveUsesOneOf", "range": {"end": {"character": 15, "line": 255}, "start": {"character": 0, "line": 255}}}
{"example_id": "0101", "variation": "positive_structure", "code": "describeField _fieldName desc schema = schema { schemaDescription = Just desc }\n\n-- | Convert schema to Aeson Value (JSON Schema draft-07 format)\n-- Note: Anthropic API requires additionalProperties: false on all object types\n", "criteria": "CRITERIA_0101", "selected": "SELECTED_0101", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "describeField", "range": {"end": {"character": 13, "line": 100}, "start": {"character": 0, "line": 100}}}
{"example_id": "0102", "variation": "positive_semantic", "code": "describeField _fieldName desc schema = schema { schemaDescription = Just desc }\n\n-- | Convert schema to Aeson Value (JSON Schema draft-07 format)\n-- Note: Anthropic API requires additionalProperties: false on all object types\n", "criteria": "CRITERIA_0102", "selected": "SELECTED_0102", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "describeField", "range": {"end": {"character": 13, "line": 100}, "start": {"character": 0, "line": 100}}}
{"example_id": "0103", "variation": "negative_1", "code": "describeField _fieldName desc schema = schema { schemaDescription = Just desc }\n\n-- | Convert schema to Aeson Value (JSON Schema draft-07 format)\n-- Note: Anthropic API requires additionalProperties: false on all object types\n", "criteria": "CRITERIA_0103", "selected": "SELECTED_0103", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "describeField", "range": {"end": {"character": 13, "line": 100}, "start": {"character": 0, "line": 100}}}
{"example_id": "0104", "variation": "negative_2", "code": "describeField _fieldName desc schema = schema { schemaDescription = Just desc }\n\n-- | Convert schema to Aeson Value (JSON Schema draft-07 format)\n-- Note: Anthropic API requires additionalProperties: false on all object types\n", "criteria": "CRITERIA_0104", "selected": "SELECTED_0104", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "describeField", "range": {"end": {"character": 13, "line": 100}, "start": {"character": 0, "line": 100}}}
{"example_id": "0105", "variation": "positive_structure", "code": "emptySchema t = JSONSchema t Nothing Map.empty [] Nothing Nothing Nothing Nothing\n\n-- | Object schema combinator\n", "criteria": "CRITERIA_0105", "selected": "SELECTED_0105", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "emptySchema", "range": {"end": {"character": 11, "line": 77}, "start": {"character": 0, "line": 77}}}
{"example_id": "0106", "variation": "positive_semantic", "code": "emptySchema t = JSONSchema t Nothing Map.empty [] Nothing Nothing Nothing Nothing\n\n-- | Object schema combinator\n", "criteria": "CRITERIA_0106", "selected": "SELECTED_0106", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "emptySchema", "range": {"end": {"character": 11, "line": 77}, "start": {"character": 0, "line": 77}}}
{"example_id": "0107", "variation": "negative_1", "code": "emptySchema t = JSONSchema t Nothing Map.empty [] Nothing Nothing Nothing Nothing\n\n-- | Object schema combinator\n", "criteria": "CRITERIA_0107", "selected": "SELECTED_0107", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "emptySchema", "range": {"end": {"character": 11, "line": 77}, "start": {"character": 0, "line": 77}}}
{"example_id": "0108", "variation": "negative_2", "code": "emptySchema t = JSONSchema t Nothing Map.empty [] Nothing Nothing Nothing Nothing\n\n-- | Object schema combinator\n", "criteria": "CRITERIA_0108", "selected": "SELECTED_0108", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "emptySchema", "range": {"end": {"character": 11, "line": 77}, "start": {"character": 0, "line": 77}}}
{"example_id": "0109", "variation": "positive_structure", "code": "enumSchema variants = (emptySchema TString) { schemaEnum = Just variants }\n\n-- | OneOf schema combinator (for sum types)\n", "criteria": "CRITERIA_0109", "selected": "SELECTED_0109", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "enumSchema", "range": {"end": {"character": 10, "line": 92}, "start": {"character": 0, "line": 92}}}
{"example_id": "0110", "variation": "positive_semantic", "code": "enumSchema variants = (emptySchema TString) { schemaEnum = Just variants }\n\n-- | OneOf schema combinator (for sum types)\n", "criteria": "CRITERIA_0110", "selected": "SELECTED_0110", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "enumSchema", "range": {"end": {"character": 10, "line": 92}, "start": {"character": 0, "line": 92}}}
{"example_id": "0111", "variation": "negative_1", "code": "enumSchema variants = (emptySchema TString) { schemaEnum = Just variants }\n\n-- | OneOf schema combinator (for sum types)\n", "criteria": "CRITERIA_0111", "selected": "SELECTED_0111", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "enumSchema", "range": {"end": {"character": 10, "line": 92}, "start": {"character": 0, "line": 92}}}
{"example_id": "0112", "variation": "negative_2", "code": "enumSchema variants = (emptySchema TString) { schemaEnum = Just variants }\n\n-- | OneOf schema combinator (for sum types)\n", "criteria": "CRITERIA_0112", "selected": "SELECTED_0112", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "enumSchema", "range": {"end": {"character": 10, "line": 92}, "start": {"character": 0, "line": 92}}}
{"example_id": "0113", "variation": "positive_structure", "code": "objectSchema props required = (emptySchema TObject)\n  { schemaProperties = Map.fromList props\n  , schemaRequired = required\n  }\n\n-- | Array schema combinator\n", "criteria": "CRITERIA_0113", "selected": "SELECTED_0113", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "objectSchema", "range": {"end": {"character": 12, "line": 81}, "start": {"character": 0, "line": 81}}}
{"example_id": "0114", "variation": "positive_semantic", "code": "objectSchema props required = (emptySchema TObject)\n  { schemaProperties = Map.fromList props\n  , schemaRequired = required\n  }\n\n-- | Array schema combinator\n", "criteria": "CRITERIA_0114", "selected": "SELECTED_0114", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "objectSchema", "range": {"end": {"character": 12, "line": 81}, "start": {"character": 0, "line": 81}}}
{"example_id": "0115", "variation": "negative_1", "code": "objectSchema props required = (emptySchema TObject)\n  { schemaProperties = Map.fromList props\n  , schemaRequired = required\n  }\n\n-- | Array schema combinator\n", "criteria": "CRITERIA_0115", "selected": "SELECTED_0115", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "objectSchema", "range": {"end": {"character": 12, "line": 81}, "start": {"character": 0, "line": 81}}}
{"example_id": "0116", "variation": "negative_2", "code": "objectSchema props required = (emptySchema TObject)\n  { schemaProperties = Map.fromList props\n  , schemaRequired = required\n  }\n\n-- | Array schema combinator\n", "criteria": "CRITERIA_0116", "selected": "SELECTED_0116", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "objectSchema", "range": {"end": {"character": 12, "line": 81}, "start": {"character": 0, "line": 81}}}
{"example_id": "0117", "variation": "positive_structure", "code": "oneOfSchema variants = (emptySchema TObject) { schemaOneOf = Just variants }\n\n-- | Add description to schema\n", "criteria": "CRITERIA_0117", "selected": "SELECTED_0117", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "oneOfSchema", "range": {"end": {"character": 11, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0118", "variation": "positive_semantic", "code": "oneOfSchema variants = (emptySchema TObject) { schemaOneOf = Just variants }\n\n-- | Add description to schema\n", "criteria": "CRITERIA_0118", "selected": "SELECTED_0118", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "oneOfSchema", "range": {"end": {"character": 11, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0119", "variation": "negative_1", "code": "oneOfSchema variants = (emptySchema TObject) { schemaOneOf = Just variants }\n\n-- | Add description to schema\n", "criteria": "CRITERIA_0119", "selected": "SELECTED_0119", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "oneOfSchema", "range": {"end": {"character": 11, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0120", "variation": "negative_2", "code": "oneOfSchema variants = (emptySchema TObject) { schemaOneOf = Just variants }\n\n-- | Add description to schema\n", "criteria": "CRITERIA_0120", "selected": "SELECTED_0120", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "oneOfSchema", "range": {"end": {"character": 11, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0121", "variation": "positive_structure", "code": "schemaToValue (JSONSchema typ desc props req items minItems_ enum_ oneOf_) = object $ catMaybes\n  [ Just $ \"type\" .= typeToText typ\n  , (\"description\" .=) <$> desc\n  , if Map.null props\n    then Nothing\n    else Just $ \"properties\" .= fmap schemaToValue props\n  , if null req\n    then Nothing\n    else Just $ \"required\" .= req\n  -- Anthropic requires additionalProperties: false for all object types\n  , if typ == TObject\n    then Just $ \"additionalProperties\" .= False\n    else Nothing\n  , (\"items\" .=) . schemaToValue <$> items\n  , (\"minItems\" .=) <$> minItems_\n  , (\"enum\" .=) <$> enum_\n  , (\"oneOf\" .=) . fmap schemaToValue <$> oneOf_\n  ]\n\n-- | Convert schema type to JSON Schema type string\n", "criteria": "CRITERIA_0121", "selected": "SELECTED_0121", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "schemaToValue", "range": {"end": {"character": 13, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0122", "variation": "positive_semantic", "code": "schemaToValue (JSONSchema typ desc props req items minItems_ enum_ oneOf_) = object $ catMaybes\n  [ Just $ \"type\" .= typeToText typ\n  , (\"description\" .=) <$> desc\n  , if Map.null props\n    then Nothing\n    else Just $ \"properties\" .= fmap schemaToValue props\n  , if null req\n    then Nothing\n    else Just $ \"required\" .= req\n  -- Anthropic requires additionalProperties: false for all object types\n  , if typ == TObject\n    then Just $ \"additionalProperties\" .= False\n    else Nothing\n  , (\"items\" .=) . schemaToValue <$> items\n  , (\"minItems\" .=) <$> minItems_\n  , (\"enum\" .=) <$> enum_\n  , (\"oneOf\" .=) . fmap schemaToValue <$> oneOf_\n  ]\n\n-- | Convert schema type to JSON Schema type string\n", "criteria": "CRITERIA_0122", "selected": "SELECTED_0122", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "schemaToValue", "range": {"end": {"character": 13, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0123", "variation": "negative_1", "code": "schemaToValue (JSONSchema typ desc props req items minItems_ enum_ oneOf_) = object $ catMaybes\n  [ Just $ \"type\" .= typeToText typ\n  , (\"description\" .=) <$> desc\n  , if Map.null props\n    then Nothing\n    else Just $ \"properties\" .= fmap schemaToValue props\n  , if null req\n    then Nothing\n    else Just $ \"required\" .= req\n  -- Anthropic requires additionalProperties: false for all object types\n  , if typ == TObject\n    then Just $ \"additionalProperties\" .= False\n    else Nothing\n  , (\"items\" .=) . schemaToValue <$> items\n  , (\"minItems\" .=) <$> minItems_\n  , (\"enum\" .=) <$> enum_\n  , (\"oneOf\" .=) . fmap schemaToValue <$> oneOf_\n  ]\n\n-- | Convert schema type to JSON Schema type string\n", "criteria": "CRITERIA_0123", "selected": "SELECTED_0123", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "schemaToValue", "range": {"end": {"character": 13, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0124", "variation": "negative_2", "code": "schemaToValue (JSONSchema typ desc props req items minItems_ enum_ oneOf_) = object $ catMaybes\n  [ Just $ \"type\" .= typeToText typ\n  , (\"description\" .=) <$> desc\n  , if Map.null props\n    then Nothing\n    else Just $ \"properties\" .= fmap schemaToValue props\n  , if null req\n    then Nothing\n    else Just $ \"required\" .= req\n  -- Anthropic requires additionalProperties: false for all object types\n  , if typ == TObject\n    then Just $ \"additionalProperties\" .= False\n    else Nothing\n  , (\"items\" .=) . schemaToValue <$> items\n  , (\"minItems\" .=) <$> minItems_\n  , (\"enum\" .=) <$> enum_\n  , (\"oneOf\" .=) . fmap schemaToValue <$> oneOf_\n  ]\n\n-- | Convert schema type to JSON Schema type string\n", "criteria": "CRITERIA_0124", "selected": "SELECTED_0124", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "schemaToValue", "range": {"end": {"character": 13, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0125", "variation": "positive_structure", "code": "deriveFieldSchema typeName _conName _fieldIdx (fieldName, _, fieldType) = do\n  mDoc <- getDoc (DeclDoc fieldName)\n  desc <- case mDoc of\n    Just doc -> pure (T.pack doc)\n    Nothing  -> fail $ \"deriveJSONSchema: Missing documentation for field \" ++ nameBase fieldName\n  baseSchema <- typeToSchemaExp fieldType\n  [| describeField (T.pack $(litE (stringL (nameBase fieldName)))) desc $(pure baseSchema) |]\n\n-- | Convert a Haskell type to a JSONSchema expression\n", "criteria": "CRITERIA_0125", "selected": "SELECTED_0125", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveFieldSchema", "range": {"end": {"character": 17, "line": 179}, "start": {"character": 0, "line": 179}}}
{"example_id": "0126", "variation": "positive_semantic", "code": "deriveFieldSchema typeName _conName _fieldIdx (fieldName, _, fieldType) = do\n  mDoc <- getDoc (DeclDoc fieldName)\n  desc <- case mDoc of\n    Just doc -> pure (T.pack doc)\n    Nothing  -> fail $ \"deriveJSONSchema: Missing documentation for field \" ++ nameBase fieldName\n  baseSchema <- typeToSchemaExp fieldType\n  [| describeField (T.pack $(litE (stringL (nameBase fieldName)))) desc $(pure baseSchema) |]\n\n-- | Convert a Haskell type to a JSONSchema expression\n", "criteria": "CRITERIA_0126", "selected": "SELECTED_0126", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveFieldSchema", "range": {"end": {"character": 17, "line": 179}, "start": {"character": 0, "line": 179}}}
{"example_id": "0127", "variation": "negative_1", "code": "deriveFieldSchema typeName _conName _fieldIdx (fieldName, _, fieldType) = do\n  mDoc <- getDoc (DeclDoc fieldName)\n  desc <- case mDoc of\n    Just doc -> pure (T.pack doc)\n    Nothing  -> fail $ \"deriveJSONSchema: Missing documentation for field \" ++ nameBase fieldName\n  baseSchema <- typeToSchemaExp fieldType\n  [| describeField (T.pack $(litE (stringL (nameBase fieldName)))) desc $(pure baseSchema) |]\n\n-- | Convert a Haskell type to a JSONSchema expression\n", "criteria": "CRITERIA_0127", "selected": "SELECTED_0127", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveFieldSchema", "range": {"end": {"character": 17, "line": 179}, "start": {"character": 0, "line": 179}}}
{"example_id": "0128", "variation": "negative_2", "code": "deriveFieldSchema typeName _conName _fieldIdx (fieldName, _, fieldType) = do\n  mDoc <- getDoc (DeclDoc fieldName)\n  desc <- case mDoc of\n    Just doc -> pure (T.pack doc)\n    Nothing  -> fail $ \"deriveJSONSchema: Missing documentation for field \" ++ nameBase fieldName\n  baseSchema <- typeToSchemaExp fieldType\n  [| describeField (T.pack $(litE (stringL (nameBase fieldName)))) desc $(pure baseSchema) |]\n\n-- | Convert a Haskell type to a JSONSchema expression\n", "criteria": "CRITERIA_0128", "selected": "SELECTED_0128", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "deriveFieldSchema", "range": {"end": {"character": 17, "line": 179}, "start": {"character": 0, "line": 179}}}
{"example_id": "0129", "variation": "positive_structure", "code": "typeToSchemaExp typ = case typ of\n  -- Text, String, FilePath -> TString\n  ConT name | nameBase name `elem` [\"Text\", \"String\", \"FilePath\"] ->\n    [| emptySchema TString |]\n  -- Int, Integer -> TInteger\n  ConT name | nameBase name `elem` [\"Int\", \"Integer\"] ->\n    [| emptySchema TInteger |]\n  -- Double, Float -> TNumber\n  ConT name | nameBase name `elem` [\"Double\", \"Float\"] ->\n    [| emptySchema TNumber |]\n  -- Bool -> TBoolean\n  ConT name | nameBase name == \"Bool\" -> [| emptySchema TBoolean |]\n  -- [a] -> array of a\n  AppT ListT elemType -> do\n    elemSchema <- typeToSchemaExp elemType\n    [| arraySchema $(pure elemSchema) |]\n  -- Maybe a -> same as a (optional handled by not being in required)\n  AppT (ConT name) innerType | nameBase name == \"Maybe\" ->\n    typeToSchemaExp innerType\n  -- Named type with HasJSONSchema instance -> use its schema\n  ConT name -> do\n    [| jsonSchema @($(conT name)) |]\n  -- Fallback: treat as string (for complex types without HasJSONSchema)\n  _ -> [| emptySchema TString |]\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HAS JSON SCHEMA TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Typeclass for types that have a JSON Schema representation.\n", "criteria": "CRITERIA_0129", "selected": "SELECTED_0129", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "typeToSchemaExp", "range": {"end": {"character": 15, "line": 189}, "start": {"character": 0, "line": 189}}}
{"example_id": "0130", "variation": "positive_semantic", "code": "typeToSchemaExp typ = case typ of\n  -- Text, String, FilePath -> TString\n  ConT name | nameBase name `elem` [\"Text\", \"String\", \"FilePath\"] ->\n    [| emptySchema TString |]\n  -- Int, Integer -> TInteger\n  ConT name | nameBase name `elem` [\"Int\", \"Integer\"] ->\n    [| emptySchema TInteger |]\n  -- Double, Float -> TNumber\n  ConT name | nameBase name `elem` [\"Double\", \"Float\"] ->\n    [| emptySchema TNumber |]\n  -- Bool -> TBoolean\n  ConT name | nameBase name == \"Bool\" -> [| emptySchema TBoolean |]\n  -- [a] -> array of a\n  AppT ListT elemType -> do\n    elemSchema <- typeToSchemaExp elemType\n    [| arraySchema $(pure elemSchema) |]\n  -- Maybe a -> same as a (optional handled by not being in required)\n  AppT (ConT name) innerType | nameBase name == \"Maybe\" ->\n    typeToSchemaExp innerType\n  -- Named type with HasJSONSchema instance -> use its schema\n  ConT name -> do\n    [| jsonSchema @($(conT name)) |]\n  -- Fallback: treat as string (for complex types without HasJSONSchema)\n  _ -> [| emptySchema TString |]\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HAS JSON SCHEMA TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Typeclass for types that have a JSON Schema representation.\n", "criteria": "CRITERIA_0130", "selected": "SELECTED_0130", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "typeToSchemaExp", "range": {"end": {"character": 15, "line": 189}, "start": {"character": 0, "line": 189}}}
{"example_id": "0131", "variation": "negative_1", "code": "typeToSchemaExp typ = case typ of\n  -- Text, String, FilePath -> TString\n  ConT name | nameBase name `elem` [\"Text\", \"String\", \"FilePath\"] ->\n    [| emptySchema TString |]\n  -- Int, Integer -> TInteger\n  ConT name | nameBase name `elem` [\"Int\", \"Integer\"] ->\n    [| emptySchema TInteger |]\n  -- Double, Float -> TNumber\n  ConT name | nameBase name `elem` [\"Double\", \"Float\"] ->\n    [| emptySchema TNumber |]\n  -- Bool -> TBoolean\n  ConT name | nameBase name == \"Bool\" -> [| emptySchema TBoolean |]\n  -- [a] -> array of a\n  AppT ListT elemType -> do\n    elemSchema <- typeToSchemaExp elemType\n    [| arraySchema $(pure elemSchema) |]\n  -- Maybe a -> same as a (optional handled by not being in required)\n  AppT (ConT name) innerType | nameBase name == \"Maybe\" ->\n    typeToSchemaExp innerType\n  -- Named type with HasJSONSchema instance -> use its schema\n  ConT name -> do\n    [| jsonSchema @($(conT name)) |]\n  -- Fallback: treat as string (for complex types without HasJSONSchema)\n  _ -> [| emptySchema TString |]\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HAS JSON SCHEMA TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Typeclass for types that have a JSON Schema representation.\n", "criteria": "CRITERIA_0131", "selected": "SELECTED_0131", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "typeToSchemaExp", "range": {"end": {"character": 15, "line": 189}, "start": {"character": 0, "line": 189}}}
{"example_id": "0132", "variation": "negative_2", "code": "typeToSchemaExp typ = case typ of\n  -- Text, String, FilePath -> TString\n  ConT name | nameBase name `elem` [\"Text\", \"String\", \"FilePath\"] ->\n    [| emptySchema TString |]\n  -- Int, Integer -> TInteger\n  ConT name | nameBase name `elem` [\"Int\", \"Integer\"] ->\n    [| emptySchema TInteger |]\n  -- Double, Float -> TNumber\n  ConT name | nameBase name `elem` [\"Double\", \"Float\"] ->\n    [| emptySchema TNumber |]\n  -- Bool -> TBoolean\n  ConT name | nameBase name == \"Bool\" -> [| emptySchema TBoolean |]\n  -- [a] -> array of a\n  AppT ListT elemType -> do\n    elemSchema <- typeToSchemaExp elemType\n    [| arraySchema $(pure elemSchema) |]\n  -- Maybe a -> same as a (optional handled by not being in required)\n  AppT (ConT name) innerType | nameBase name == \"Maybe\" ->\n    typeToSchemaExp innerType\n  -- Named type with HasJSONSchema instance -> use its schema\n  ConT name -> do\n    [| jsonSchema @($(conT name)) |]\n  -- Fallback: treat as string (for complex types without HasJSONSchema)\n  _ -> [| emptySchema TString |]\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HAS JSON SCHEMA TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Typeclass for types that have a JSON Schema representation.\n", "criteria": "CRITERIA_0132", "selected": "SELECTED_0132", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "typeToSchemaExp", "range": {"end": {"character": 15, "line": 189}, "start": {"character": 0, "line": 189}}}
{"example_id": "0133", "variation": "positive_structure", "code": "typeToText = \\case\n  TString  -> \"string\"\n  TNumber  -> \"number\"\n  TInteger -> \"integer\"\n  TBoolean -> \"boolean\"\n  TObject  -> \"object\"\n  TArray   -> \"array\"\n  TNull    -> \"null\"\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE HASKELL DERIVATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Derive a JSONSchema from a record type, using Haddock comments as descriptions.\n", "criteria": "CRITERIA_0133", "selected": "SELECTED_0133", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "typeToText", "range": {"end": {"character": 10, "line": 126}, "start": {"character": 0, "line": 126}}}
{"example_id": "0134", "variation": "positive_semantic", "code": "typeToText = \\case\n  TString  -> \"string\"\n  TNumber  -> \"number\"\n  TInteger -> \"integer\"\n  TBoolean -> \"boolean\"\n  TObject  -> \"object\"\n  TArray   -> \"array\"\n  TNull    -> \"null\"\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE HASKELL DERIVATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Derive a JSONSchema from a record type, using Haddock comments as descriptions.\n", "criteria": "CRITERIA_0134", "selected": "SELECTED_0134", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "typeToText", "range": {"end": {"character": 10, "line": 126}, "start": {"character": 0, "line": 126}}}
{"example_id": "0135", "variation": "negative_1", "code": "typeToText = \\case\n  TString  -> \"string\"\n  TNumber  -> \"number\"\n  TInteger -> \"integer\"\n  TBoolean -> \"boolean\"\n  TObject  -> \"object\"\n  TArray   -> \"array\"\n  TNull    -> \"null\"\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE HASKELL DERIVATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Derive a JSONSchema from a record type, using Haddock comments as descriptions.\n", "criteria": "CRITERIA_0135", "selected": "SELECTED_0135", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "typeToText", "range": {"end": {"character": 10, "line": 126}, "start": {"character": 0, "line": 126}}}
{"example_id": "0136", "variation": "negative_2", "code": "typeToText = \\case\n  TString  -> \"string\"\n  TNumber  -> \"number\"\n  TInteger -> \"integer\"\n  TBoolean -> \"boolean\"\n  TObject  -> \"object\"\n  TArray   -> \"array\"\n  TNull    -> \"null\"\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE HASKELL DERIVATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Derive a JSONSchema from a record type, using Haddock comments as descriptions.\n", "criteria": "CRITERIA_0136", "selected": "SELECTED_0136", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Schema.hs", "name": "typeToText", "range": {"end": {"character": 10, "line": 126}, "start": {"character": 0, "line": 126}}}
{"example_id": "0137", "variation": "positive_structure", "code": "allNullary = all (\\(_, schema) -> isEmptyObject schema)\n\n-- | Check if a schema represents an empty object {}.\n--\n-- An empty object has type TObject with no properties and no required fields.\n", "criteria": "CRITERIA_0137", "selected": "SELECTED_0137", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "allNullary", "range": {"end": {"character": 10, "line": 302}, "start": {"character": 0, "line": 302}}}
{"example_id": "0138", "variation": "positive_semantic", "code": "allNullary = all (\\(_, schema) -> isEmptyObject schema)\n\n-- | Check if a schema represents an empty object {}.\n--\n-- An empty object has type TObject with no properties and no required fields.\n", "criteria": "CRITERIA_0138", "selected": "SELECTED_0138", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "allNullary", "range": {"end": {"character": 10, "line": 302}, "start": {"character": 0, "line": 302}}}
{"example_id": "0139", "variation": "negative_1", "code": "allNullary = all (\\(_, schema) -> isEmptyObject schema)\n\n-- | Check if a schema represents an empty object {}.\n--\n-- An empty object has type TObject with no properties and no required fields.\n", "criteria": "CRITERIA_0139", "selected": "SELECTED_0139", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "allNullary", "range": {"end": {"character": 10, "line": 302}, "start": {"character": 0, "line": 302}}}
{"example_id": "0140", "variation": "negative_2", "code": "allNullary = all (\\(_, schema) -> isEmptyObject schema)\n\n-- | Check if a schema represents an empty object {}.\n--\n-- An empty object has type TObject with no properties and no required fields.\n", "criteria": "CRITERIA_0140", "selected": "SELECTED_0140", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "allNullary", "range": {"end": {"character": 10, "line": 302}, "start": {"character": 0, "line": 302}}}
{"example_id": "0141", "variation": "positive_structure", "code": "conName' _ = conName (undefined :: M1 C c f p)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- NULLARY SUM TYPE DETECTION AND ENUM GENERATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Check if all variants have empty contents (nullary constructors).\n--\n-- For example, @data Priority = Low | Medium | High@ has all nullary constructors.\n", "criteria": "CRITERIA_0141", "selected": "SELECTED_0141", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "conName'", "range": {"end": {"character": 8, "line": 291}, "start": {"character": 0, "line": 291}}}
{"example_id": "0142", "variation": "positive_semantic", "code": "conName' _ = conName (undefined :: M1 C c f p)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- NULLARY SUM TYPE DETECTION AND ENUM GENERATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Check if all variants have empty contents (nullary constructors).\n--\n-- For example, @data Priority = Low | Medium | High@ has all nullary constructors.\n", "criteria": "CRITERIA_0142", "selected": "SELECTED_0142", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "conName'", "range": {"end": {"character": 8, "line": 291}, "start": {"character": 0, "line": 291}}}
{"example_id": "0143", "variation": "negative_1", "code": "conName' _ = conName (undefined :: M1 C c f p)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- NULLARY SUM TYPE DETECTION AND ENUM GENERATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Check if all variants have empty contents (nullary constructors).\n--\n-- For example, @data Priority = Low | Medium | High@ has all nullary constructors.\n", "criteria": "CRITERIA_0143", "selected": "SELECTED_0143", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "conName'", "range": {"end": {"character": 8, "line": 291}, "start": {"character": 0, "line": 291}}}
{"example_id": "0144", "variation": "negative_2", "code": "conName' _ = conName (undefined :: M1 C c f p)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- NULLARY SUM TYPE DETECTION AND ENUM GENERATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Check if all variants have empty contents (nullary constructors).\n--\n-- For example, @data Priority = Low | Medium | High@ has all nullary constructors.\n", "criteria": "CRITERIA_0144", "selected": "SELECTED_0144", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "conName'", "range": {"end": {"character": 8, "line": 291}, "start": {"character": 0, "line": 291}}}
{"example_id": "0145", "variation": "positive_structure", "code": "isEmptyObject (JSONSchema { schemaType = typ, schemaProperties = props, schemaRequired = req }) =\n  typ == TObject &&\n  null props &&\n  null req\n\n-- | Generate a string enum schema.\n--\n-- For nullary sum types like @data Priority = Low | Medium | High@,\n-- generates @{\"type\": \"string\", \"enum\": [\"Low\", \"Medium\", \"High\"]}@\n-- instead of wasteful oneOf with tag+contents encoding.\n", "criteria": "CRITERIA_0145", "selected": "SELECTED_0145", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "isEmptyObject", "range": {"end": {"character": 13, "line": 308}, "start": {"character": 0, "line": 308}}}
{"example_id": "0146", "variation": "positive_semantic", "code": "isEmptyObject (JSONSchema { schemaType = typ, schemaProperties = props, schemaRequired = req }) =\n  typ == TObject &&\n  null props &&\n  null req\n\n-- | Generate a string enum schema.\n--\n-- For nullary sum types like @data Priority = Low | Medium | High@,\n-- generates @{\"type\": \"string\", \"enum\": [\"Low\", \"Medium\", \"High\"]}@\n-- instead of wasteful oneOf with tag+contents encoding.\n", "criteria": "CRITERIA_0146", "selected": "SELECTED_0146", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "isEmptyObject", "range": {"end": {"character": 13, "line": 308}, "start": {"character": 0, "line": 308}}}
{"example_id": "0147", "variation": "negative_1", "code": "isEmptyObject (JSONSchema { schemaType = typ, schemaProperties = props, schemaRequired = req }) =\n  typ == TObject &&\n  null props &&\n  null req\n\n-- | Generate a string enum schema.\n--\n-- For nullary sum types like @data Priority = Low | Medium | High@,\n-- generates @{\"type\": \"string\", \"enum\": [\"Low\", \"Medium\", \"High\"]}@\n-- instead of wasteful oneOf with tag+contents encoding.\n", "criteria": "CRITERIA_0147", "selected": "SELECTED_0147", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "isEmptyObject", "range": {"end": {"character": 13, "line": 308}, "start": {"character": 0, "line": 308}}}
{"example_id": "0148", "variation": "negative_2", "code": "isEmptyObject (JSONSchema { schemaType = typ, schemaProperties = props, schemaRequired = req }) =\n  typ == TObject &&\n  null props &&\n  null req\n\n-- | Generate a string enum schema.\n--\n-- For nullary sum types like @data Priority = Low | Medium | High@,\n-- generates @{\"type\": \"string\", \"enum\": [\"Low\", \"Medium\", \"High\"]}@\n-- instead of wasteful oneOf with tag+contents encoding.\n", "criteria": "CRITERIA_0148", "selected": "SELECTED_0148", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "isEmptyObject", "range": {"end": {"character": 13, "line": 308}, "start": {"character": 0, "line": 308}}}
{"example_id": "0149", "variation": "positive_structure", "code": "prependPath prefix (ParseDiagnostic p e a m) = ParseDiagnostic (prefix ++ p) e a m\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- SUM TYPES (Multiple Constructors)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Class for handling sum type constructors.\n", "criteria": "CRITERIA_0149", "selected": "SELECTED_0149", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "prependPath", "range": {"end": {"character": 11, "line": 220}, "start": {"character": 0, "line": 220}}}
{"example_id": "0150", "variation": "positive_semantic", "code": "prependPath prefix (ParseDiagnostic p e a m) = ParseDiagnostic (prefix ++ p) e a m\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- SUM TYPES (Multiple Constructors)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Class for handling sum type constructors.\n", "criteria": "CRITERIA_0150", "selected": "SELECTED_0150", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "prependPath", "range": {"end": {"character": 11, "line": 220}, "start": {"character": 0, "line": 220}}}
{"example_id": "0151", "variation": "negative_1", "code": "prependPath prefix (ParseDiagnostic p e a m) = ParseDiagnostic (prefix ++ p) e a m\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- SUM TYPES (Multiple Constructors)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Class for handling sum type constructors.\n", "criteria": "CRITERIA_0151", "selected": "SELECTED_0151", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "prependPath", "range": {"end": {"character": 11, "line": 220}, "start": {"character": 0, "line": 220}}}
{"example_id": "0152", "variation": "negative_2", "code": "prependPath prefix (ParseDiagnostic p e a m) = ParseDiagnostic (prefix ++ p) e a m\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- SUM TYPES (Multiple Constructors)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Class for handling sum type constructors.\n", "criteria": "CRITERIA_0152", "selected": "SELECTED_0152", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "prependPath", "range": {"end": {"character": 11, "line": 220}, "start": {"character": 0, "line": 220}}}
{"example_id": "0153", "variation": "positive_structure", "code": "stringEnumSchema constructors =\n  (emptySchema TString) { schemaEnum = Just (map T.pack constructors) }\n\n\n-- | GStructuredOutput instance for sum types (multiple constructors).\n--\n-- This uses TaggedObject encoding: {\"tag\": \"Constructor\", \"contents\": {...}}\n--\n-- Special case: If ALL constructors are nullary (no data), generates a\n-- string enum instead of oneOf for efficiency and Anthropic compatibility.\n", "criteria": "CRITERIA_0153", "selected": "SELECTED_0153", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "stringEnumSchema", "range": {"end": {"character": 16, "line": 319}, "start": {"character": 0, "line": 319}}}
{"example_id": "0154", "variation": "positive_semantic", "code": "stringEnumSchema constructors =\n  (emptySchema TString) { schemaEnum = Just (map T.pack constructors) }\n\n\n-- | GStructuredOutput instance for sum types (multiple constructors).\n--\n-- This uses TaggedObject encoding: {\"tag\": \"Constructor\", \"contents\": {...}}\n--\n-- Special case: If ALL constructors are nullary (no data), generates a\n-- string enum instead of oneOf for efficiency and Anthropic compatibility.\n", "criteria": "CRITERIA_0154", "selected": "SELECTED_0154", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "stringEnumSchema", "range": {"end": {"character": 16, "line": 319}, "start": {"character": 0, "line": 319}}}
{"example_id": "0155", "variation": "negative_1", "code": "stringEnumSchema constructors =\n  (emptySchema TString) { schemaEnum = Just (map T.pack constructors) }\n\n\n-- | GStructuredOutput instance for sum types (multiple constructors).\n--\n-- This uses TaggedObject encoding: {\"tag\": \"Constructor\", \"contents\": {...}}\n--\n-- Special case: If ALL constructors are nullary (no data), generates a\n-- string enum instead of oneOf for efficiency and Anthropic compatibility.\n", "criteria": "CRITERIA_0155", "selected": "SELECTED_0155", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "stringEnumSchema", "range": {"end": {"character": 16, "line": 319}, "start": {"character": 0, "line": 319}}}
{"example_id": "0156", "variation": "negative_2", "code": "stringEnumSchema constructors =\n  (emptySchema TString) { schemaEnum = Just (map T.pack constructors) }\n\n\n-- | GStructuredOutput instance for sum types (multiple constructors).\n--\n-- This uses TaggedObject encoding: {\"tag\": \"Constructor\", \"contents\": {...}}\n--\n-- Special case: If ALL constructors are nullary (no data), generates a\n-- string enum instead of oneOf for efficiency and Anthropic compatibility.\n", "criteria": "CRITERIA_0156", "selected": "SELECTED_0156", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs", "name": "stringEnumSchema", "range": {"end": {"character": 16, "line": 319}, "start": {"character": 0, "line": 319}}}
{"example_id": "0157", "variation": "positive_structure", "code": "decisionServerName = \"decision\"\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WIRE TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | An MCP tool definition for a sum type branch.\n--\n-- @\n-- DecisionTool\n--   { dtName = \"decision::approve\"\n--   , dtDescription = \"Select the Approve branch\"\n--   , dtInputSchema = { \"type\": \"object\", \"properties\": {...} }\n--   }\n-- @\n", "criteria": "CRITERIA_0157", "selected": "SELECTED_0157", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs", "name": "decisionServerName", "range": {"end": {"character": 18, "line": 75}, "start": {"character": 0, "line": 75}}}
{"example_id": "0158", "variation": "positive_semantic", "code": "decisionServerName = \"decision\"\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WIRE TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | An MCP tool definition for a sum type branch.\n--\n-- @\n-- DecisionTool\n--   { dtName = \"decision::approve\"\n--   , dtDescription = \"Select the Approve branch\"\n--   , dtInputSchema = { \"type\": \"object\", \"properties\": {...} }\n--   }\n-- @\n", "criteria": "CRITERIA_0158", "selected": "SELECTED_0158", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs", "name": "decisionServerName", "range": {"end": {"character": 18, "line": 75}, "start": {"character": 0, "line": 75}}}
{"example_id": "0159", "variation": "negative_1", "code": "decisionServerName = \"decision\"\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WIRE TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | An MCP tool definition for a sum type branch.\n--\n-- @\n-- DecisionTool\n--   { dtName = \"decision::approve\"\n--   , dtDescription = \"Select the Approve branch\"\n--   , dtInputSchema = { \"type\": \"object\", \"properties\": {...} }\n--   }\n-- @\n", "criteria": "CRITERIA_0159", "selected": "SELECTED_0159", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs", "name": "decisionServerName", "range": {"end": {"character": 18, "line": 75}, "start": {"character": 0, "line": 75}}}
{"example_id": "0160", "variation": "negative_2", "code": "decisionServerName = \"decision\"\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WIRE TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | An MCP tool definition for a sum type branch.\n--\n-- @\n-- DecisionTool\n--   { dtName = \"decision::approve\"\n--   , dtDescription = \"Select the Approve branch\"\n--   , dtInputSchema = { \"type\": \"object\", \"properties\": {...} }\n--   }\n-- @\n", "criteria": "CRITERIA_0160", "selected": "SELECTED_0160", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs", "name": "decisionServerName", "range": {"end": {"character": 18, "line": 75}, "start": {"character": 0, "line": 75}}}
{"example_id": "0161", "variation": "positive_structure", "code": "camelToSnake = go True\n  where\n    go _ [] = []\n    go isFirst (c:cs)\n      | isUpper c =\n          let lower = toLower c\n          in if isFirst\n             then lower : go False cs\n             else '_' : lower : go False cs\n      | otherwise = c : go False cs\n", "criteria": "CRITERIA_0161", "selected": "SELECTED_0161", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 251}, "start": {"character": 0, "line": 251}}}
{"example_id": "0162", "variation": "positive_semantic", "code": "camelToSnake = go True\n  where\n    go _ [] = []\n    go isFirst (c:cs)\n      | isUpper c =\n          let lower = toLower c\n          in if isFirst\n             then lower : go False cs\n             else '_' : lower : go False cs\n      | otherwise = c : go False cs\n", "criteria": "CRITERIA_0162", "selected": "SELECTED_0162", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 251}, "start": {"character": 0, "line": 251}}}
{"example_id": "0163", "variation": "negative_1", "code": "camelToSnake = go True\n  where\n    go _ [] = []\n    go isFirst (c:cs)\n      | isUpper c =\n          let lower = toLower c\n          in if isFirst\n             then lower : go False cs\n             else '_' : lower : go False cs\n      | otherwise = c : go False cs\n", "criteria": "CRITERIA_0163", "selected": "SELECTED_0163", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 251}, "start": {"character": 0, "line": 251}}}
{"example_id": "0164", "variation": "negative_2", "code": "camelToSnake = go True\n  where\n    go _ [] = []\n    go isFirst (c:cs)\n      | isUpper c =\n          let lower = toLower c\n          in if isFirst\n             then lower : go False cs\n             else '_' : lower : go False cs\n      | otherwise = c : go False cs\n", "criteria": "CRITERIA_0164", "selected": "SELECTED_0164", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 251}, "start": {"character": 0, "line": 251}}}
{"example_id": "0165", "variation": "positive_structure", "code": "camelToSnake = concatMap go\n  where\n    go c\n      | isUpper c = ['_', toLower c]\n      | otherwise = [c]\n", "criteria": "CRITERIA_0165", "selected": "SELECTED_0165", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/MCPReify.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 162}, "start": {"character": 0, "line": 162}}}
{"example_id": "0166", "variation": "positive_semantic", "code": "camelToSnake = concatMap go\n  where\n    go c\n      | isUpper c = ['_', toLower c]\n      | otherwise = [c]\n", "criteria": "CRITERIA_0166", "selected": "SELECTED_0166", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/MCPReify.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 162}, "start": {"character": 0, "line": 162}}}
{"example_id": "0167", "variation": "negative_1", "code": "camelToSnake = concatMap go\n  where\n    go c\n      | isUpper c = ['_', toLower c]\n      | otherwise = [c]\n", "criteria": "CRITERIA_0167", "selected": "SELECTED_0167", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/MCPReify.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 162}, "start": {"character": 0, "line": 162}}}
{"example_id": "0168", "variation": "negative_2", "code": "camelToSnake = concatMap go\n  where\n    go c\n      | isUpper c = ['_', toLower c]\n      | otherwise = [c]\n", "criteria": "CRITERIA_0168", "selected": "SELECTED_0168", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/MCPReify.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 162}, "start": {"character": 0, "line": 162}}}
{"example_id": "0169", "variation": "positive_structure", "code": "camelToSnake = go True\n  where\n    go _ [] = []\n    go isFirst (c:cs)\n      | isUpper c =\n          let lower = toLower c\n          in if isFirst\n             then lower : go False cs\n             else '_' : lower : go False cs\n      | otherwise = c : go False cs\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Session effects for orchestrating dockerized Claude Code.\n--\n-- Each operation spawns a @mantle session@ process:\n--\n-- * @StartSession@ \u2192 @mantle session start --slug X --prompt Y --model Z [--json-schema S] [--decision-tools T]@\n-- * @ContinueSession@ \u2192 @mantle session continue <id> --prompt Y [--json-schema S] [--decision-tools T]@\n-- * @ForkSession@ \u2192 @mantle session fork <id> --child-slug X --child-prompt Y [--json-schema S] [--decision-tools T]@\n-- * @SessionInfo@ \u2192 @mantle session info <id>@\n--\n-- Mantle handles container lifecycle and worktree management. Haskell only\n-- sees JSON results. The slug is LLM-generated (from preceding node output)\n-- and can optionally include a phase prefix (e.g., \"implement/user-auth\").\n-- Mantle appends a hex suffix for uniqueness.\n--\n-- When a JSON schema is provided, Claude Code enforces structured output and\n", "criteria": "CRITERIA_0169", "selected": "SELECTED_0169", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 292}, "start": {"character": 0, "line": 292}}}
{"example_id": "0170", "variation": "positive_semantic", "code": "camelToSnake = go True\n  where\n    go _ [] = []\n    go isFirst (c:cs)\n      | isUpper c =\n          let lower = toLower c\n          in if isFirst\n             then lower : go False cs\n             else '_' : lower : go False cs\n      | otherwise = c : go False cs\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Session effects for orchestrating dockerized Claude Code.\n--\n-- Each operation spawns a @mantle session@ process:\n--\n-- * @StartSession@ \u2192 @mantle session start --slug X --prompt Y --model Z [--json-schema S] [--decision-tools T]@\n-- * @ContinueSession@ \u2192 @mantle session continue <id> --prompt Y [--json-schema S] [--decision-tools T]@\n-- * @ForkSession@ \u2192 @mantle session fork <id> --child-slug X --child-prompt Y [--json-schema S] [--decision-tools T]@\n-- * @SessionInfo@ \u2192 @mantle session info <id>@\n--\n-- Mantle handles container lifecycle and worktree management. Haskell only\n-- sees JSON results. The slug is LLM-generated (from preceding node output)\n-- and can optionally include a phase prefix (e.g., \"implement/user-auth\").\n-- Mantle appends a hex suffix for uniqueness.\n--\n-- When a JSON schema is provided, Claude Code enforces structured output and\n", "criteria": "CRITERIA_0170", "selected": "SELECTED_0170", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 292}, "start": {"character": 0, "line": 292}}}
{"example_id": "0171", "variation": "negative_1", "code": "camelToSnake = go True\n  where\n    go _ [] = []\n    go isFirst (c:cs)\n      | isUpper c =\n          let lower = toLower c\n          in if isFirst\n             then lower : go False cs\n             else '_' : lower : go False cs\n      | otherwise = c : go False cs\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Session effects for orchestrating dockerized Claude Code.\n--\n-- Each operation spawns a @mantle session@ process:\n--\n-- * @StartSession@ \u2192 @mantle session start --slug X --prompt Y --model Z [--json-schema S] [--decision-tools T]@\n-- * @ContinueSession@ \u2192 @mantle session continue <id> --prompt Y [--json-schema S] [--decision-tools T]@\n-- * @ForkSession@ \u2192 @mantle session fork <id> --child-slug X --child-prompt Y [--json-schema S] [--decision-tools T]@\n-- * @SessionInfo@ \u2192 @mantle session info <id>@\n--\n-- Mantle handles container lifecycle and worktree management. Haskell only\n-- sees JSON results. The slug is LLM-generated (from preceding node output)\n-- and can optionally include a phase prefix (e.g., \"implement/user-auth\").\n-- Mantle appends a hex suffix for uniqueness.\n--\n-- When a JSON schema is provided, Claude Code enforces structured output and\n", "criteria": "CRITERIA_0171", "selected": "SELECTED_0171", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 292}, "start": {"character": 0, "line": 292}}}
{"example_id": "0172", "variation": "negative_2", "code": "camelToSnake = go True\n  where\n    go _ [] = []\n    go isFirst (c:cs)\n      | isUpper c =\n          let lower = toLower c\n          in if isFirst\n             then lower : go False cs\n             else '_' : lower : go False cs\n      | otherwise = c : go False cs\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Session effects for orchestrating dockerized Claude Code.\n--\n-- Each operation spawns a @mantle session@ process:\n--\n-- * @StartSession@ \u2192 @mantle session start --slug X --prompt Y --model Z [--json-schema S] [--decision-tools T]@\n-- * @ContinueSession@ \u2192 @mantle session continue <id> --prompt Y [--json-schema S] [--decision-tools T]@\n-- * @ForkSession@ \u2192 @mantle session fork <id> --child-slug X --child-prompt Y [--json-schema S] [--decision-tools T]@\n-- * @SessionInfo@ \u2192 @mantle session info <id>@\n--\n-- Mantle handles container lifecycle and worktree management. Haskell only\n-- sees JSON results. The slug is LLM-generated (from preceding node output)\n-- and can optionally include a phase prefix (e.g., \"implement/user-auth\").\n-- Mantle appends a hex suffix for uniqueness.\n--\n-- When a JSON schema is provided, Claude Code enforces structured output and\n", "criteria": "CRITERIA_0172", "selected": "SELECTED_0172", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "camelToSnake", "range": {"end": {"character": 12, "line": 292}, "start": {"character": 0, "line": 292}}}
{"example_id": "0173", "variation": "positive_structure", "code": "noDispatcher = AgentDispatcher $ \\_ _ ->\n  pure (Right (ToolSuccess (toJSON ())))\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONFIGURATION (runtime, not behavior)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Configuration for running an agent.\n--\n-- Events stream via callback rather than accumulating in memory.\n-- This supports long sessions (DM campaigns) without memory growth.\n", "criteria": "CRITERIA_0173", "selected": "SELECTED_0173", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool.hs", "name": "noDispatcher", "range": {"end": {"character": 12, "line": 141}, "start": {"character": 0, "line": 141}}}
{"example_id": "0174", "variation": "positive_semantic", "code": "noDispatcher = AgentDispatcher $ \\_ _ ->\n  pure (Right (ToolSuccess (toJSON ())))\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONFIGURATION (runtime, not behavior)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Configuration for running an agent.\n--\n-- Events stream via callback rather than accumulating in memory.\n-- This supports long sessions (DM campaigns) without memory growth.\n", "criteria": "CRITERIA_0174", "selected": "SELECTED_0174", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool.hs", "name": "noDispatcher", "range": {"end": {"character": 12, "line": 141}, "start": {"character": 0, "line": 141}}}
{"example_id": "0175", "variation": "negative_1", "code": "noDispatcher = AgentDispatcher $ \\_ _ ->\n  pure (Right (ToolSuccess (toJSON ())))\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONFIGURATION (runtime, not behavior)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Configuration for running an agent.\n--\n-- Events stream via callback rather than accumulating in memory.\n-- This supports long sessions (DM campaigns) without memory growth.\n", "criteria": "CRITERIA_0175", "selected": "SELECTED_0175", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool.hs", "name": "noDispatcher", "range": {"end": {"character": 12, "line": 141}, "start": {"character": 0, "line": 141}}}
{"example_id": "0176", "variation": "negative_2", "code": "noDispatcher = AgentDispatcher $ \\_ _ ->\n  pure (Right (ToolSuccess (toJSON ())))\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONFIGURATION (runtime, not behavior)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Configuration for running an agent.\n--\n-- Events stream via callback rather than accumulating in memory.\n-- This supports long sessions (DM campaigns) without memory growth.\n", "criteria": "CRITERIA_0176", "selected": "SELECTED_0176", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool.hs", "name": "noDispatcher", "range": {"end": {"character": 12, "line": 141}, "start": {"character": 0, "line": 141}}}
{"example_id": "0177", "variation": "positive_structure", "code": "newMailboxIO = Mailbox <$> newTQueueIO\n\n-- | Send a message to a mailbox.\n--\n-- Non-blocking, always succeeds (unbounded queue).\n", "criteria": "CRITERIA_0177", "selected": "SELECTED_0177", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "newMailboxIO", "range": {"end": {"character": 12, "line": 30}, "start": {"character": 0, "line": 30}}}
{"example_id": "0178", "variation": "positive_semantic", "code": "newMailboxIO = Mailbox <$> newTQueueIO\n\n-- | Send a message to a mailbox.\n--\n-- Non-blocking, always succeeds (unbounded queue).\n", "criteria": "CRITERIA_0178", "selected": "SELECTED_0178", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "newMailboxIO", "range": {"end": {"character": 12, "line": 30}, "start": {"character": 0, "line": 30}}}
{"example_id": "0179", "variation": "negative_1", "code": "newMailboxIO = Mailbox <$> newTQueueIO\n\n-- | Send a message to a mailbox.\n--\n-- Non-blocking, always succeeds (unbounded queue).\n", "criteria": "CRITERIA_0179", "selected": "SELECTED_0179", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "newMailboxIO", "range": {"end": {"character": 12, "line": 30}, "start": {"character": 0, "line": 30}}}
{"example_id": "0180", "variation": "negative_2", "code": "newMailboxIO = Mailbox <$> newTQueueIO\n\n-- | Send a message to a mailbox.\n--\n-- Non-blocking, always succeeds (unbounded queue).\n", "criteria": "CRITERIA_0180", "selected": "SELECTED_0180", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "newMailboxIO", "range": {"end": {"character": 12, "line": 30}, "start": {"character": 0, "line": 30}}}
{"example_id": "0181", "variation": "positive_structure", "code": "send (Mailbox q) msg = atomically $ writeTQueue q msg\n\n-- | Receive a message from a mailbox.\n--\n-- Blocks until a message is available.\n", "criteria": "CRITERIA_0181", "selected": "SELECTED_0181", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "send", "range": {"end": {"character": 4, "line": 36}, "start": {"character": 0, "line": 36}}}
{"example_id": "0182", "variation": "positive_semantic", "code": "send (Mailbox q) msg = atomically $ writeTQueue q msg\n\n-- | Receive a message from a mailbox.\n--\n-- Blocks until a message is available.\n", "criteria": "CRITERIA_0182", "selected": "SELECTED_0182", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "send", "range": {"end": {"character": 4, "line": 36}, "start": {"character": 0, "line": 36}}}
{"example_id": "0183", "variation": "negative_1", "code": "send (Mailbox q) msg = atomically $ writeTQueue q msg\n\n-- | Receive a message from a mailbox.\n--\n-- Blocks until a message is available.\n", "criteria": "CRITERIA_0183", "selected": "SELECTED_0183", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "send", "range": {"end": {"character": 4, "line": 36}, "start": {"character": 0, "line": 36}}}
{"example_id": "0184", "variation": "negative_2", "code": "send (Mailbox q) msg = atomically $ writeTQueue q msg\n\n-- | Receive a message from a mailbox.\n--\n-- Blocks until a message is available.\n", "criteria": "CRITERIA_0184", "selected": "SELECTED_0184", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "send", "range": {"end": {"character": 4, "line": 36}, "start": {"character": 0, "line": 36}}}
{"example_id": "0185", "variation": "positive_structure", "code": "receive (Mailbox q) = atomically $ readTQueue q\n", "criteria": "CRITERIA_0185", "selected": "SELECTED_0185", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "receive", "range": {"end": {"character": 7, "line": 42}, "start": {"character": 0, "line": 42}}}
{"example_id": "0186", "variation": "positive_semantic", "code": "receive (Mailbox q) = atomically $ readTQueue q\n", "criteria": "CRITERIA_0186", "selected": "SELECTED_0186", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "receive", "range": {"end": {"character": 7, "line": 42}, "start": {"character": 0, "line": 42}}}
{"example_id": "0187", "variation": "negative_1", "code": "receive (Mailbox q) = atomically $ readTQueue q\n", "criteria": "CRITERIA_0187", "selected": "SELECTED_0187", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "receive", "range": {"end": {"character": 7, "line": 42}, "start": {"character": 0, "line": 42}}}
{"example_id": "0188", "variation": "negative_2", "code": "receive (Mailbox q) = atomically $ readTQueue q\n", "criteria": "CRITERIA_0188", "selected": "SELECTED_0188", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Mailbox.hs", "name": "receive", "range": {"end": {"character": 7, "line": 42}, "start": {"character": 0, "line": 42}}}
{"example_id": "0189", "variation": "positive_structure", "code": "commonPrefix a b = map fst $ takeWhile (uncurry (==)) $ zip a b\n\n\n-- | Lowercase the first character of a string.\n--\n-- @\n-- lcFirst \"TypeName\" = \"typeName\"\n-- lcFirst \"URL\" = \"uRL\"\n-- lcFirst \"\" = \"\"\n-- @\n", "criteria": "CRITERIA_0189", "selected": "SELECTED_0189", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "commonPrefix", "range": {"end": {"character": 12, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0190", "variation": "positive_semantic", "code": "commonPrefix a b = map fst $ takeWhile (uncurry (==)) $ zip a b\n\n\n-- | Lowercase the first character of a string.\n--\n-- @\n-- lcFirst \"TypeName\" = \"typeName\"\n-- lcFirst \"URL\" = \"uRL\"\n-- lcFirst \"\" = \"\"\n-- @\n", "criteria": "CRITERIA_0190", "selected": "SELECTED_0190", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "commonPrefix", "range": {"end": {"character": 12, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0191", "variation": "negative_1", "code": "commonPrefix a b = map fst $ takeWhile (uncurry (==)) $ zip a b\n\n\n-- | Lowercase the first character of a string.\n--\n-- @\n-- lcFirst \"TypeName\" = \"typeName\"\n-- lcFirst \"URL\" = \"uRL\"\n-- lcFirst \"\" = \"\"\n-- @\n", "criteria": "CRITERIA_0191", "selected": "SELECTED_0191", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "commonPrefix", "range": {"end": {"character": 12, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0192", "variation": "negative_2", "code": "commonPrefix a b = map fst $ takeWhile (uncurry (==)) $ zip a b\n\n\n-- | Lowercase the first character of a string.\n--\n-- @\n-- lcFirst \"TypeName\" = \"typeName\"\n-- lcFirst \"URL\" = \"uRL\"\n-- lcFirst \"\" = \"\"\n-- @\n", "criteria": "CRITERIA_0192", "selected": "SELECTED_0192", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "commonPrefix", "range": {"end": {"character": 12, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0193", "variation": "positive_structure", "code": "defaultFieldLabel = stripFieldPrefix\n\n\n-- | Create a field modifier that strips a specific prefix.\n--\n-- If the prefix is empty, returns 'lcFirst' (just lowercase first char).\n-- Otherwise, strips the exact prefix and lowercases the next character.\n--\n-- @\n-- makeStripPrefix \"td\" \"tdTypeName\"  = \"typeName\"\n-- makeStripPrefix \"td\" \"tdDataType\"  = \"dataType\"\n-- makeStripPrefix \"td\" \"otherField\"  = \"otherField\"  -- no match, unchanged\n-- makeStripPrefix \"\"   \"SomeField\"   = \"someField\"   -- empty prefix = lcFirst\n-- @\n", "criteria": "CRITERIA_0193", "selected": "SELECTED_0193", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "defaultFieldLabel", "range": {"end": {"character": 17, "line": 55}, "start": {"character": 0, "line": 55}}}
{"example_id": "0194", "variation": "positive_semantic", "code": "defaultFieldLabel = stripFieldPrefix\n\n\n-- | Create a field modifier that strips a specific prefix.\n--\n-- If the prefix is empty, returns 'lcFirst' (just lowercase first char).\n-- Otherwise, strips the exact prefix and lowercases the next character.\n--\n-- @\n-- makeStripPrefix \"td\" \"tdTypeName\"  = \"typeName\"\n-- makeStripPrefix \"td\" \"tdDataType\"  = \"dataType\"\n-- makeStripPrefix \"td\" \"otherField\"  = \"otherField\"  -- no match, unchanged\n-- makeStripPrefix \"\"   \"SomeField\"   = \"someField\"   -- empty prefix = lcFirst\n-- @\n", "criteria": "CRITERIA_0194", "selected": "SELECTED_0194", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "defaultFieldLabel", "range": {"end": {"character": 17, "line": 55}, "start": {"character": 0, "line": 55}}}
{"example_id": "0195", "variation": "negative_1", "code": "defaultFieldLabel = stripFieldPrefix\n\n\n-- | Create a field modifier that strips a specific prefix.\n--\n-- If the prefix is empty, returns 'lcFirst' (just lowercase first char).\n-- Otherwise, strips the exact prefix and lowercases the next character.\n--\n-- @\n-- makeStripPrefix \"td\" \"tdTypeName\"  = \"typeName\"\n-- makeStripPrefix \"td\" \"tdDataType\"  = \"dataType\"\n-- makeStripPrefix \"td\" \"otherField\"  = \"otherField\"  -- no match, unchanged\n-- makeStripPrefix \"\"   \"SomeField\"   = \"someField\"   -- empty prefix = lcFirst\n-- @\n", "criteria": "CRITERIA_0195", "selected": "SELECTED_0195", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "defaultFieldLabel", "range": {"end": {"character": 17, "line": 55}, "start": {"character": 0, "line": 55}}}
{"example_id": "0196", "variation": "negative_2", "code": "defaultFieldLabel = stripFieldPrefix\n\n\n-- | Create a field modifier that strips a specific prefix.\n--\n-- If the prefix is empty, returns 'lcFirst' (just lowercase first char).\n-- Otherwise, strips the exact prefix and lowercases the next character.\n--\n-- @\n-- makeStripPrefix \"td\" \"tdTypeName\"  = \"typeName\"\n-- makeStripPrefix \"td\" \"tdDataType\"  = \"dataType\"\n-- makeStripPrefix \"td\" \"otherField\"  = \"otherField\"  -- no match, unchanged\n-- makeStripPrefix \"\"   \"SomeField\"   = \"someField\"   -- empty prefix = lcFirst\n-- @\n", "criteria": "CRITERIA_0196", "selected": "SELECTED_0196", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "defaultFieldLabel", "range": {"end": {"character": 17, "line": 55}, "start": {"character": 0, "line": 55}}}
{"example_id": "0197", "variation": "positive_structure", "code": "detectPrefix [] = \"\"\n", "criteria": "CRITERIA_0197", "selected": "SELECTED_0197", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "detectPrefix", "range": {"end": {"character": 12, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0198", "variation": "positive_semantic", "code": "detectPrefix [] = \"\"\n", "criteria": "CRITERIA_0198", "selected": "SELECTED_0198", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "detectPrefix", "range": {"end": {"character": 12, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0199", "variation": "negative_1", "code": "detectPrefix [] = \"\"\n", "criteria": "CRITERIA_0199", "selected": "SELECTED_0199", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "detectPrefix", "range": {"end": {"character": 12, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0200", "variation": "negative_2", "code": "detectPrefix [] = \"\"\n", "criteria": "CRITERIA_0200", "selected": "SELECTED_0200", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "detectPrefix", "range": {"end": {"character": 12, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0201", "variation": "positive_structure", "code": "lcFirst [] = []\n", "criteria": "CRITERIA_0201", "selected": "SELECTED_0201", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "lcFirst", "range": {"end": {"character": 7, "line": 120}, "start": {"character": 0, "line": 120}}}
{"example_id": "0202", "variation": "positive_semantic", "code": "lcFirst [] = []\n", "criteria": "CRITERIA_0202", "selected": "SELECTED_0202", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "lcFirst", "range": {"end": {"character": 7, "line": 120}, "start": {"character": 0, "line": 120}}}
{"example_id": "0203", "variation": "negative_1", "code": "lcFirst [] = []\n", "criteria": "CRITERIA_0203", "selected": "SELECTED_0203", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "lcFirst", "range": {"end": {"character": 7, "line": 120}, "start": {"character": 0, "line": 120}}}
{"example_id": "0204", "variation": "negative_2", "code": "lcFirst [] = []\n", "criteria": "CRITERIA_0204", "selected": "SELECTED_0204", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Prefix.hs", "name": "lcFirst", "range": {"end": {"character": 7, "line": 120}, "start": {"character": 0, "line": 120}}}
{"example_id": "0205", "variation": "positive_structure", "code": "runGraphAsActors handlerBuilders entryPayload = do\n  -- MVar for exit result\n  exitChan <- newEmptyMVar\n\n  -- IORef for router (chicken-and-egg: router needs actors, actors need router)\n  routerRef <- newIORef (\\_ _ -> error \"Router not yet initialized\")\n\n  -- IORef for actors map\n  actorsRef <- newIORef Map.empty\n\n  Ki.scoped $ \\scope -> do\n    -- Build the real router\n    let router :: Router\n        router target payload\n          | target == \"exit\" = do\n              -- Exit: put result in MVar\n              putStrLn $ \"[GRAPH] Routing to: exit\"\n              hFlush stdout\n              case parseEither parseJSON payload of\n                Left err -> error $ \"Failed to parse exit payload: \" <> err\n                Right result -> putMVar exitChan result\n\n          | target == \"arrive\" = do\n              -- Arrive: extract barrier name and dispatch to barrier actor\n              -- Message format: { \"barrier\": \"hJoin\", \"payload\": {...} }\n              case parseArriveMessage payload of\n                Left err -> error $ \"Failed to parse arrive message: \" <> err\n                Right (barrierName, sourceName, workerPayload) -> do\n                  putStrLn $ \"[GRAPH] Routing arrive from \" <> T.unpack sourceName <> \" to barrier: \" <> T.unpack barrierName\n                  hFlush stdout\n                  actors <- readIORef actorsRef\n", "criteria": "CRITERIA_0205", "selected": "SELECTED_0205", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "runGraphAsActors", "range": {"end": {"character": 16, "line": 301}, "start": {"character": 0, "line": 301}}}
{"example_id": "0206", "variation": "positive_semantic", "code": "runGraphAsActors handlerBuilders entryPayload = do\n  -- MVar for exit result\n  exitChan <- newEmptyMVar\n\n  -- IORef for router (chicken-and-egg: router needs actors, actors need router)\n  routerRef <- newIORef (\\_ _ -> error \"Router not yet initialized\")\n\n  -- IORef for actors map\n  actorsRef <- newIORef Map.empty\n\n  Ki.scoped $ \\scope -> do\n    -- Build the real router\n    let router :: Router\n        router target payload\n          | target == \"exit\" = do\n              -- Exit: put result in MVar\n              putStrLn $ \"[GRAPH] Routing to: exit\"\n              hFlush stdout\n              case parseEither parseJSON payload of\n                Left err -> error $ \"Failed to parse exit payload: \" <> err\n                Right result -> putMVar exitChan result\n\n          | target == \"arrive\" = do\n              -- Arrive: extract barrier name and dispatch to barrier actor\n              -- Message format: { \"barrier\": \"hJoin\", \"payload\": {...} }\n              case parseArriveMessage payload of\n                Left err -> error $ \"Failed to parse arrive message: \" <> err\n                Right (barrierName, sourceName, workerPayload) -> do\n                  putStrLn $ \"[GRAPH] Routing arrive from \" <> T.unpack sourceName <> \" to barrier: \" <> T.unpack barrierName\n                  hFlush stdout\n                  actors <- readIORef actorsRef\n", "criteria": "CRITERIA_0206", "selected": "SELECTED_0206", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "runGraphAsActors", "range": {"end": {"character": 16, "line": 301}, "start": {"character": 0, "line": 301}}}
{"example_id": "0207", "variation": "negative_1", "code": "runGraphAsActors handlerBuilders entryPayload = do\n  -- MVar for exit result\n  exitChan <- newEmptyMVar\n\n  -- IORef for router (chicken-and-egg: router needs actors, actors need router)\n  routerRef <- newIORef (\\_ _ -> error \"Router not yet initialized\")\n\n  -- IORef for actors map\n  actorsRef <- newIORef Map.empty\n\n  Ki.scoped $ \\scope -> do\n    -- Build the real router\n    let router :: Router\n        router target payload\n          | target == \"exit\" = do\n              -- Exit: put result in MVar\n              putStrLn $ \"[GRAPH] Routing to: exit\"\n              hFlush stdout\n              case parseEither parseJSON payload of\n                Left err -> error $ \"Failed to parse exit payload: \" <> err\n                Right result -> putMVar exitChan result\n\n          | target == \"arrive\" = do\n              -- Arrive: extract barrier name and dispatch to barrier actor\n              -- Message format: { \"barrier\": \"hJoin\", \"payload\": {...} }\n              case parseArriveMessage payload of\n                Left err -> error $ \"Failed to parse arrive message: \" <> err\n                Right (barrierName, sourceName, workerPayload) -> do\n                  putStrLn $ \"[GRAPH] Routing arrive from \" <> T.unpack sourceName <> \" to barrier: \" <> T.unpack barrierName\n                  hFlush stdout\n                  actors <- readIORef actorsRef\n", "criteria": "CRITERIA_0207", "selected": "SELECTED_0207", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "runGraphAsActors", "range": {"end": {"character": 16, "line": 301}, "start": {"character": 0, "line": 301}}}
{"example_id": "0208", "variation": "negative_2", "code": "runGraphAsActors handlerBuilders entryPayload = do\n  -- MVar for exit result\n  exitChan <- newEmptyMVar\n\n  -- IORef for router (chicken-and-egg: router needs actors, actors need router)\n  routerRef <- newIORef (\\_ _ -> error \"Router not yet initialized\")\n\n  -- IORef for actors map\n  actorsRef <- newIORef Map.empty\n\n  Ki.scoped $ \\scope -> do\n    -- Build the real router\n    let router :: Router\n        router target payload\n          | target == \"exit\" = do\n              -- Exit: put result in MVar\n              putStrLn $ \"[GRAPH] Routing to: exit\"\n              hFlush stdout\n              case parseEither parseJSON payload of\n                Left err -> error $ \"Failed to parse exit payload: \" <> err\n                Right result -> putMVar exitChan result\n\n          | target == \"arrive\" = do\n              -- Arrive: extract barrier name and dispatch to barrier actor\n              -- Message format: { \"barrier\": \"hJoin\", \"payload\": {...} }\n              case parseArriveMessage payload of\n                Left err -> error $ \"Failed to parse arrive message: \" <> err\n                Right (barrierName, sourceName, workerPayload) -> do\n                  putStrLn $ \"[GRAPH] Routing arrive from \" <> T.unpack sourceName <> \" to barrier: \" <> T.unpack barrierName\n                  hFlush stdout\n                  actors <- readIORef actorsRef\n", "criteria": "CRITERIA_0208", "selected": "SELECTED_0208", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "runGraphAsActors", "range": {"end": {"character": 16, "line": 301}, "start": {"character": 0, "line": 301}}}
{"example_id": "0209", "variation": "positive_structure", "code": "runMemoryWithIORef ref = interpret $ \\case\n  GetMem      -> sendM $ readIORef ref\n  UpdateMem f -> sendM $ modifyIORef' ref f\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GRAPH EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Builder for creating a handler.\n--\n-- Each builder is an IO action that creates a NodeHandler. This allows\n-- handlers to initialize their own state (e.g., IORef for memory) when\n-- the actor is spawned. Each actor runs its builder once at startup.\n", "criteria": "CRITERIA_0209", "selected": "SELECTED_0209", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "runMemoryWithIORef", "range": {"end": {"character": 18, "line": 253}, "start": {"character": 0, "line": 253}}}
{"example_id": "0210", "variation": "positive_semantic", "code": "runMemoryWithIORef ref = interpret $ \\case\n  GetMem      -> sendM $ readIORef ref\n  UpdateMem f -> sendM $ modifyIORef' ref f\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GRAPH EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Builder for creating a handler.\n--\n-- Each builder is an IO action that creates a NodeHandler. This allows\n-- handlers to initialize their own state (e.g., IORef for memory) when\n-- the actor is spawned. Each actor runs its builder once at startup.\n", "criteria": "CRITERIA_0210", "selected": "SELECTED_0210", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "runMemoryWithIORef", "range": {"end": {"character": 18, "line": 253}, "start": {"character": 0, "line": 253}}}
{"example_id": "0211", "variation": "negative_1", "code": "runMemoryWithIORef ref = interpret $ \\case\n  GetMem      -> sendM $ readIORef ref\n  UpdateMem f -> sendM $ modifyIORef' ref f\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GRAPH EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Builder for creating a handler.\n--\n-- Each builder is an IO action that creates a NodeHandler. This allows\n-- handlers to initialize their own state (e.g., IORef for memory) when\n-- the actor is spawned. Each actor runs its builder once at startup.\n", "criteria": "CRITERIA_0211", "selected": "SELECTED_0211", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "runMemoryWithIORef", "range": {"end": {"character": 18, "line": 253}, "start": {"character": 0, "line": 253}}}
{"example_id": "0212", "variation": "negative_2", "code": "runMemoryWithIORef ref = interpret $ \\case\n  GetMem      -> sendM $ readIORef ref\n  UpdateMem f -> sendM $ modifyIORef' ref f\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GRAPH EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Builder for creating a handler.\n--\n-- Each builder is an IO action that creates a NodeHandler. This allows\n-- handlers to initialize their own state (e.g., IORef for memory) when\n-- the actor is spawned. Each actor runs its builder once at startup.\n", "criteria": "CRITERIA_0212", "selected": "SELECTED_0212", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "runMemoryWithIORef", "range": {"end": {"character": 18, "line": 253}, "start": {"character": 0, "line": 253}}}
{"example_id": "0213", "variation": "positive_structure", "code": "runSubgraph state = interpret $ \\case\n\n  SpawnSelf childEntry -> sendM $ do\n    -- Generate unique child ID\n    cid <- ChildId <$> nextRandom\n\n    -- Acquire semaphore before spawning (blocks if at limit)\n    case state.ssConcurrencySem of\n      Just sem -> atomically $ waitTSem sem\n      Nothing  -> pure ()\n\n    -- Spawn child graph within the ki scope\n    -- When the scope exits (parent completes or throws), all children\n    -- are automatically cancelled by ki's structured concurrency.\n    childThread <- Ki.fork state.ssScope $ do\n      -- Ensure semaphore released on all exit paths (success, failure, cancellation)\n      finally\n        (do -- Get the runner (may be deferred via IORef)\n            -- This is where the deferred binding resolves!\n            runner <- state.ssGetRunner\n\n            -- Run the full graph for this child, catching exceptions\n            -- This prevents one child's failure from killing siblings via Ki cancellation\n            -- Pass the ChildId so the runner can link child nodes to parent\n            outcome <- try @SomeException $ runner cid childEntry\n\n            let result = case outcome of\n                  Right r -> Right r\n                  Left ex -> Left $ exceptionToChildError ex\n\n            -- On completion (success OR failure):\n", "criteria": "CRITERIA_0213", "selected": "SELECTED_0213", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Subgraph.hs", "name": "runSubgraph", "range": {"end": {"character": 11, "line": 308}, "start": {"character": 0, "line": 308}}}
{"example_id": "0214", "variation": "positive_semantic", "code": "runSubgraph state = interpret $ \\case\n\n  SpawnSelf childEntry -> sendM $ do\n    -- Generate unique child ID\n    cid <- ChildId <$> nextRandom\n\n    -- Acquire semaphore before spawning (blocks if at limit)\n    case state.ssConcurrencySem of\n      Just sem -> atomically $ waitTSem sem\n      Nothing  -> pure ()\n\n    -- Spawn child graph within the ki scope\n    -- When the scope exits (parent completes or throws), all children\n    -- are automatically cancelled by ki's structured concurrency.\n    childThread <- Ki.fork state.ssScope $ do\n      -- Ensure semaphore released on all exit paths (success, failure, cancellation)\n      finally\n        (do -- Get the runner (may be deferred via IORef)\n            -- This is where the deferred binding resolves!\n            runner <- state.ssGetRunner\n\n            -- Run the full graph for this child, catching exceptions\n            -- This prevents one child's failure from killing siblings via Ki cancellation\n            -- Pass the ChildId so the runner can link child nodes to parent\n            outcome <- try @SomeException $ runner cid childEntry\n\n            let result = case outcome of\n                  Right r -> Right r\n                  Left ex -> Left $ exceptionToChildError ex\n\n            -- On completion (success OR failure):\n", "criteria": "CRITERIA_0214", "selected": "SELECTED_0214", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Subgraph.hs", "name": "runSubgraph", "range": {"end": {"character": 11, "line": 308}, "start": {"character": 0, "line": 308}}}
{"example_id": "0215", "variation": "negative_1", "code": "runSubgraph state = interpret $ \\case\n\n  SpawnSelf childEntry -> sendM $ do\n    -- Generate unique child ID\n    cid <- ChildId <$> nextRandom\n\n    -- Acquire semaphore before spawning (blocks if at limit)\n    case state.ssConcurrencySem of\n      Just sem -> atomically $ waitTSem sem\n      Nothing  -> pure ()\n\n    -- Spawn child graph within the ki scope\n    -- When the scope exits (parent completes or throws), all children\n    -- are automatically cancelled by ki's structured concurrency.\n    childThread <- Ki.fork state.ssScope $ do\n      -- Ensure semaphore released on all exit paths (success, failure, cancellation)\n      finally\n        (do -- Get the runner (may be deferred via IORef)\n            -- This is where the deferred binding resolves!\n            runner <- state.ssGetRunner\n\n            -- Run the full graph for this child, catching exceptions\n            -- This prevents one child's failure from killing siblings via Ki cancellation\n            -- Pass the ChildId so the runner can link child nodes to parent\n            outcome <- try @SomeException $ runner cid childEntry\n\n            let result = case outcome of\n                  Right r -> Right r\n                  Left ex -> Left $ exceptionToChildError ex\n\n            -- On completion (success OR failure):\n", "criteria": "CRITERIA_0215", "selected": "SELECTED_0215", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Subgraph.hs", "name": "runSubgraph", "range": {"end": {"character": 11, "line": 308}, "start": {"character": 0, "line": 308}}}
{"example_id": "0216", "variation": "negative_2", "code": "runSubgraph state = interpret $ \\case\n\n  SpawnSelf childEntry -> sendM $ do\n    -- Generate unique child ID\n    cid <- ChildId <$> nextRandom\n\n    -- Acquire semaphore before spawning (blocks if at limit)\n    case state.ssConcurrencySem of\n      Just sem -> atomically $ waitTSem sem\n      Nothing  -> pure ()\n\n    -- Spawn child graph within the ki scope\n    -- When the scope exits (parent completes or throws), all children\n    -- are automatically cancelled by ki's structured concurrency.\n    childThread <- Ki.fork state.ssScope $ do\n      -- Ensure semaphore released on all exit paths (success, failure, cancellation)\n      finally\n        (do -- Get the runner (may be deferred via IORef)\n            -- This is where the deferred binding resolves!\n            runner <- state.ssGetRunner\n\n            -- Run the full graph for this child, catching exceptions\n            -- This prevents one child's failure from killing siblings via Ki cancellation\n            -- Pass the ChildId so the runner can link child nodes to parent\n            outcome <- try @SomeException $ runner cid childEntry\n\n            let result = case outcome of\n                  Right r -> Right r\n                  Left ex -> Left $ exceptionToChildError ex\n\n            -- On completion (success OR failure):\n", "criteria": "CRITERIA_0216", "selected": "SELECTED_0216", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Subgraph.hs", "name": "runSubgraph", "range": {"end": {"character": 11, "line": 308}, "start": {"character": 0, "line": 308}}}
{"example_id": "0217", "variation": "positive_structure", "code": "runWithRetryOrFail config action = do\n  result <- withRetry config action\n  case result of\n    RetrySuccess a _ -> pure a\n    RetryFailure errs -> error $ \"All retry attempts failed: \" <> show errs\n", "criteria": "CRITERIA_0217", "selected": "SELECTED_0217", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Dispatch.hs", "name": "runWithRetryOrFail", "range": {"end": {"character": 18, "line": 156}, "start": {"character": 0, "line": 156}}}
{"example_id": "0218", "variation": "positive_semantic", "code": "runWithRetryOrFail config action = do\n  result <- withRetry config action\n  case result of\n    RetrySuccess a _ -> pure a\n    RetryFailure errs -> error $ \"All retry attempts failed: \" <> show errs\n", "criteria": "CRITERIA_0218", "selected": "SELECTED_0218", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Dispatch.hs", "name": "runWithRetryOrFail", "range": {"end": {"character": 18, "line": 156}, "start": {"character": 0, "line": 156}}}
{"example_id": "0219", "variation": "negative_1", "code": "runWithRetryOrFail config action = do\n  result <- withRetry config action\n  case result of\n    RetrySuccess a _ -> pure a\n    RetryFailure errs -> error $ \"All retry attempts failed: \" <> show errs\n", "criteria": "CRITERIA_0219", "selected": "SELECTED_0219", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Dispatch.hs", "name": "runWithRetryOrFail", "range": {"end": {"character": 18, "line": 156}, "start": {"character": 0, "line": 156}}}
{"example_id": "0220", "variation": "negative_2", "code": "runWithRetryOrFail config action = do\n  result <- withRetry config action\n  case result of\n    RetrySuccess a _ -> pure a\n    RetryFailure errs -> error $ \"All retry attempts failed: \" <> show errs\n", "criteria": "CRITERIA_0220", "selected": "SELECTED_0220", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Dispatch.hs", "name": "runWithRetryOrFail", "range": {"end": {"character": 18, "line": 156}, "start": {"character": 0, "line": 156}}}
{"example_id": "0221", "variation": "positive_structure", "code": "runLLMComplete env = interpret $ \\case\n  -- Throwing variants (for when errors are fatal)\n  Complete SAnthropic config msg tools -> sendM $ do\n    result <- anthropicRequest env config msg tools\n    case result of\n      Left err -> error $ \"LLMComplete (Anthropic): \" <> show err\n      Right resp -> pure resp\n\n  Complete SOpenAI config msg tools -> sendM $ do\n    result <- openaiRequest env config msg tools\n    case result of\n      Left err -> error $ \"LLMComplete (OpenAI): \" <> show err\n      Right resp -> pure resp\n\n  -- Try variants (for graceful error handling)\n  CompleteTry SAnthropic config msg tools -> sendM $\n    anthropicRequest env config msg tools\n\n  CompleteTry SOpenAI config msg tools -> sendM $\n    openaiRequest env config msg tools\n", "criteria": "CRITERIA_0221", "selected": "SELECTED_0221", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "runLLMComplete", "range": {"end": {"character": 14, "line": 275}, "start": {"character": 0, "line": 275}}}
{"example_id": "0222", "variation": "positive_semantic", "code": "runLLMComplete env = interpret $ \\case\n  -- Throwing variants (for when errors are fatal)\n  Complete SAnthropic config msg tools -> sendM $ do\n    result <- anthropicRequest env config msg tools\n    case result of\n      Left err -> error $ \"LLMComplete (Anthropic): \" <> show err\n      Right resp -> pure resp\n\n  Complete SOpenAI config msg tools -> sendM $ do\n    result <- openaiRequest env config msg tools\n    case result of\n      Left err -> error $ \"LLMComplete (OpenAI): \" <> show err\n      Right resp -> pure resp\n\n  -- Try variants (for graceful error handling)\n  CompleteTry SAnthropic config msg tools -> sendM $\n    anthropicRequest env config msg tools\n\n  CompleteTry SOpenAI config msg tools -> sendM $\n    openaiRequest env config msg tools\n", "criteria": "CRITERIA_0222", "selected": "SELECTED_0222", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "runLLMComplete", "range": {"end": {"character": 14, "line": 275}, "start": {"character": 0, "line": 275}}}
{"example_id": "0223", "variation": "negative_1", "code": "runLLMComplete env = interpret $ \\case\n  -- Throwing variants (for when errors are fatal)\n  Complete SAnthropic config msg tools -> sendM $ do\n    result <- anthropicRequest env config msg tools\n    case result of\n      Left err -> error $ \"LLMComplete (Anthropic): \" <> show err\n      Right resp -> pure resp\n\n  Complete SOpenAI config msg tools -> sendM $ do\n    result <- openaiRequest env config msg tools\n    case result of\n      Left err -> error $ \"LLMComplete (OpenAI): \" <> show err\n      Right resp -> pure resp\n\n  -- Try variants (for graceful error handling)\n  CompleteTry SAnthropic config msg tools -> sendM $\n    anthropicRequest env config msg tools\n\n  CompleteTry SOpenAI config msg tools -> sendM $\n    openaiRequest env config msg tools\n", "criteria": "CRITERIA_0223", "selected": "SELECTED_0223", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "runLLMComplete", "range": {"end": {"character": 14, "line": 275}, "start": {"character": 0, "line": 275}}}
{"example_id": "0224", "variation": "negative_2", "code": "runLLMComplete env = interpret $ \\case\n  -- Throwing variants (for when errors are fatal)\n  Complete SAnthropic config msg tools -> sendM $ do\n    result <- anthropicRequest env config msg tools\n    case result of\n      Left err -> error $ \"LLMComplete (Anthropic): \" <> show err\n      Right resp -> pure resp\n\n  Complete SOpenAI config msg tools -> sendM $ do\n    result <- openaiRequest env config msg tools\n    case result of\n      Left err -> error $ \"LLMComplete (OpenAI): \" <> show err\n      Right resp -> pure resp\n\n  -- Try variants (for graceful error handling)\n  CompleteTry SAnthropic config msg tools -> sendM $\n    anthropicRequest env config msg tools\n\n  CompleteTry SOpenAI config msg tools -> sendM $\n    openaiRequest env config msg tools\n", "criteria": "CRITERIA_0224", "selected": "SELECTED_0224", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "runLLMComplete", "range": {"end": {"character": 14, "line": 275}, "start": {"character": 0, "line": 275}}}
{"example_id": "0225", "variation": "positive_structure", "code": "runMcpServer cfg = runMcpServerStdio serverInfo handlers\n  where\n    serverInfo = McpServerInfo\n      { serverName = cfg.mcName\n      , serverVersion = cfg.mcVersion\n      , serverInstructions = \"Tidepool MCP Server - LLMNode as MCP tools\"\n      }\n\n    handlers = McpServerHandlers\n      { tools = Just (listTools cfg, callTool cfg)\n      , resources = Nothing\n      , prompts = Nothing\n      }\n\n-- | List available tools\n", "criteria": "CRITERIA_0225", "selected": "SELECTED_0225", "file": "haskell/effects/mcp-server/src/Tidepool/MCP/Server.hs", "name": "runMcpServer", "range": {"end": {"character": 12, "line": 54}, "start": {"character": 0, "line": 54}}}
{"example_id": "0226", "variation": "positive_semantic", "code": "runMcpServer cfg = runMcpServerStdio serverInfo handlers\n  where\n    serverInfo = McpServerInfo\n      { serverName = cfg.mcName\n      , serverVersion = cfg.mcVersion\n      , serverInstructions = \"Tidepool MCP Server - LLMNode as MCP tools\"\n      }\n\n    handlers = McpServerHandlers\n      { tools = Just (listTools cfg, callTool cfg)\n      , resources = Nothing\n      , prompts = Nothing\n      }\n\n-- | List available tools\n", "criteria": "CRITERIA_0226", "selected": "SELECTED_0226", "file": "haskell/effects/mcp-server/src/Tidepool/MCP/Server.hs", "name": "runMcpServer", "range": {"end": {"character": 12, "line": 54}, "start": {"character": 0, "line": 54}}}
{"example_id": "0227", "variation": "negative_1", "code": "runMcpServer cfg = runMcpServerStdio serverInfo handlers\n  where\n    serverInfo = McpServerInfo\n      { serverName = cfg.mcName\n      , serverVersion = cfg.mcVersion\n      , serverInstructions = \"Tidepool MCP Server - LLMNode as MCP tools\"\n      }\n\n    handlers = McpServerHandlers\n      { tools = Just (listTools cfg, callTool cfg)\n      , resources = Nothing\n      , prompts = Nothing\n      }\n\n-- | List available tools\n", "criteria": "CRITERIA_0227", "selected": "SELECTED_0227", "file": "haskell/effects/mcp-server/src/Tidepool/MCP/Server.hs", "name": "runMcpServer", "range": {"end": {"character": 12, "line": 54}, "start": {"character": 0, "line": 54}}}
{"example_id": "0228", "variation": "negative_2", "code": "runMcpServer cfg = runMcpServerStdio serverInfo handlers\n  where\n    serverInfo = McpServerInfo\n      { serverName = cfg.mcName\n      , serverVersion = cfg.mcVersion\n      , serverInstructions = \"Tidepool MCP Server - LLMNode as MCP tools\"\n      }\n\n    handlers = McpServerHandlers\n      { tools = Just (listTools cfg, callTool cfg)\n      , resources = Nothing\n      , prompts = Nothing\n      }\n\n-- | List available tools\n", "criteria": "CRITERIA_0228", "selected": "SELECTED_0228", "file": "haskell/effects/mcp-server/src/Tidepool/MCP/Server.hs", "name": "runMcpServer", "range": {"end": {"character": 12, "line": 54}, "start": {"character": 0, "line": 54}}}
{"example_id": "0229", "variation": "positive_structure", "code": "runGraphContext entry = interpret $ \\case\n  GetEntry -> pure entry\n\n\n-- | Run NodeInput effect with a fixed input value.\n--\n-- Typically provided by the dispatcher when calling a handler.\n-- Each node invocation wraps the handler in @runNodeInput@.\n--\n-- @\n-- -- In dispatcher\n-- runNodeInput implInput $ do\n--   (exit, sid) <- runLLMNode ...\n--   implAfter (exit, sid)  -- can now call getNodeInput\n-- @\n", "criteria": "CRITERIA_0229", "selected": "SELECTED_0229", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "runGraphContext", "range": {"end": {"character": 15, "line": 185}, "start": {"character": 0, "line": 185}}}
{"example_id": "0230", "variation": "positive_semantic", "code": "runGraphContext entry = interpret $ \\case\n  GetEntry -> pure entry\n\n\n-- | Run NodeInput effect with a fixed input value.\n--\n-- Typically provided by the dispatcher when calling a handler.\n-- Each node invocation wraps the handler in @runNodeInput@.\n--\n-- @\n-- -- In dispatcher\n-- runNodeInput implInput $ do\n--   (exit, sid) <- runLLMNode ...\n--   implAfter (exit, sid)  -- can now call getNodeInput\n-- @\n", "criteria": "CRITERIA_0230", "selected": "SELECTED_0230", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "runGraphContext", "range": {"end": {"character": 15, "line": 185}, "start": {"character": 0, "line": 185}}}
{"example_id": "0231", "variation": "negative_1", "code": "runGraphContext entry = interpret $ \\case\n  GetEntry -> pure entry\n\n\n-- | Run NodeInput effect with a fixed input value.\n--\n-- Typically provided by the dispatcher when calling a handler.\n-- Each node invocation wraps the handler in @runNodeInput@.\n--\n-- @\n-- -- In dispatcher\n-- runNodeInput implInput $ do\n--   (exit, sid) <- runLLMNode ...\n--   implAfter (exit, sid)  -- can now call getNodeInput\n-- @\n", "criteria": "CRITERIA_0231", "selected": "SELECTED_0231", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "runGraphContext", "range": {"end": {"character": 15, "line": 185}, "start": {"character": 0, "line": 185}}}
{"example_id": "0232", "variation": "negative_2", "code": "runGraphContext entry = interpret $ \\case\n  GetEntry -> pure entry\n\n\n-- | Run NodeInput effect with a fixed input value.\n--\n-- Typically provided by the dispatcher when calling a handler.\n-- Each node invocation wraps the handler in @runNodeInput@.\n--\n-- @\n-- -- In dispatcher\n-- runNodeInput implInput $ do\n--   (exit, sid) <- runLLMNode ...\n--   implAfter (exit, sid)  -- can now call getNodeInput\n-- @\n", "criteria": "CRITERIA_0232", "selected": "SELECTED_0232", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "runGraphContext", "range": {"end": {"character": 15, "line": 185}, "start": {"character": 0, "line": 185}}}
{"example_id": "0233", "variation": "positive_structure", "code": "runNodeInput input = interpret $ \\case\n  GetNodeInput -> pure input\n", "criteria": "CRITERIA_0233", "selected": "SELECTED_0233", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "runNodeInput", "range": {"end": {"character": 12, "line": 204}, "start": {"character": 0, "line": 204}}}
{"example_id": "0234", "variation": "positive_semantic", "code": "runNodeInput input = interpret $ \\case\n  GetNodeInput -> pure input\n", "criteria": "CRITERIA_0234", "selected": "SELECTED_0234", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "runNodeInput", "range": {"end": {"character": 12, "line": 204}, "start": {"character": 0, "line": 204}}}
{"example_id": "0235", "variation": "negative_1", "code": "runNodeInput input = interpret $ \\case\n  GetNodeInput -> pure input\n", "criteria": "CRITERIA_0235", "selected": "SELECTED_0235", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "runNodeInput", "range": {"end": {"character": 12, "line": 204}, "start": {"character": 0, "line": 204}}}
{"example_id": "0236", "variation": "negative_2", "code": "runNodeInput input = interpret $ \\case\n  GetNodeInput -> pure input\n", "criteria": "CRITERIA_0236", "selected": "SELECTED_0236", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "runNodeInput", "range": {"end": {"character": 12, "line": 204}, "start": {"character": 0, "line": 204}}}
{"example_id": "0237", "variation": "positive_structure", "code": "runDevLogPure = interpret $ \\case\n  LogDevEvent _ -> pure ()\n", "criteria": "CRITERIA_0237", "selected": "SELECTED_0237", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/DevLog.hs", "name": "runDevLogPure", "range": {"end": {"character": 13, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0238", "variation": "positive_semantic", "code": "runDevLogPure = interpret $ \\case\n  LogDevEvent _ -> pure ()\n", "criteria": "CRITERIA_0238", "selected": "SELECTED_0238", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/DevLog.hs", "name": "runDevLogPure", "range": {"end": {"character": 13, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0239", "variation": "negative_1", "code": "runDevLogPure = interpret $ \\case\n  LogDevEvent _ -> pure ()\n", "criteria": "CRITERIA_0239", "selected": "SELECTED_0239", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/DevLog.hs", "name": "runDevLogPure", "range": {"end": {"character": 13, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0240", "variation": "negative_2", "code": "runDevLogPure = interpret $ \\case\n  LogDevEvent _ -> pure ()\n", "criteria": "CRITERIA_0240", "selected": "SELECTED_0240", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/DevLog.hs", "name": "runDevLogPure", "range": {"end": {"character": 13, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0241", "variation": "positive_structure", "code": "runMemory initial = handleRelayS initial (\\s a -> pure (a, s)) $ \\s -> \\case\n  GetMem      -> \\k -> k s s\n  UpdateMem f -> \\k -> k (f s) ()\n\n-- | Run memory effect purely, returning only the result.\n--\n-- Useful when you don't need the final state.\n", "criteria": "CRITERIA_0241", "selected": "SELECTED_0241", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemory", "range": {"end": {"character": 9, "line": 204}, "start": {"character": 0, "line": 204}}}
{"example_id": "0242", "variation": "positive_semantic", "code": "runMemory initial = handleRelayS initial (\\s a -> pure (a, s)) $ \\s -> \\case\n  GetMem      -> \\k -> k s s\n  UpdateMem f -> \\k -> k (f s) ()\n\n-- | Run memory effect purely, returning only the result.\n--\n-- Useful when you don't need the final state.\n", "criteria": "CRITERIA_0242", "selected": "SELECTED_0242", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemory", "range": {"end": {"character": 9, "line": 204}, "start": {"character": 0, "line": 204}}}
{"example_id": "0243", "variation": "negative_1", "code": "runMemory initial = handleRelayS initial (\\s a -> pure (a, s)) $ \\s -> \\case\n  GetMem      -> \\k -> k s s\n  UpdateMem f -> \\k -> k (f s) ()\n\n-- | Run memory effect purely, returning only the result.\n--\n-- Useful when you don't need the final state.\n", "criteria": "CRITERIA_0243", "selected": "SELECTED_0243", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemory", "range": {"end": {"character": 9, "line": 204}, "start": {"character": 0, "line": 204}}}
{"example_id": "0244", "variation": "negative_2", "code": "runMemory initial = handleRelayS initial (\\s a -> pure (a, s)) $ \\s -> \\case\n  GetMem      -> \\k -> k s s\n  UpdateMem f -> \\k -> k (f s) ()\n\n-- | Run memory effect purely, returning only the result.\n--\n-- Useful when you don't need the final state.\n", "criteria": "CRITERIA_0244", "selected": "SELECTED_0244", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemory", "range": {"end": {"character": 9, "line": 204}, "start": {"character": 0, "line": 204}}}
{"example_id": "0245", "variation": "positive_structure", "code": "runMemoryPure = evalMemory\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WASM SERIALIZATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- $serialization\n--\n-- For WASM deployment, memory must survive across sessions. When the WASM\n-- instance dies, we serialize all memory scopes to JSON. When resuming,\n-- we restore from the snapshot.\n--\n-- = Design\n--\n-- Memory is scoped by node name (a Text key). The 'MemoryStore' holds all\n-- scopes as a @Map Text Value@, where each Value is the JSON-serialized\n-- contents of that scope.\n--\n-- The serialization format is:\n--\n-- @\n-- {\n--   \"version\": 1,\n--   \"scopes\": {\n--     \"explore\": { ... node-specific state ... },\n--     \"classify\": { ... node-specific state ... }\n--   }\n-- }\n-- @\n--\n-- = Constraints\n", "criteria": "CRITERIA_0245", "selected": "SELECTED_0245", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemoryPure", "range": {"end": {"character": 13, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0246", "variation": "positive_semantic", "code": "runMemoryPure = evalMemory\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WASM SERIALIZATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- $serialization\n--\n-- For WASM deployment, memory must survive across sessions. When the WASM\n-- instance dies, we serialize all memory scopes to JSON. When resuming,\n-- we restore from the snapshot.\n--\n-- = Design\n--\n-- Memory is scoped by node name (a Text key). The 'MemoryStore' holds all\n-- scopes as a @Map Text Value@, where each Value is the JSON-serialized\n-- contents of that scope.\n--\n-- The serialization format is:\n--\n-- @\n-- {\n--   \"version\": 1,\n--   \"scopes\": {\n--     \"explore\": { ... node-specific state ... },\n--     \"classify\": { ... node-specific state ... }\n--   }\n-- }\n-- @\n--\n-- = Constraints\n", "criteria": "CRITERIA_0246", "selected": "SELECTED_0246", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemoryPure", "range": {"end": {"character": 13, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0247", "variation": "negative_1", "code": "runMemoryPure = evalMemory\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WASM SERIALIZATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- $serialization\n--\n-- For WASM deployment, memory must survive across sessions. When the WASM\n-- instance dies, we serialize all memory scopes to JSON. When resuming,\n-- we restore from the snapshot.\n--\n-- = Design\n--\n-- Memory is scoped by node name (a Text key). The 'MemoryStore' holds all\n-- scopes as a @Map Text Value@, where each Value is the JSON-serialized\n-- contents of that scope.\n--\n-- The serialization format is:\n--\n-- @\n-- {\n--   \"version\": 1,\n--   \"scopes\": {\n--     \"explore\": { ... node-specific state ... },\n--     \"classify\": { ... node-specific state ... }\n--   }\n-- }\n-- @\n--\n-- = Constraints\n", "criteria": "CRITERIA_0247", "selected": "SELECTED_0247", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemoryPure", "range": {"end": {"character": 13, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0248", "variation": "negative_2", "code": "runMemoryPure = evalMemory\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WASM SERIALIZATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- $serialization\n--\n-- For WASM deployment, memory must survive across sessions. When the WASM\n-- instance dies, we serialize all memory scopes to JSON. When resuming,\n-- we restore from the snapshot.\n--\n-- = Design\n--\n-- Memory is scoped by node name (a Text key). The 'MemoryStore' holds all\n-- scopes as a @Map Text Value@, where each Value is the JSON-serialized\n-- contents of that scope.\n--\n-- The serialization format is:\n--\n-- @\n-- {\n--   \"version\": 1,\n--   \"scopes\": {\n--     \"explore\": { ... node-specific state ... },\n--     \"classify\": { ... node-specific state ... }\n--   }\n-- }\n-- @\n--\n-- = Constraints\n", "criteria": "CRITERIA_0248", "selected": "SELECTED_0248", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemoryPure", "range": {"end": {"character": 13, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0249", "variation": "positive_structure", "code": "runMemoryScoped scopeName defaultVal store action = do\n  -- Load initial state from store or use default\n  let initial = case getScope @s scopeName store of\n        Left _err -> defaultVal  -- Deserialization error: use default\n        Right Nothing -> defaultVal  -- Scope doesn't exist: use default\n        Right (Just val) -> val  -- Successfully loaded\n\n  -- Run the action\n  (result, final) <- runMemory initial action\n\n  -- Save final state back to store\n  let newStore = setScope scopeName final store\n  pure (result, newStore)\n\n-- | Run memory effect with scoped persistence, discarding result store.\n--\n-- Useful when you don't need the updated store (e.g., read-only access).\n", "criteria": "CRITERIA_0249", "selected": "SELECTED_0249", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemoryScoped", "range": {"end": {"character": 15, "line": 441}, "start": {"character": 0, "line": 441}}}
{"example_id": "0250", "variation": "positive_semantic", "code": "runMemoryScoped scopeName defaultVal store action = do\n  -- Load initial state from store or use default\n  let initial = case getScope @s scopeName store of\n        Left _err -> defaultVal  -- Deserialization error: use default\n        Right Nothing -> defaultVal  -- Scope doesn't exist: use default\n        Right (Just val) -> val  -- Successfully loaded\n\n  -- Run the action\n  (result, final) <- runMemory initial action\n\n  -- Save final state back to store\n  let newStore = setScope scopeName final store\n  pure (result, newStore)\n\n-- | Run memory effect with scoped persistence, discarding result store.\n--\n-- Useful when you don't need the updated store (e.g., read-only access).\n", "criteria": "CRITERIA_0250", "selected": "SELECTED_0250", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemoryScoped", "range": {"end": {"character": 15, "line": 441}, "start": {"character": 0, "line": 441}}}
{"example_id": "0251", "variation": "negative_1", "code": "runMemoryScoped scopeName defaultVal store action = do\n  -- Load initial state from store or use default\n  let initial = case getScope @s scopeName store of\n        Left _err -> defaultVal  -- Deserialization error: use default\n        Right Nothing -> defaultVal  -- Scope doesn't exist: use default\n        Right (Just val) -> val  -- Successfully loaded\n\n  -- Run the action\n  (result, final) <- runMemory initial action\n\n  -- Save final state back to store\n  let newStore = setScope scopeName final store\n  pure (result, newStore)\n\n-- | Run memory effect with scoped persistence, discarding result store.\n--\n-- Useful when you don't need the updated store (e.g., read-only access).\n", "criteria": "CRITERIA_0251", "selected": "SELECTED_0251", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemoryScoped", "range": {"end": {"character": 15, "line": 441}, "start": {"character": 0, "line": 441}}}
{"example_id": "0252", "variation": "negative_2", "code": "runMemoryScoped scopeName defaultVal store action = do\n  -- Load initial state from store or use default\n  let initial = case getScope @s scopeName store of\n        Left _err -> defaultVal  -- Deserialization error: use default\n        Right Nothing -> defaultVal  -- Scope doesn't exist: use default\n        Right (Just val) -> val  -- Successfully loaded\n\n  -- Run the action\n  (result, final) <- runMemory initial action\n\n  -- Save final state back to store\n  let newStore = setScope scopeName final store\n  pure (result, newStore)\n\n-- | Run memory effect with scoped persistence, discarding result store.\n--\n-- Useful when you don't need the updated store (e.g., read-only access).\n", "criteria": "CRITERIA_0252", "selected": "SELECTED_0252", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "runMemoryScoped", "range": {"end": {"character": 15, "line": 441}, "start": {"character": 0, "line": 441}}}
{"example_id": "0253", "variation": "positive_structure", "code": "runChatHistory action = do\n  ref <- sendM $ newIORef ([] :: [Message])\n  runChatHistoryWith ref action\n\n", "criteria": "CRITERIA_0253", "selected": "SELECTED_0253", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runChatHistory", "range": {"end": {"character": 14, "line": 525}, "start": {"character": 0, "line": 525}}}
{"example_id": "0254", "variation": "positive_semantic", "code": "runChatHistory action = do\n  ref <- sendM $ newIORef ([] :: [Message])\n  runChatHistoryWith ref action\n\n", "criteria": "CRITERIA_0254", "selected": "SELECTED_0254", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runChatHistory", "range": {"end": {"character": 14, "line": 525}, "start": {"character": 0, "line": 525}}}
{"example_id": "0255", "variation": "negative_1", "code": "runChatHistory action = do\n  ref <- sendM $ newIORef ([] :: [Message])\n  runChatHistoryWith ref action\n\n", "criteria": "CRITERIA_0255", "selected": "SELECTED_0255", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runChatHistory", "range": {"end": {"character": 14, "line": 525}, "start": {"character": 0, "line": 525}}}
{"example_id": "0256", "variation": "negative_2", "code": "runChatHistory action = do\n  ref <- sendM $ newIORef ([] :: [Message])\n  runChatHistoryWith ref action\n\n", "criteria": "CRITERIA_0256", "selected": "SELECTED_0256", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runChatHistory", "range": {"end": {"character": 14, "line": 525}, "start": {"character": 0, "line": 525}}}
{"example_id": "0257", "variation": "positive_structure", "code": "runEmit handler = interpret $ \\case\n  EmitEvent e -> sendM $ handler e\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- REQUEST INPUT EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | User input request effect (choice, text, etc.).\n--\n-- This effect is opaque - use the smart constructors:\n-- - 'requestChoice' for multiple-choice questions\n-- - 'requestText' for free text input\n-- - 'requestTextWithPhoto' for text input with photo support\n-- - 'requestCustom' for custom request types\n", "criteria": "CRITERIA_0257", "selected": "SELECTED_0257", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runEmit", "range": {"end": {"character": 7, "line": 581}, "start": {"character": 0, "line": 581}}}
{"example_id": "0258", "variation": "positive_semantic", "code": "runEmit handler = interpret $ \\case\n  EmitEvent e -> sendM $ handler e\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- REQUEST INPUT EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | User input request effect (choice, text, etc.).\n--\n-- This effect is opaque - use the smart constructors:\n-- - 'requestChoice' for multiple-choice questions\n-- - 'requestText' for free text input\n-- - 'requestTextWithPhoto' for text input with photo support\n-- - 'requestCustom' for custom request types\n", "criteria": "CRITERIA_0258", "selected": "SELECTED_0258", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runEmit", "range": {"end": {"character": 7, "line": 581}, "start": {"character": 0, "line": 581}}}
{"example_id": "0259", "variation": "negative_1", "code": "runEmit handler = interpret $ \\case\n  EmitEvent e -> sendM $ handler e\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- REQUEST INPUT EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | User input request effect (choice, text, etc.).\n--\n-- This effect is opaque - use the smart constructors:\n-- - 'requestChoice' for multiple-choice questions\n-- - 'requestText' for free text input\n-- - 'requestTextWithPhoto' for text input with photo support\n-- - 'requestCustom' for custom request types\n", "criteria": "CRITERIA_0259", "selected": "SELECTED_0259", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runEmit", "range": {"end": {"character": 7, "line": 581}, "start": {"character": 0, "line": 581}}}
{"example_id": "0260", "variation": "negative_2", "code": "runEmit handler = interpret $ \\case\n  EmitEvent e -> sendM $ handler e\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- REQUEST INPUT EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | User input request effect (choice, text, etc.).\n--\n-- This effect is opaque - use the smart constructors:\n-- - 'requestChoice' for multiple-choice questions\n-- - 'requestText' for free text input\n-- - 'requestTextWithPhoto' for text input with photo support\n-- - 'requestCustom' for custom request types\n", "criteria": "CRITERIA_0260", "selected": "SELECTED_0260", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runEmit", "range": {"end": {"character": 7, "line": 581}, "start": {"character": 0, "line": 581}}}
{"example_id": "0261", "variation": "positive_structure", "code": "runLog minLevel = interpret $ \\case\n  LogMsg level msg maybeFields\n    | level >= minLevel -> do\n        let fieldStr = case maybeFields of\n              Nothing -> \"\"\n              Just fs -> \" | \" <> T.intercalate \", \" (map fst fs)\n        sendM $ TIO.hPutStrLn stderr (\"[\" <> T.pack (show level) <> \"] \" <> msg <> fieldStr)\n    | otherwise -> pure ()\n\n", "criteria": "CRITERIA_0261", "selected": "SELECTED_0261", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runLog", "range": {"end": {"character": 6, "line": 715}, "start": {"character": 0, "line": 715}}}
{"example_id": "0262", "variation": "positive_semantic", "code": "runLog minLevel = interpret $ \\case\n  LogMsg level msg maybeFields\n    | level >= minLevel -> do\n        let fieldStr = case maybeFields of\n              Nothing -> \"\"\n              Just fs -> \" | \" <> T.intercalate \", \" (map fst fs)\n        sendM $ TIO.hPutStrLn stderr (\"[\" <> T.pack (show level) <> \"] \" <> msg <> fieldStr)\n    | otherwise -> pure ()\n\n", "criteria": "CRITERIA_0262", "selected": "SELECTED_0262", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runLog", "range": {"end": {"character": 6, "line": 715}, "start": {"character": 0, "line": 715}}}
{"example_id": "0263", "variation": "negative_1", "code": "runLog minLevel = interpret $ \\case\n  LogMsg level msg maybeFields\n    | level >= minLevel -> do\n        let fieldStr = case maybeFields of\n              Nothing -> \"\"\n              Just fs -> \" | \" <> T.intercalate \", \" (map fst fs)\n        sendM $ TIO.hPutStrLn stderr (\"[\" <> T.pack (show level) <> \"] \" <> msg <> fieldStr)\n    | otherwise -> pure ()\n\n", "criteria": "CRITERIA_0263", "selected": "SELECTED_0263", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runLog", "range": {"end": {"character": 6, "line": 715}, "start": {"character": 0, "line": 715}}}
{"example_id": "0264", "variation": "negative_2", "code": "runLog minLevel = interpret $ \\case\n  LogMsg level msg maybeFields\n    | level >= minLevel -> do\n        let fieldStr = case maybeFields of\n              Nothing -> \"\"\n              Just fs -> \" | \" <> T.intercalate \", \" (map fst fs)\n        sendM $ TIO.hPutStrLn stderr (\"[\" <> T.pack (show level) <> \"] \" <> msg <> fieldStr)\n    | otherwise -> pure ()\n\n", "criteria": "CRITERIA_0264", "selected": "SELECTED_0264", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runLog", "range": {"end": {"character": 6, "line": 715}, "start": {"character": 0, "line": 715}}}
{"example_id": "0265", "variation": "positive_structure", "code": "runQuestionUI handler = interpret $ \\case\n  AskQuestion q -> sendM $ handler q\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LOG EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0265", "selected": "SELECTED_0265", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runQuestionUI", "range": {"end": {"character": 13, "line": 650}, "start": {"character": 0, "line": 650}}}
{"example_id": "0266", "variation": "positive_semantic", "code": "runQuestionUI handler = interpret $ \\case\n  AskQuestion q -> sendM $ handler q\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LOG EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0266", "selected": "SELECTED_0266", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runQuestionUI", "range": {"end": {"character": 13, "line": 650}, "start": {"character": 0, "line": 650}}}
{"example_id": "0267", "variation": "negative_1", "code": "runQuestionUI handler = interpret $ \\case\n  AskQuestion q -> sendM $ handler q\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LOG EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0267", "selected": "SELECTED_0267", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runQuestionUI", "range": {"end": {"character": 13, "line": 650}, "start": {"character": 0, "line": 650}}}
{"example_id": "0268", "variation": "negative_2", "code": "runQuestionUI handler = interpret $ \\case\n  AskQuestion q -> sendM $ handler q\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LOG EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0268", "selected": "SELECTED_0268", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runQuestionUI", "range": {"end": {"character": 13, "line": 650}, "start": {"character": 0, "line": 650}}}
{"example_id": "0269", "variation": "positive_structure", "code": "runRandom = interpret $ \\case\n  RandomInt lo hi -> sendM $ randomRIO (lo, hi)\n  RandomDouble    -> sendM $ randomRIO (0.0, 1.0)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TIME EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0269", "selected": "SELECTED_0269", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runRandom", "range": {"end": {"character": 9, "line": 186}, "start": {"character": 0, "line": 186}}}
{"example_id": "0270", "variation": "positive_semantic", "code": "runRandom = interpret $ \\case\n  RandomInt lo hi -> sendM $ randomRIO (lo, hi)\n  RandomDouble    -> sendM $ randomRIO (0.0, 1.0)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TIME EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0270", "selected": "SELECTED_0270", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runRandom", "range": {"end": {"character": 9, "line": 186}, "start": {"character": 0, "line": 186}}}
{"example_id": "0271", "variation": "negative_1", "code": "runRandom = interpret $ \\case\n  RandomInt lo hi -> sendM $ randomRIO (lo, hi)\n  RandomDouble    -> sendM $ randomRIO (0.0, 1.0)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TIME EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0271", "selected": "SELECTED_0271", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runRandom", "range": {"end": {"character": 9, "line": 186}, "start": {"character": 0, "line": 186}}}
{"example_id": "0272", "variation": "negative_2", "code": "runRandom = interpret $ \\case\n  RandomInt lo hi -> sendM $ randomRIO (lo, hi)\n  RandomDouble    -> sendM $ randomRIO (0.0, 1.0)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TIME EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0272", "selected": "SELECTED_0272", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runRandom", "range": {"end": {"character": 9, "line": 186}, "start": {"character": 0, "line": 186}}}
{"example_id": "0273", "variation": "positive_structure", "code": "runRequestInput handler = interpret $ \\case\n  RequestChoice prompt choices ->\n    let InputHandler { ihChoice = choiceHandler } = handler\n    in sendM $ choiceHandler prompt choices\n  RequestText prompt -> sendM $ handler.ihText prompt\n  RequestTextWithPhoto prompt -> sendM $ handler.ihTextWithPhoto prompt\n  RequestCustom tag payload -> sendM $ handler.ihCustom tag payload\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- QUESTION UI EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0273", "selected": "SELECTED_0273", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runRequestInput", "range": {"end": {"character": 15, "line": 629}, "start": {"character": 0, "line": 629}}}
{"example_id": "0274", "variation": "positive_semantic", "code": "runRequestInput handler = interpret $ \\case\n  RequestChoice prompt choices ->\n    let InputHandler { ihChoice = choiceHandler } = handler\n    in sendM $ choiceHandler prompt choices\n  RequestText prompt -> sendM $ handler.ihText prompt\n  RequestTextWithPhoto prompt -> sendM $ handler.ihTextWithPhoto prompt\n  RequestCustom tag payload -> sendM $ handler.ihCustom tag payload\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- QUESTION UI EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0274", "selected": "SELECTED_0274", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runRequestInput", "range": {"end": {"character": 15, "line": 629}, "start": {"character": 0, "line": 629}}}
{"example_id": "0275", "variation": "negative_1", "code": "runRequestInput handler = interpret $ \\case\n  RequestChoice prompt choices ->\n    let InputHandler { ihChoice = choiceHandler } = handler\n    in sendM $ choiceHandler prompt choices\n  RequestText prompt -> sendM $ handler.ihText prompt\n  RequestTextWithPhoto prompt -> sendM $ handler.ihTextWithPhoto prompt\n  RequestCustom tag payload -> sendM $ handler.ihCustom tag payload\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- QUESTION UI EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0275", "selected": "SELECTED_0275", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runRequestInput", "range": {"end": {"character": 15, "line": 629}, "start": {"character": 0, "line": 629}}}
{"example_id": "0276", "variation": "negative_2", "code": "runRequestInput handler = interpret $ \\case\n  RequestChoice prompt choices ->\n    let InputHandler { ihChoice = choiceHandler } = handler\n    in sendM $ choiceHandler prompt choices\n  RequestText prompt -> sendM $ handler.ihText prompt\n  RequestTextWithPhoto prompt -> sendM $ handler.ihTextWithPhoto prompt\n  RequestCustom tag payload -> sendM $ handler.ihCustom tag payload\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- QUESTION UI EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0276", "selected": "SELECTED_0276", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runRequestInput", "range": {"end": {"character": 15, "line": 629}, "start": {"character": 0, "line": 629}}}
{"example_id": "0277", "variation": "positive_structure", "code": "runState initial = handleRelayS initial (\\s a -> pure (a, s)) $ \\s -> \\case\n  Get   -> \\k -> k s s\n  Put s' -> \\k -> k s' ()\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- RANDOM EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0277", "selected": "SELECTED_0277", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runState", "range": {"end": {"character": 8, "line": 167}, "start": {"character": 0, "line": 167}}}
{"example_id": "0278", "variation": "positive_semantic", "code": "runState initial = handleRelayS initial (\\s a -> pure (a, s)) $ \\s -> \\case\n  Get   -> \\k -> k s s\n  Put s' -> \\k -> k s' ()\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- RANDOM EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0278", "selected": "SELECTED_0278", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runState", "range": {"end": {"character": 8, "line": 167}, "start": {"character": 0, "line": 167}}}
{"example_id": "0279", "variation": "negative_1", "code": "runState initial = handleRelayS initial (\\s a -> pure (a, s)) $ \\s -> \\case\n  Get   -> \\k -> k s s\n  Put s' -> \\k -> k s' ()\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- RANDOM EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0279", "selected": "SELECTED_0279", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runState", "range": {"end": {"character": 8, "line": 167}, "start": {"character": 0, "line": 167}}}
{"example_id": "0280", "variation": "negative_2", "code": "runState initial = handleRelayS initial (\\s a -> pure (a, s)) $ \\s -> \\case\n  Get   -> \\k -> k s s\n  Put s' -> \\k -> k s' ()\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- RANDOM EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0280", "selected": "SELECTED_0280", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runState", "range": {"end": {"character": 8, "line": 167}, "start": {"character": 0, "line": 167}}}
{"example_id": "0281", "variation": "positive_structure", "code": "runTime = interpret $ \\case\n  GetCurrentTime -> sendM Time.getCurrentTime\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LLM EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | The LLM effect runs a complete turn with template and tools\n", "criteria": "CRITERIA_0281", "selected": "SELECTED_0281", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTime", "range": {"end": {"character": 7, "line": 201}, "start": {"character": 0, "line": 201}}}
{"example_id": "0282", "variation": "positive_semantic", "code": "runTime = interpret $ \\case\n  GetCurrentTime -> sendM Time.getCurrentTime\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LLM EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | The LLM effect runs a complete turn with template and tools\n", "criteria": "CRITERIA_0282", "selected": "SELECTED_0282", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTime", "range": {"end": {"character": 7, "line": 201}, "start": {"character": 0, "line": 201}}}
{"example_id": "0283", "variation": "negative_1", "code": "runTime = interpret $ \\case\n  GetCurrentTime -> sendM Time.getCurrentTime\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LLM EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | The LLM effect runs a complete turn with template and tools\n", "criteria": "CRITERIA_0283", "selected": "SELECTED_0283", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTime", "range": {"end": {"character": 7, "line": 201}, "start": {"character": 0, "line": 201}}}
{"example_id": "0284", "variation": "negative_2", "code": "runTime = interpret $ \\case\n  GetCurrentTime -> sendM Time.getCurrentTime\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LLM EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | The LLM effect runs a complete turn with template and tools\n", "criteria": "CRITERIA_0284", "selected": "SELECTED_0284", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTime", "range": {"end": {"character": 7, "line": 201}, "start": {"character": 0, "line": 201}}}
{"example_id": "0285", "variation": "positive_structure", "code": "runTurn systemPrompt userAction =\n  runTurnContent systemPrompt [TextBlock userAction]\n\n", "criteria": "CRITERIA_0285", "selected": "SELECTED_0285", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTurn", "range": {"end": {"character": 7, "line": 387}, "start": {"character": 0, "line": 387}}}
{"example_id": "0286", "variation": "positive_semantic", "code": "runTurn systemPrompt userAction =\n  runTurnContent systemPrompt [TextBlock userAction]\n\n", "criteria": "CRITERIA_0286", "selected": "SELECTED_0286", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTurn", "range": {"end": {"character": 7, "line": 387}, "start": {"character": 0, "line": 387}}}
{"example_id": "0287", "variation": "negative_1", "code": "runTurn systemPrompt userAction =\n  runTurnContent systemPrompt [TextBlock userAction]\n\n", "criteria": "CRITERIA_0287", "selected": "SELECTED_0287", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTurn", "range": {"end": {"character": 7, "line": 387}, "start": {"character": 0, "line": 387}}}
{"example_id": "0288", "variation": "negative_2", "code": "runTurn systemPrompt userAction =\n  runTurnContent systemPrompt [TextBlock userAction]\n\n", "criteria": "CRITERIA_0288", "selected": "SELECTED_0288", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTurn", "range": {"end": {"character": 7, "line": 387}, "start": {"character": 0, "line": 387}}}
{"example_id": "0289", "variation": "positive_structure", "code": "runTurnContent systemPrompt userContent schema tools = do\n  rawResult <- send (RunTurnOp systemPrompt userContent schema tools)\n  case rawResult of\n    TurnBroken reason -> return (TurnBroken reason)\n    TurnTransitionHint target payload -> return (TurnTransitionHint target payload)\n    TurnCompleted tr -> do\n      let rawJson = tr.trOutput\n      case parseStructured rawJson of\n        Right parsed -> return $ TurnCompleted $ TurnParsed tr { trOutput = parsed }\n        Left diag -> return $ TurnCompleted $ TurnParseFailed\n          { tpfRawJson = rawJson\n          , tpfNarrative = tr.trNarrative\n          , tpfError = T.unpack (formatDiagnostic diag)\n          , tpfToolsInvoked = tr.trToolsInvoked\n          }\n\n-- | Make an LLM call that throws on error.\n--\n-- Throws an exception if the LLM call fails. For error handling, use\n-- 'llmCallEither' (returns Either with Text errors) or 'llmCallStructured'\n-- (returns Either with structured LlmError type).\n", "criteria": "CRITERIA_0289", "selected": "SELECTED_0289", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTurnContent", "range": {"end": {"character": 14, "line": 395}, "start": {"character": 0, "line": 395}}}
{"example_id": "0290", "variation": "positive_semantic", "code": "runTurnContent systemPrompt userContent schema tools = do\n  rawResult <- send (RunTurnOp systemPrompt userContent schema tools)\n  case rawResult of\n    TurnBroken reason -> return (TurnBroken reason)\n    TurnTransitionHint target payload -> return (TurnTransitionHint target payload)\n    TurnCompleted tr -> do\n      let rawJson = tr.trOutput\n      case parseStructured rawJson of\n        Right parsed -> return $ TurnCompleted $ TurnParsed tr { trOutput = parsed }\n        Left diag -> return $ TurnCompleted $ TurnParseFailed\n          { tpfRawJson = rawJson\n          , tpfNarrative = tr.trNarrative\n          , tpfError = T.unpack (formatDiagnostic diag)\n          , tpfToolsInvoked = tr.trToolsInvoked\n          }\n\n-- | Make an LLM call that throws on error.\n--\n-- Throws an exception if the LLM call fails. For error handling, use\n-- 'llmCallEither' (returns Either with Text errors) or 'llmCallStructured'\n-- (returns Either with structured LlmError type).\n", "criteria": "CRITERIA_0290", "selected": "SELECTED_0290", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTurnContent", "range": {"end": {"character": 14, "line": 395}, "start": {"character": 0, "line": 395}}}
{"example_id": "0291", "variation": "negative_1", "code": "runTurnContent systemPrompt userContent schema tools = do\n  rawResult <- send (RunTurnOp systemPrompt userContent schema tools)\n  case rawResult of\n    TurnBroken reason -> return (TurnBroken reason)\n    TurnTransitionHint target payload -> return (TurnTransitionHint target payload)\n    TurnCompleted tr -> do\n      let rawJson = tr.trOutput\n      case parseStructured rawJson of\n        Right parsed -> return $ TurnCompleted $ TurnParsed tr { trOutput = parsed }\n        Left diag -> return $ TurnCompleted $ TurnParseFailed\n          { tpfRawJson = rawJson\n          , tpfNarrative = tr.trNarrative\n          , tpfError = T.unpack (formatDiagnostic diag)\n          , tpfToolsInvoked = tr.trToolsInvoked\n          }\n\n-- | Make an LLM call that throws on error.\n--\n-- Throws an exception if the LLM call fails. For error handling, use\n-- 'llmCallEither' (returns Either with Text errors) or 'llmCallStructured'\n-- (returns Either with structured LlmError type).\n", "criteria": "CRITERIA_0291", "selected": "SELECTED_0291", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTurnContent", "range": {"end": {"character": 14, "line": 395}, "start": {"character": 0, "line": 395}}}
{"example_id": "0292", "variation": "negative_2", "code": "runTurnContent systemPrompt userContent schema tools = do\n  rawResult <- send (RunTurnOp systemPrompt userContent schema tools)\n  case rawResult of\n    TurnBroken reason -> return (TurnBroken reason)\n    TurnTransitionHint target payload -> return (TurnTransitionHint target payload)\n    TurnCompleted tr -> do\n      let rawJson = tr.trOutput\n      case parseStructured rawJson of\n        Right parsed -> return $ TurnCompleted $ TurnParsed tr { trOutput = parsed }\n        Left diag -> return $ TurnCompleted $ TurnParseFailed\n          { tpfRawJson = rawJson\n          , tpfNarrative = tr.trNarrative\n          , tpfError = T.unpack (formatDiagnostic diag)\n          , tpfToolsInvoked = tr.trToolsInvoked\n          }\n\n-- | Make an LLM call that throws on error.\n--\n-- Throws an exception if the LLM call fails. For error handling, use\n-- 'llmCallEither' (returns Either with Text errors) or 'llmCallStructured'\n-- (returns Either with structured LlmError type).\n", "criteria": "CRITERIA_0292", "selected": "SELECTED_0292", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runTurnContent", "range": {"end": {"character": 14, "line": 395}, "start": {"character": 0, "line": 395}}}
{"example_id": "0293", "variation": "positive_structure", "code": "runChatHistoryWith ref = interpret $ \\case\n  GetHistory -> sendM $ readIORef ref\n  AppendMessages msgs -> sendM $ modifyIORef ref (++ msgs)\n  ClearHistory -> sendM $ writeIORef ref []\n\n-- | Roughly estimate token count for a list of messages.\n--\n-- Uses a common @character_count / 4@ heuristic as a quick approximation.\n-- This is intentionally coarse and:\n--\n--   * Is not model- or tokenizer-aware\n--   * Can be significantly off for technical content, code, or non-English text\n--   * Does not account for provider-specific image/tool token handling\n--\n-- Use this only for budgeting and back-of-the-envelope estimates,\n-- not for precise token accounting.\n", "criteria": "CRITERIA_0293", "selected": "SELECTED_0293", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runChatHistoryWith", "range": {"end": {"character": 18, "line": 530}, "start": {"character": 0, "line": 530}}}
{"example_id": "0294", "variation": "positive_semantic", "code": "runChatHistoryWith ref = interpret $ \\case\n  GetHistory -> sendM $ readIORef ref\n  AppendMessages msgs -> sendM $ modifyIORef ref (++ msgs)\n  ClearHistory -> sendM $ writeIORef ref []\n\n-- | Roughly estimate token count for a list of messages.\n--\n-- Uses a common @character_count / 4@ heuristic as a quick approximation.\n-- This is intentionally coarse and:\n--\n--   * Is not model- or tokenizer-aware\n--   * Can be significantly off for technical content, code, or non-English text\n--   * Does not account for provider-specific image/tool token handling\n--\n-- Use this only for budgeting and back-of-the-envelope estimates,\n-- not for precise token accounting.\n", "criteria": "CRITERIA_0294", "selected": "SELECTED_0294", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runChatHistoryWith", "range": {"end": {"character": 18, "line": 530}, "start": {"character": 0, "line": 530}}}
{"example_id": "0295", "variation": "negative_1", "code": "runChatHistoryWith ref = interpret $ \\case\n  GetHistory -> sendM $ readIORef ref\n  AppendMessages msgs -> sendM $ modifyIORef ref (++ msgs)\n  ClearHistory -> sendM $ writeIORef ref []\n\n-- | Roughly estimate token count for a list of messages.\n--\n-- Uses a common @character_count / 4@ heuristic as a quick approximation.\n-- This is intentionally coarse and:\n--\n--   * Is not model- or tokenizer-aware\n--   * Can be significantly off for technical content, code, or non-English text\n--   * Does not account for provider-specific image/tool token handling\n--\n-- Use this only for budgeting and back-of-the-envelope estimates,\n-- not for precise token accounting.\n", "criteria": "CRITERIA_0295", "selected": "SELECTED_0295", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runChatHistoryWith", "range": {"end": {"character": 18, "line": 530}, "start": {"character": 0, "line": 530}}}
{"example_id": "0296", "variation": "negative_2", "code": "runChatHistoryWith ref = interpret $ \\case\n  GetHistory -> sendM $ readIORef ref\n  AppendMessages msgs -> sendM $ modifyIORef ref (++ msgs)\n  ClearHistory -> sendM $ writeIORef ref []\n\n-- | Roughly estimate token count for a list of messages.\n--\n-- Uses a common @character_count / 4@ heuristic as a quick approximation.\n-- This is intentionally coarse and:\n--\n--   * Is not model- or tokenizer-aware\n--   * Can be significantly off for technical content, code, or non-English text\n--   * Does not account for provider-specific image/tool token handling\n--\n-- Use this only for budgeting and back-of-the-envelope estimates,\n-- not for precise token accounting.\n", "criteria": "CRITERIA_0296", "selected": "SELECTED_0296", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "runChatHistoryWith", "range": {"end": {"character": 18, "line": 530}, "start": {"character": 0, "line": 530}}}
{"example_id": "0297", "variation": "positive_structure", "code": "runHabiticaStub = interpret $ \\case\n  -- Original operations (crash on call)\n  FetchTodos -> do\n    logInfo \"[Habitica:stub] FetchTodos called\"\n    error \"Habitica.fetchTodos: not implemented\"\n  AddChecklistItem _ item -> do\n    logInfo $ \"[Habitica:stub] AddChecklistItem called: \" <> item\n    error \"Habitica.addChecklistItem: not implemented\"\n  CreateTodo title -> do\n    logInfo $ \"[Habitica:stub] CreateTodo called: \" <> title\n    error \"Habitica.createTodo: not implemented\"\n  GetUser -> do\n    logInfo \"[Habitica:stub] GetUser called\"\n    error \"Habitica.getUser: not implemented\"\n  ScoreTask tid dir -> do\n    logInfo $ \"[Habitica:stub] ScoreTask called: \" <> tid.unTaskId <> \" \" <> dirText dir\n    error \"Habitica.scoreTask: not implemented\"\n  GetTasks tt -> do\n    logInfo $ \"[Habitica:stub] GetTasks called: \" <> taskTypeText tt\n    error \"Habitica.getTasks: not implemented\"\n\n  -- Try variants (return Left with error instead of crashing)\n  FetchTodosTry -> do\n    logInfo \"[Habitica:stub] FetchTodosTry called\"\n    pure $ Left (HabiticaOther \"Habitica.fetchTodos: not implemented (stub)\")\n  AddChecklistItemTry _ item -> do\n    logInfo $ \"[Habitica:stub] AddChecklistItemTry called: \" <> item\n    pure $ Left (HabiticaOther \"Habitica.addChecklistItem: not implemented (stub)\")\n  CreateTodoTry title -> do\n    logInfo $ \"[Habitica:stub] CreateTodoTry called: \" <> title\n    pure $ Left (HabiticaOther \"Habitica.createTodo: not implemented (stub)\")\n", "criteria": "CRITERIA_0297", "selected": "SELECTED_0297", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "runHabiticaStub", "range": {"end": {"character": 15, "line": 133}, "start": {"character": 0, "line": 133}}}
{"example_id": "0298", "variation": "positive_semantic", "code": "runHabiticaStub = interpret $ \\case\n  -- Original operations (crash on call)\n  FetchTodos -> do\n    logInfo \"[Habitica:stub] FetchTodos called\"\n    error \"Habitica.fetchTodos: not implemented\"\n  AddChecklistItem _ item -> do\n    logInfo $ \"[Habitica:stub] AddChecklistItem called: \" <> item\n    error \"Habitica.addChecklistItem: not implemented\"\n  CreateTodo title -> do\n    logInfo $ \"[Habitica:stub] CreateTodo called: \" <> title\n    error \"Habitica.createTodo: not implemented\"\n  GetUser -> do\n    logInfo \"[Habitica:stub] GetUser called\"\n    error \"Habitica.getUser: not implemented\"\n  ScoreTask tid dir -> do\n    logInfo $ \"[Habitica:stub] ScoreTask called: \" <> tid.unTaskId <> \" \" <> dirText dir\n    error \"Habitica.scoreTask: not implemented\"\n  GetTasks tt -> do\n    logInfo $ \"[Habitica:stub] GetTasks called: \" <> taskTypeText tt\n    error \"Habitica.getTasks: not implemented\"\n\n  -- Try variants (return Left with error instead of crashing)\n  FetchTodosTry -> do\n    logInfo \"[Habitica:stub] FetchTodosTry called\"\n    pure $ Left (HabiticaOther \"Habitica.fetchTodos: not implemented (stub)\")\n  AddChecklistItemTry _ item -> do\n    logInfo $ \"[Habitica:stub] AddChecklistItemTry called: \" <> item\n    pure $ Left (HabiticaOther \"Habitica.addChecklistItem: not implemented (stub)\")\n  CreateTodoTry title -> do\n    logInfo $ \"[Habitica:stub] CreateTodoTry called: \" <> title\n    pure $ Left (HabiticaOther \"Habitica.createTodo: not implemented (stub)\")\n", "criteria": "CRITERIA_0298", "selected": "SELECTED_0298", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "runHabiticaStub", "range": {"end": {"character": 15, "line": 133}, "start": {"character": 0, "line": 133}}}
{"example_id": "0299", "variation": "negative_1", "code": "runHabiticaStub = interpret $ \\case\n  -- Original operations (crash on call)\n  FetchTodos -> do\n    logInfo \"[Habitica:stub] FetchTodos called\"\n    error \"Habitica.fetchTodos: not implemented\"\n  AddChecklistItem _ item -> do\n    logInfo $ \"[Habitica:stub] AddChecklistItem called: \" <> item\n    error \"Habitica.addChecklistItem: not implemented\"\n  CreateTodo title -> do\n    logInfo $ \"[Habitica:stub] CreateTodo called: \" <> title\n    error \"Habitica.createTodo: not implemented\"\n  GetUser -> do\n    logInfo \"[Habitica:stub] GetUser called\"\n    error \"Habitica.getUser: not implemented\"\n  ScoreTask tid dir -> do\n    logInfo $ \"[Habitica:stub] ScoreTask called: \" <> tid.unTaskId <> \" \" <> dirText dir\n    error \"Habitica.scoreTask: not implemented\"\n  GetTasks tt -> do\n    logInfo $ \"[Habitica:stub] GetTasks called: \" <> taskTypeText tt\n    error \"Habitica.getTasks: not implemented\"\n\n  -- Try variants (return Left with error instead of crashing)\n  FetchTodosTry -> do\n    logInfo \"[Habitica:stub] FetchTodosTry called\"\n    pure $ Left (HabiticaOther \"Habitica.fetchTodos: not implemented (stub)\")\n  AddChecklistItemTry _ item -> do\n    logInfo $ \"[Habitica:stub] AddChecklistItemTry called: \" <> item\n    pure $ Left (HabiticaOther \"Habitica.addChecklistItem: not implemented (stub)\")\n  CreateTodoTry title -> do\n    logInfo $ \"[Habitica:stub] CreateTodoTry called: \" <> title\n    pure $ Left (HabiticaOther \"Habitica.createTodo: not implemented (stub)\")\n", "criteria": "CRITERIA_0299", "selected": "SELECTED_0299", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "runHabiticaStub", "range": {"end": {"character": 15, "line": 133}, "start": {"character": 0, "line": 133}}}
{"example_id": "0300", "variation": "negative_2", "code": "runHabiticaStub = interpret $ \\case\n  -- Original operations (crash on call)\n  FetchTodos -> do\n    logInfo \"[Habitica:stub] FetchTodos called\"\n    error \"Habitica.fetchTodos: not implemented\"\n  AddChecklistItem _ item -> do\n    logInfo $ \"[Habitica:stub] AddChecklistItem called: \" <> item\n    error \"Habitica.addChecklistItem: not implemented\"\n  CreateTodo title -> do\n    logInfo $ \"[Habitica:stub] CreateTodo called: \" <> title\n    error \"Habitica.createTodo: not implemented\"\n  GetUser -> do\n    logInfo \"[Habitica:stub] GetUser called\"\n    error \"Habitica.getUser: not implemented\"\n  ScoreTask tid dir -> do\n    logInfo $ \"[Habitica:stub] ScoreTask called: \" <> tid.unTaskId <> \" \" <> dirText dir\n    error \"Habitica.scoreTask: not implemented\"\n  GetTasks tt -> do\n    logInfo $ \"[Habitica:stub] GetTasks called: \" <> taskTypeText tt\n    error \"Habitica.getTasks: not implemented\"\n\n  -- Try variants (return Left with error instead of crashing)\n  FetchTodosTry -> do\n    logInfo \"[Habitica:stub] FetchTodosTry called\"\n    pure $ Left (HabiticaOther \"Habitica.fetchTodos: not implemented (stub)\")\n  AddChecklistItemTry _ item -> do\n    logInfo $ \"[Habitica:stub] AddChecklistItemTry called: \" <> item\n    pure $ Left (HabiticaOther \"Habitica.addChecklistItem: not implemented (stub)\")\n  CreateTodoTry title -> do\n    logInfo $ \"[Habitica:stub] CreateTodoTry called: \" <> title\n    pure $ Left (HabiticaOther \"Habitica.createTodo: not implemented (stub)\")\n", "criteria": "CRITERIA_0300", "selected": "SELECTED_0300", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "runHabiticaStub", "range": {"end": {"character": 15, "line": 133}, "start": {"character": 0, "line": 133}}}
{"example_id": "0301", "variation": "positive_structure", "code": "runGHCiStub = interpret $ \\case\n  QueryType expr -> do\n    logInfo $ \"[GHCi:stub] :type \" <> expr\n    pure $ Right $ expr <> \" :: a -> b -> c\"\n\n  QueryInfo name -> do\n    logInfo $ \"[GHCi:stub] :info \" <> name\n    pure $ Right $ \"-- info for \" <> name\n\n  QueryKind typ -> do\n    logInfo $ \"[GHCi:stub] :kind \" <> typ\n    pure $ Right $ typ <> \" :: * -> *\"\n\n  Evaluate expr -> do\n    logInfo $ \"[GHCi:stub] evaluate: \" <> expr\n    pure $ Right \"(stub result)\"\n\n  CheckCompiles expr -> do\n    logInfo $ \"[GHCi:stub] check compiles: \" <> T.take 50 expr\n    pure $ Right True\n\n  LoadModule modName -> do\n    logInfo $ \"[GHCi:stub] :load \" <> modName\n    pure $ Right ()\n\n  ReloadModules -> do\n    logInfo \"[GHCi:stub] :reload\"\n    pure $ Right ()\n", "criteria": "CRITERIA_0301", "selected": "SELECTED_0301", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GHCi.hs", "name": "runGHCiStub", "range": {"end": {"character": 11, "line": 305}, "start": {"character": 0, "line": 305}}}
{"example_id": "0302", "variation": "positive_semantic", "code": "runGHCiStub = interpret $ \\case\n  QueryType expr -> do\n    logInfo $ \"[GHCi:stub] :type \" <> expr\n    pure $ Right $ expr <> \" :: a -> b -> c\"\n\n  QueryInfo name -> do\n    logInfo $ \"[GHCi:stub] :info \" <> name\n    pure $ Right $ \"-- info for \" <> name\n\n  QueryKind typ -> do\n    logInfo $ \"[GHCi:stub] :kind \" <> typ\n    pure $ Right $ typ <> \" :: * -> *\"\n\n  Evaluate expr -> do\n    logInfo $ \"[GHCi:stub] evaluate: \" <> expr\n    pure $ Right \"(stub result)\"\n\n  CheckCompiles expr -> do\n    logInfo $ \"[GHCi:stub] check compiles: \" <> T.take 50 expr\n    pure $ Right True\n\n  LoadModule modName -> do\n    logInfo $ \"[GHCi:stub] :load \" <> modName\n    pure $ Right ()\n\n  ReloadModules -> do\n    logInfo \"[GHCi:stub] :reload\"\n    pure $ Right ()\n", "criteria": "CRITERIA_0302", "selected": "SELECTED_0302", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GHCi.hs", "name": "runGHCiStub", "range": {"end": {"character": 11, "line": 305}, "start": {"character": 0, "line": 305}}}
{"example_id": "0303", "variation": "negative_1", "code": "runGHCiStub = interpret $ \\case\n  QueryType expr -> do\n    logInfo $ \"[GHCi:stub] :type \" <> expr\n    pure $ Right $ expr <> \" :: a -> b -> c\"\n\n  QueryInfo name -> do\n    logInfo $ \"[GHCi:stub] :info \" <> name\n    pure $ Right $ \"-- info for \" <> name\n\n  QueryKind typ -> do\n    logInfo $ \"[GHCi:stub] :kind \" <> typ\n    pure $ Right $ typ <> \" :: * -> *\"\n\n  Evaluate expr -> do\n    logInfo $ \"[GHCi:stub] evaluate: \" <> expr\n    pure $ Right \"(stub result)\"\n\n  CheckCompiles expr -> do\n    logInfo $ \"[GHCi:stub] check compiles: \" <> T.take 50 expr\n    pure $ Right True\n\n  LoadModule modName -> do\n    logInfo $ \"[GHCi:stub] :load \" <> modName\n    pure $ Right ()\n\n  ReloadModules -> do\n    logInfo \"[GHCi:stub] :reload\"\n    pure $ Right ()\n", "criteria": "CRITERIA_0303", "selected": "SELECTED_0303", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GHCi.hs", "name": "runGHCiStub", "range": {"end": {"character": 11, "line": 305}, "start": {"character": 0, "line": 305}}}
{"example_id": "0304", "variation": "negative_2", "code": "runGHCiStub = interpret $ \\case\n  QueryType expr -> do\n    logInfo $ \"[GHCi:stub] :type \" <> expr\n    pure $ Right $ expr <> \" :: a -> b -> c\"\n\n  QueryInfo name -> do\n    logInfo $ \"[GHCi:stub] :info \" <> name\n    pure $ Right $ \"-- info for \" <> name\n\n  QueryKind typ -> do\n    logInfo $ \"[GHCi:stub] :kind \" <> typ\n    pure $ Right $ typ <> \" :: * -> *\"\n\n  Evaluate expr -> do\n    logInfo $ \"[GHCi:stub] evaluate: \" <> expr\n    pure $ Right \"(stub result)\"\n\n  CheckCompiles expr -> do\n    logInfo $ \"[GHCi:stub] check compiles: \" <> T.take 50 expr\n    pure $ Right True\n\n  LoadModule modName -> do\n    logInfo $ \"[GHCi:stub] :load \" <> modName\n    pure $ Right ()\n\n  ReloadModules -> do\n    logInfo \"[GHCi:stub] :reload\"\n    pure $ Right ()\n", "criteria": "CRITERIA_0304", "selected": "SELECTED_0304", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GHCi.hs", "name": "runGHCiStub", "range": {"end": {"character": 11, "line": 305}, "start": {"character": 0, "line": 305}}}
{"example_id": "0305", "variation": "positive_structure", "code": "runGitHubStub = interpret $ \\case\n  CreateIssue (Repo repo) title _ _ -> do\n    logInfo $ \"[GitHub:stub] CreateIssue called: \" <> repo <> \" - \" <> title\n    error \"GitHub.createIssue: not implemented\"\n\n  GetIssue (Repo repo) num _ -> do\n    logInfo $ \"[GitHub:stub] GetIssue called: \" <> repo <> \" #\" <> showT num\n    pure Nothing\n\n  ListIssues (Repo repo) _ -> do\n    logInfo $ \"[GitHub:stub] ListIssues called: \" <> repo\n    pure []\n\n  GetPullRequest (Repo repo) num _ -> do\n    logInfo $ \"[GitHub:stub] GetPullRequest called: \" <> repo <> \" #\" <> showT num\n    pure Nothing\n\n  ListPullRequests (Repo repo) _ -> do\n    logInfo $ \"[GitHub:stub] ListPullRequests called: \" <> repo\n    pure []\n\n  CheckAuth -> do\n    logInfo \"[GitHub:stub] CheckAuth called\"\n    pure False\n\n  where\n    showT :: Show a => a -> Text\n    showT = Data.Text.pack . show\n", "criteria": "CRITERIA_0305", "selected": "SELECTED_0305", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "runGitHubStub", "range": {"end": {"character": 13, "line": 345}, "start": {"character": 0, "line": 345}}}
{"example_id": "0306", "variation": "positive_semantic", "code": "runGitHubStub = interpret $ \\case\n  CreateIssue (Repo repo) title _ _ -> do\n    logInfo $ \"[GitHub:stub] CreateIssue called: \" <> repo <> \" - \" <> title\n    error \"GitHub.createIssue: not implemented\"\n\n  GetIssue (Repo repo) num _ -> do\n    logInfo $ \"[GitHub:stub] GetIssue called: \" <> repo <> \" #\" <> showT num\n    pure Nothing\n\n  ListIssues (Repo repo) _ -> do\n    logInfo $ \"[GitHub:stub] ListIssues called: \" <> repo\n    pure []\n\n  GetPullRequest (Repo repo) num _ -> do\n    logInfo $ \"[GitHub:stub] GetPullRequest called: \" <> repo <> \" #\" <> showT num\n    pure Nothing\n\n  ListPullRequests (Repo repo) _ -> do\n    logInfo $ \"[GitHub:stub] ListPullRequests called: \" <> repo\n    pure []\n\n  CheckAuth -> do\n    logInfo \"[GitHub:stub] CheckAuth called\"\n    pure False\n\n  where\n    showT :: Show a => a -> Text\n    showT = Data.Text.pack . show\n", "criteria": "CRITERIA_0306", "selected": "SELECTED_0306", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "runGitHubStub", "range": {"end": {"character": 13, "line": 345}, "start": {"character": 0, "line": 345}}}
{"example_id": "0307", "variation": "negative_1", "code": "runGitHubStub = interpret $ \\case\n  CreateIssue (Repo repo) title _ _ -> do\n    logInfo $ \"[GitHub:stub] CreateIssue called: \" <> repo <> \" - \" <> title\n    error \"GitHub.createIssue: not implemented\"\n\n  GetIssue (Repo repo) num _ -> do\n    logInfo $ \"[GitHub:stub] GetIssue called: \" <> repo <> \" #\" <> showT num\n    pure Nothing\n\n  ListIssues (Repo repo) _ -> do\n    logInfo $ \"[GitHub:stub] ListIssues called: \" <> repo\n    pure []\n\n  GetPullRequest (Repo repo) num _ -> do\n    logInfo $ \"[GitHub:stub] GetPullRequest called: \" <> repo <> \" #\" <> showT num\n    pure Nothing\n\n  ListPullRequests (Repo repo) _ -> do\n    logInfo $ \"[GitHub:stub] ListPullRequests called: \" <> repo\n    pure []\n\n  CheckAuth -> do\n    logInfo \"[GitHub:stub] CheckAuth called\"\n    pure False\n\n  where\n    showT :: Show a => a -> Text\n    showT = Data.Text.pack . show\n", "criteria": "CRITERIA_0307", "selected": "SELECTED_0307", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "runGitHubStub", "range": {"end": {"character": 13, "line": 345}, "start": {"character": 0, "line": 345}}}
{"example_id": "0308", "variation": "negative_2", "code": "runGitHubStub = interpret $ \\case\n  CreateIssue (Repo repo) title _ _ -> do\n    logInfo $ \"[GitHub:stub] CreateIssue called: \" <> repo <> \" - \" <> title\n    error \"GitHub.createIssue: not implemented\"\n\n  GetIssue (Repo repo) num _ -> do\n    logInfo $ \"[GitHub:stub] GetIssue called: \" <> repo <> \" #\" <> showT num\n    pure Nothing\n\n  ListIssues (Repo repo) _ -> do\n    logInfo $ \"[GitHub:stub] ListIssues called: \" <> repo\n    pure []\n\n  GetPullRequest (Repo repo) num _ -> do\n    logInfo $ \"[GitHub:stub] GetPullRequest called: \" <> repo <> \" #\" <> showT num\n    pure Nothing\n\n  ListPullRequests (Repo repo) _ -> do\n    logInfo $ \"[GitHub:stub] ListPullRequests called: \" <> repo\n    pure []\n\n  CheckAuth -> do\n    logInfo \"[GitHub:stub] CheckAuth called\"\n    pure False\n\n  where\n    showT :: Show a => a -> Text\n    showT = Data.Text.pack . show\n", "criteria": "CRITERIA_0308", "selected": "SELECTED_0308", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "runGitHubStub", "range": {"end": {"character": 13, "line": 345}, "start": {"character": 0, "line": 345}}}
{"example_id": "0309", "variation": "positive_structure", "code": "runGraphFromWithSpans graph input = do\n  let handlerName = T.pack $ symbolVal (Proxy @name)\n  withNodeSpan handlerName $ do\n    let handler = getField @name graph\n    choice <- callHandler handler input\n    dispatchGotoTraced graph choice\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRACED DISPATCH TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Dispatch with span emission for each node transition.\n--\n-- Like 'DispatchGoto', but emits OpenTelemetry spans for observability.\n", "criteria": "CRITERIA_0309", "selected": "SELECTED_0309", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "runGraphFromWithSpans", "range": {"end": {"character": 21, "line": 152}, "start": {"character": 0, "line": 152}}}
{"example_id": "0310", "variation": "positive_semantic", "code": "runGraphFromWithSpans graph input = do\n  let handlerName = T.pack $ symbolVal (Proxy @name)\n  withNodeSpan handlerName $ do\n    let handler = getField @name graph\n    choice <- callHandler handler input\n    dispatchGotoTraced graph choice\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRACED DISPATCH TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Dispatch with span emission for each node transition.\n--\n-- Like 'DispatchGoto', but emits OpenTelemetry spans for observability.\n", "criteria": "CRITERIA_0310", "selected": "SELECTED_0310", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "runGraphFromWithSpans", "range": {"end": {"character": 21, "line": 152}, "start": {"character": 0, "line": 152}}}
{"example_id": "0311", "variation": "negative_1", "code": "runGraphFromWithSpans graph input = do\n  let handlerName = T.pack $ symbolVal (Proxy @name)\n  withNodeSpan handlerName $ do\n    let handler = getField @name graph\n    choice <- callHandler handler input\n    dispatchGotoTraced graph choice\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRACED DISPATCH TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Dispatch with span emission for each node transition.\n--\n-- Like 'DispatchGoto', but emits OpenTelemetry spans for observability.\n", "criteria": "CRITERIA_0311", "selected": "SELECTED_0311", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "runGraphFromWithSpans", "range": {"end": {"character": 21, "line": 152}, "start": {"character": 0, "line": 152}}}
{"example_id": "0312", "variation": "negative_2", "code": "runGraphFromWithSpans graph input = do\n  let handlerName = T.pack $ symbolVal (Proxy @name)\n  withNodeSpan handlerName $ do\n    let handler = getField @name graph\n    choice <- callHandler handler input\n    dispatchGotoTraced graph choice\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRACED DISPATCH TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Dispatch with span emission for each node transition.\n--\n-- Like 'DispatchGoto', but emits OpenTelemetry spans for observability.\n", "criteria": "CRITERIA_0312", "selected": "SELECTED_0312", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "runGraphFromWithSpans", "range": {"end": {"character": 21, "line": 152}, "start": {"character": 0, "line": 152}}}
{"example_id": "0313", "variation": "positive_structure", "code": "runGraphWithSpans = runGraphFromWithSpans @entryHandlerName\n\n\n-- | Run a graph from a named handler with span emission.\n--\n-- @\n-- result <- runGraphFromWithSpans @\"compute\" handlers inputValue\n-- @\n", "criteria": "CRITERIA_0313", "selected": "SELECTED_0313", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "runGraphWithSpans", "range": {"end": {"character": 17, "line": 133}, "start": {"character": 0, "line": 133}}}
{"example_id": "0314", "variation": "positive_semantic", "code": "runGraphWithSpans = runGraphFromWithSpans @entryHandlerName\n\n\n-- | Run a graph from a named handler with span emission.\n--\n-- @\n-- result <- runGraphFromWithSpans @\"compute\" handlers inputValue\n-- @\n", "criteria": "CRITERIA_0314", "selected": "SELECTED_0314", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "runGraphWithSpans", "range": {"end": {"character": 17, "line": 133}, "start": {"character": 0, "line": 133}}}
{"example_id": "0315", "variation": "negative_1", "code": "runGraphWithSpans = runGraphFromWithSpans @entryHandlerName\n\n\n-- | Run a graph from a named handler with span emission.\n--\n-- @\n-- result <- runGraphFromWithSpans @\"compute\" handlers inputValue\n-- @\n", "criteria": "CRITERIA_0315", "selected": "SELECTED_0315", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "runGraphWithSpans", "range": {"end": {"character": 17, "line": 133}, "start": {"character": 0, "line": 133}}}
{"example_id": "0316", "variation": "negative_2", "code": "runGraphWithSpans = runGraphFromWithSpans @entryHandlerName\n\n\n-- | Run a graph from a named handler with span emission.\n--\n-- @\n-- result <- runGraphFromWithSpans @\"compute\" handlers inputValue\n-- @\n", "criteria": "CRITERIA_0316", "selected": "SELECTED_0316", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "runGraphWithSpans", "range": {"end": {"character": 17, "line": 133}, "start": {"character": 0, "line": 133}}}
{"example_id": "0317", "variation": "positive_structure", "code": "runGraphCLIPure desc parser handlers =\n  runGraphCLIWith desc parser $ \\input ->\n    pure $ run $ runGraph @graph @(GraphEntryType graph) @targets @(GraphExitType graph) @'[] @entryHandlerName @handler handlers input\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Convert camelCase to kebab-case.\n--\n-- @\n-- toKebabCase \"inputFile\" = \"input-file\"\n-- toKebabCase \"processURL\" = \"process-url\"\n-- @\n", "criteria": "CRITERIA_0317", "selected": "SELECTED_0317", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "runGraphCLIPure", "range": {"end": {"character": 15, "line": 527}, "start": {"character": 0, "line": 527}}}
{"example_id": "0318", "variation": "positive_semantic", "code": "runGraphCLIPure desc parser handlers =\n  runGraphCLIWith desc parser $ \\input ->\n    pure $ run $ runGraph @graph @(GraphEntryType graph) @targets @(GraphExitType graph) @'[] @entryHandlerName @handler handlers input\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Convert camelCase to kebab-case.\n--\n-- @\n-- toKebabCase \"inputFile\" = \"input-file\"\n-- toKebabCase \"processURL\" = \"process-url\"\n-- @\n", "criteria": "CRITERIA_0318", "selected": "SELECTED_0318", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "runGraphCLIPure", "range": {"end": {"character": 15, "line": 527}, "start": {"character": 0, "line": 527}}}
{"example_id": "0319", "variation": "negative_1", "code": "runGraphCLIPure desc parser handlers =\n  runGraphCLIWith desc parser $ \\input ->\n    pure $ run $ runGraph @graph @(GraphEntryType graph) @targets @(GraphExitType graph) @'[] @entryHandlerName @handler handlers input\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Convert camelCase to kebab-case.\n--\n-- @\n-- toKebabCase \"inputFile\" = \"input-file\"\n-- toKebabCase \"processURL\" = \"process-url\"\n-- @\n", "criteria": "CRITERIA_0319", "selected": "SELECTED_0319", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "runGraphCLIPure", "range": {"end": {"character": 15, "line": 527}, "start": {"character": 0, "line": 527}}}
{"example_id": "0320", "variation": "negative_2", "code": "runGraphCLIPure desc parser handlers =\n  runGraphCLIWith desc parser $ \\input ->\n    pure $ run $ runGraph @graph @(GraphEntryType graph) @targets @(GraphExitType graph) @'[] @entryHandlerName @handler handlers input\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Convert camelCase to kebab-case.\n--\n-- @\n-- toKebabCase \"inputFile\" = \"input-file\"\n-- toKebabCase \"processURL\" = \"process-url\"\n-- @\n", "criteria": "CRITERIA_0320", "selected": "SELECTED_0320", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "runGraphCLIPure", "range": {"end": {"character": 15, "line": 527}, "start": {"character": 0, "line": 527}}}
{"example_id": "0321", "variation": "positive_structure", "code": "runGraphCLIWith desc inputParser interpreter = do\n  let combinedParser = (,) <$> inputParser <*> outputFormatParser\n      parserInfo' = info (combinedParser <**> helper)\n        ( fullDesc\n        <> progDesc (T.unpack desc)\n        )\n  (input, fmt) <- execParser parserInfo'\n  result <- interpreter input\n  TIO.putStrLn (formatOutput fmt result)\n\n-- | Run a logic-only graph (no LLM/IO effects) as CLI.\n--\n-- This wires a graph with empty effect stack @'[]@ directly to CLI.\n-- For graphs with LLM/IO effects, use @runGraphCLI@ from tidepool-platform.\n--\n-- = Example\n--\n-- @\n-- main :: IO ()\n-- main = runGraphCLIPure\n--   \"Counter graph CLI\"\n--   $(deriveCLIParser ''CounterInput)\n--   counterHandlers\n-- @\n--\n-- = Constraints\n--\n-- The graph must:\n--\n-- * Have @EntryNode@ and @Exit@ fields (detected via @GraphEntryType@ and @GraphExitType@)\n-- * Have a handler that accepts the entry type via @Needs@ (found via @FindEntryHandler@)\n", "criteria": "CRITERIA_0321", "selected": "SELECTED_0321", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "runGraphCLIWith", "range": {"end": {"character": 15, "line": 479}, "start": {"character": 0, "line": 479}}}
{"example_id": "0322", "variation": "positive_semantic", "code": "runGraphCLIWith desc inputParser interpreter = do\n  let combinedParser = (,) <$> inputParser <*> outputFormatParser\n      parserInfo' = info (combinedParser <**> helper)\n        ( fullDesc\n        <> progDesc (T.unpack desc)\n        )\n  (input, fmt) <- execParser parserInfo'\n  result <- interpreter input\n  TIO.putStrLn (formatOutput fmt result)\n\n-- | Run a logic-only graph (no LLM/IO effects) as CLI.\n--\n-- This wires a graph with empty effect stack @'[]@ directly to CLI.\n-- For graphs with LLM/IO effects, use @runGraphCLI@ from tidepool-platform.\n--\n-- = Example\n--\n-- @\n-- main :: IO ()\n-- main = runGraphCLIPure\n--   \"Counter graph CLI\"\n--   $(deriveCLIParser ''CounterInput)\n--   counterHandlers\n-- @\n--\n-- = Constraints\n--\n-- The graph must:\n--\n-- * Have @EntryNode@ and @Exit@ fields (detected via @GraphEntryType@ and @GraphExitType@)\n-- * Have a handler that accepts the entry type via @Needs@ (found via @FindEntryHandler@)\n", "criteria": "CRITERIA_0322", "selected": "SELECTED_0322", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "runGraphCLIWith", "range": {"end": {"character": 15, "line": 479}, "start": {"character": 0, "line": 479}}}
{"example_id": "0323", "variation": "negative_1", "code": "runGraphCLIWith desc inputParser interpreter = do\n  let combinedParser = (,) <$> inputParser <*> outputFormatParser\n      parserInfo' = info (combinedParser <**> helper)\n        ( fullDesc\n        <> progDesc (T.unpack desc)\n        )\n  (input, fmt) <- execParser parserInfo'\n  result <- interpreter input\n  TIO.putStrLn (formatOutput fmt result)\n\n-- | Run a logic-only graph (no LLM/IO effects) as CLI.\n--\n-- This wires a graph with empty effect stack @'[]@ directly to CLI.\n-- For graphs with LLM/IO effects, use @runGraphCLI@ from tidepool-platform.\n--\n-- = Example\n--\n-- @\n-- main :: IO ()\n-- main = runGraphCLIPure\n--   \"Counter graph CLI\"\n--   $(deriveCLIParser ''CounterInput)\n--   counterHandlers\n-- @\n--\n-- = Constraints\n--\n-- The graph must:\n--\n-- * Have @EntryNode@ and @Exit@ fields (detected via @GraphEntryType@ and @GraphExitType@)\n-- * Have a handler that accepts the entry type via @Needs@ (found via @FindEntryHandler@)\n", "criteria": "CRITERIA_0323", "selected": "SELECTED_0323", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "runGraphCLIWith", "range": {"end": {"character": 15, "line": 479}, "start": {"character": 0, "line": 479}}}
{"example_id": "0324", "variation": "negative_2", "code": "runGraphCLIWith desc inputParser interpreter = do\n  let combinedParser = (,) <$> inputParser <*> outputFormatParser\n      parserInfo' = info (combinedParser <**> helper)\n        ( fullDesc\n        <> progDesc (T.unpack desc)\n        )\n  (input, fmt) <- execParser parserInfo'\n  result <- interpreter input\n  TIO.putStrLn (formatOutput fmt result)\n\n-- | Run a logic-only graph (no LLM/IO effects) as CLI.\n--\n-- This wires a graph with empty effect stack @'[]@ directly to CLI.\n-- For graphs with LLM/IO effects, use @runGraphCLI@ from tidepool-platform.\n--\n-- = Example\n--\n-- @\n-- main :: IO ()\n-- main = runGraphCLIPure\n--   \"Counter graph CLI\"\n--   $(deriveCLIParser ''CounterInput)\n--   counterHandlers\n-- @\n--\n-- = Constraints\n--\n-- The graph must:\n--\n-- * Have @EntryNode@ and @Exit@ fields (detected via @GraphEntryType@ and @GraphExitType@)\n-- * Have a handler that accepts the entry type via @Needs@ (found via @FindEntryHandler@)\n", "criteria": "CRITERIA_0324", "selected": "SELECTED_0324", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "runGraphCLIWith", "range": {"end": {"character": 15, "line": 479}, "start": {"character": 0, "line": 479}}}
{"example_id": "0325", "variation": "positive_structure", "code": "runSession handler = interpret $ \\case\n  op@(StartSession _ _ _ _ _) -> handler op\n  op@(ContinueSession _ _ _ _ _ _ _) -> handler op\n  op@(ForkSession _ _ _ _ _ _ _ _) -> handler op\n", "criteria": "CRITERIA_0325", "selected": "SELECTED_0325", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "runSession", "range": {"end": {"character": 10, "line": 492}, "start": {"character": 0, "line": 492}}}
{"example_id": "0326", "variation": "positive_semantic", "code": "runSession handler = interpret $ \\case\n  op@(StartSession _ _ _ _ _) -> handler op\n  op@(ContinueSession _ _ _ _ _ _ _) -> handler op\n  op@(ForkSession _ _ _ _ _ _ _ _) -> handler op\n", "criteria": "CRITERIA_0326", "selected": "SELECTED_0326", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "runSession", "range": {"end": {"character": 10, "line": 492}, "start": {"character": 0, "line": 492}}}
{"example_id": "0327", "variation": "negative_1", "code": "runSession handler = interpret $ \\case\n  op@(StartSession _ _ _ _ _) -> handler op\n  op@(ContinueSession _ _ _ _ _ _ _) -> handler op\n  op@(ForkSession _ _ _ _ _ _ _ _) -> handler op\n", "criteria": "CRITERIA_0327", "selected": "SELECTED_0327", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "runSession", "range": {"end": {"character": 10, "line": 492}, "start": {"character": 0, "line": 492}}}
{"example_id": "0328", "variation": "negative_2", "code": "runSession handler = interpret $ \\case\n  op@(StartSession _ _ _ _ _) -> handler op\n  op@(ContinueSession _ _ _ _ _ _ _) -> handler op\n  op@(ForkSession _ _ _ _ _ _ _ _) -> handler op\n", "criteria": "CRITERIA_0328", "selected": "SELECTED_0328", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "runSession", "range": {"end": {"character": 10, "line": 492}, "start": {"character": 0, "line": 492}}}
{"example_id": "0329", "variation": "positive_structure", "code": "runGraph = runGraphFrom @entryHandlerName\n\n\n-- | Run a graph with an explicitly provided entry handler.\n--\n-- This avoids the 'HasField' constraint that 'runGraph' and 'runGraphFrom'\n-- require. Use this when GHC can't derive HasField for your graph record\n-- (common when field types involve type families).\n--\n-- @\n-- -- Instead of:\n-- result <- runGraph handlers input  -- Requires HasField\n--\n-- -- Use:\n-- result <- runGraphWith handlers.v3Scaffold handlers input  -- No HasField needed\n-- @\n", "criteria": "CRITERIA_0329", "selected": "SELECTED_0329", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraph", "range": {"end": {"character": 8, "line": 197}, "start": {"character": 0, "line": 197}}}
{"example_id": "0330", "variation": "positive_semantic", "code": "runGraph = runGraphFrom @entryHandlerName\n\n\n-- | Run a graph with an explicitly provided entry handler.\n--\n-- This avoids the 'HasField' constraint that 'runGraph' and 'runGraphFrom'\n-- require. Use this when GHC can't derive HasField for your graph record\n-- (common when field types involve type families).\n--\n-- @\n-- -- Instead of:\n-- result <- runGraph handlers input  -- Requires HasField\n--\n-- -- Use:\n-- result <- runGraphWith handlers.v3Scaffold handlers input  -- No HasField needed\n-- @\n", "criteria": "CRITERIA_0330", "selected": "SELECTED_0330", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraph", "range": {"end": {"character": 8, "line": 197}, "start": {"character": 0, "line": 197}}}
{"example_id": "0331", "variation": "negative_1", "code": "runGraph = runGraphFrom @entryHandlerName\n\n\n-- | Run a graph with an explicitly provided entry handler.\n--\n-- This avoids the 'HasField' constraint that 'runGraph' and 'runGraphFrom'\n-- require. Use this when GHC can't derive HasField for your graph record\n-- (common when field types involve type families).\n--\n-- @\n-- -- Instead of:\n-- result <- runGraph handlers input  -- Requires HasField\n--\n-- -- Use:\n-- result <- runGraphWith handlers.v3Scaffold handlers input  -- No HasField needed\n-- @\n", "criteria": "CRITERIA_0331", "selected": "SELECTED_0331", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraph", "range": {"end": {"character": 8, "line": 197}, "start": {"character": 0, "line": 197}}}
{"example_id": "0332", "variation": "negative_2", "code": "runGraph = runGraphFrom @entryHandlerName\n\n\n-- | Run a graph with an explicitly provided entry handler.\n--\n-- This avoids the 'HasField' constraint that 'runGraph' and 'runGraphFrom'\n-- require. Use this when GHC can't derive HasField for your graph record\n-- (common when field types involve type families).\n--\n-- @\n-- -- Instead of:\n-- result <- runGraph handlers input  -- Requires HasField\n--\n-- -- Use:\n-- result <- runGraphWith handlers.v3Scaffold handlers input  -- No HasField needed\n-- @\n", "criteria": "CRITERIA_0332", "selected": "SELECTED_0332", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraph", "range": {"end": {"character": 8, "line": 197}, "start": {"character": 0, "line": 197}}}
{"example_id": "0333", "variation": "positive_structure", "code": "runGraphFrom graph input = do\n  let handler = getField @name graph\n  choice <- callHandler handler input\n  dispatchGoto graph choice\n\n\n-- | Run a graph from EntryNode to Exit.\n--\n-- Automatically discovers the first handler that accepts the entry type\n-- (via the 'Input' annotation), calls it with the input, and dispatches\n-- through the graph until Exit is reached.\n--\n-- @\n-- -- Define graph\n-- data TestGraph mode = TestGraph\n--   { entry   :: mode :- EntryNode Int\n--   , compute :: mode :- LogicNode :@ Input Int :@ UsesEffects '[Goto Exit Int]\n--   , exit    :: mode :- ExitNode Int\n--   }\n--\n-- -- Run it\n-- result <- runGraph handlers 5  -- Returns 6 (if compute does +1)\n-- @\n", "criteria": "CRITERIA_0333", "selected": "SELECTED_0333", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraphFrom", "range": {"end": {"character": 12, "line": 162}, "start": {"character": 0, "line": 162}}}
{"example_id": "0334", "variation": "positive_semantic", "code": "runGraphFrom graph input = do\n  let handler = getField @name graph\n  choice <- callHandler handler input\n  dispatchGoto graph choice\n\n\n-- | Run a graph from EntryNode to Exit.\n--\n-- Automatically discovers the first handler that accepts the entry type\n-- (via the 'Input' annotation), calls it with the input, and dispatches\n-- through the graph until Exit is reached.\n--\n-- @\n-- -- Define graph\n-- data TestGraph mode = TestGraph\n--   { entry   :: mode :- EntryNode Int\n--   , compute :: mode :- LogicNode :@ Input Int :@ UsesEffects '[Goto Exit Int]\n--   , exit    :: mode :- ExitNode Int\n--   }\n--\n-- -- Run it\n-- result <- runGraph handlers 5  -- Returns 6 (if compute does +1)\n-- @\n", "criteria": "CRITERIA_0334", "selected": "SELECTED_0334", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraphFrom", "range": {"end": {"character": 12, "line": 162}, "start": {"character": 0, "line": 162}}}
{"example_id": "0335", "variation": "negative_1", "code": "runGraphFrom graph input = do\n  let handler = getField @name graph\n  choice <- callHandler handler input\n  dispatchGoto graph choice\n\n\n-- | Run a graph from EntryNode to Exit.\n--\n-- Automatically discovers the first handler that accepts the entry type\n-- (via the 'Input' annotation), calls it with the input, and dispatches\n-- through the graph until Exit is reached.\n--\n-- @\n-- -- Define graph\n-- data TestGraph mode = TestGraph\n--   { entry   :: mode :- EntryNode Int\n--   , compute :: mode :- LogicNode :@ Input Int :@ UsesEffects '[Goto Exit Int]\n--   , exit    :: mode :- ExitNode Int\n--   }\n--\n-- -- Run it\n-- result <- runGraph handlers 5  -- Returns 6 (if compute does +1)\n-- @\n", "criteria": "CRITERIA_0335", "selected": "SELECTED_0335", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraphFrom", "range": {"end": {"character": 12, "line": 162}, "start": {"character": 0, "line": 162}}}
{"example_id": "0336", "variation": "negative_2", "code": "runGraphFrom graph input = do\n  let handler = getField @name graph\n  choice <- callHandler handler input\n  dispatchGoto graph choice\n\n\n-- | Run a graph from EntryNode to Exit.\n--\n-- Automatically discovers the first handler that accepts the entry type\n-- (via the 'Input' annotation), calls it with the input, and dispatches\n-- through the graph until Exit is reached.\n--\n-- @\n-- -- Define graph\n-- data TestGraph mode = TestGraph\n--   { entry   :: mode :- EntryNode Int\n--   , compute :: mode :- LogicNode :@ Input Int :@ UsesEffects '[Goto Exit Int]\n--   , exit    :: mode :- ExitNode Int\n--   }\n--\n-- -- Run it\n-- result <- runGraph handlers 5  -- Returns 6 (if compute does +1)\n-- @\n", "criteria": "CRITERIA_0336", "selected": "SELECTED_0336", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraphFrom", "range": {"end": {"character": 12, "line": 162}, "start": {"character": 0, "line": 162}}}
{"example_id": "0337", "variation": "positive_structure", "code": "runGraphWith entryHandler graph input = do\n  choice <- callHandler entryHandler input\n  dispatchGoto graph choice\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LLM HANDLER EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Execute an LLMBoth handler, returning a GotoChoice.\n--\n-- This function:\n-- 1. Calls the before-handler to build template context\n-- 2. Renders the system template (if provided) and user template\n-- 3. Calls the LLM effect with rendered prompts and JSON schema\n-- 4. Parses the structured output\n-- 5. Calls the after-handler to determine the next transition\n--\n-- = Type Parameters\n--\n-- * @needs@ - The input type from Needs annotation\n-- * @schema@ - The LLM output schema type\n-- * @targets@ - The transition targets from UsesEffects\n-- * @es@ - The effect stack (must include LLM)\n-- * @tpl@ - The template context type\n--\n-- = Example\n--\n-- @\n-- result <- executeLLMHandler\n--   Nothing                          -- no system template\n", "criteria": "CRITERIA_0337", "selected": "SELECTED_0337", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraphWith", "range": {"end": {"character": 12, "line": 222}, "start": {"character": 0, "line": 222}}}
{"example_id": "0338", "variation": "positive_semantic", "code": "runGraphWith entryHandler graph input = do\n  choice <- callHandler entryHandler input\n  dispatchGoto graph choice\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LLM HANDLER EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Execute an LLMBoth handler, returning a GotoChoice.\n--\n-- This function:\n-- 1. Calls the before-handler to build template context\n-- 2. Renders the system template (if provided) and user template\n-- 3. Calls the LLM effect with rendered prompts and JSON schema\n-- 4. Parses the structured output\n-- 5. Calls the after-handler to determine the next transition\n--\n-- = Type Parameters\n--\n-- * @needs@ - The input type from Needs annotation\n-- * @schema@ - The LLM output schema type\n-- * @targets@ - The transition targets from UsesEffects\n-- * @es@ - The effect stack (must include LLM)\n-- * @tpl@ - The template context type\n--\n-- = Example\n--\n-- @\n-- result <- executeLLMHandler\n--   Nothing                          -- no system template\n", "criteria": "CRITERIA_0338", "selected": "SELECTED_0338", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraphWith", "range": {"end": {"character": 12, "line": 222}, "start": {"character": 0, "line": 222}}}
{"example_id": "0339", "variation": "negative_1", "code": "runGraphWith entryHandler graph input = do\n  choice <- callHandler entryHandler input\n  dispatchGoto graph choice\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LLM HANDLER EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Execute an LLMBoth handler, returning a GotoChoice.\n--\n-- This function:\n-- 1. Calls the before-handler to build template context\n-- 2. Renders the system template (if provided) and user template\n-- 3. Calls the LLM effect with rendered prompts and JSON schema\n-- 4. Parses the structured output\n-- 5. Calls the after-handler to determine the next transition\n--\n-- = Type Parameters\n--\n-- * @needs@ - The input type from Needs annotation\n-- * @schema@ - The LLM output schema type\n-- * @targets@ - The transition targets from UsesEffects\n-- * @es@ - The effect stack (must include LLM)\n-- * @tpl@ - The template context type\n--\n-- = Example\n--\n-- @\n-- result <- executeLLMHandler\n--   Nothing                          -- no system template\n", "criteria": "CRITERIA_0339", "selected": "SELECTED_0339", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraphWith", "range": {"end": {"character": 12, "line": 222}, "start": {"character": 0, "line": 222}}}
{"example_id": "0340", "variation": "negative_2", "code": "runGraphWith entryHandler graph input = do\n  choice <- callHandler entryHandler input\n  dispatchGoto graph choice\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LLM HANDLER EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Execute an LLMBoth handler, returning a GotoChoice.\n--\n-- This function:\n-- 1. Calls the before-handler to build template context\n-- 2. Renders the system template (if provided) and user template\n-- 3. Calls the LLM effect with rendered prompts and JSON schema\n-- 4. Parses the structured output\n-- 5. Calls the after-handler to determine the next transition\n--\n-- = Type Parameters\n--\n-- * @needs@ - The input type from Needs annotation\n-- * @schema@ - The LLM output schema type\n-- * @targets@ - The transition targets from UsesEffects\n-- * @es@ - The effect stack (must include LLM)\n-- * @tpl@ - The template context type\n--\n-- = Example\n--\n-- @\n-- result <- executeLLMHandler\n--   Nothing                          -- no system template\n", "criteria": "CRITERIA_0340", "selected": "SELECTED_0340", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "runGraphWith", "range": {"end": {"character": 12, "line": 222}, "start": {"character": 0, "line": 222}}}
{"example_id": "0341", "variation": "positive_structure", "code": "runLSP session = interpret $ \\case\n  Diagnostics _doc ->\n    -- Diagnostics come via notifications, not requests\n    -- Would need to track them in session state\n    pure []\n\n  Hover doc pos -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n        lspPos = toPosition pos\n    -- lsp-test's getHover takes TextDocumentIdentifier and Position\n    result <- getHover lspDoc lspPos\n    pure $ fromHoverResult result\n\n  References doc pos -> sendM $ executeSession session $ do\n    let lspPos = toPosition pos\n        filePath = uriToFilePath doc.tdiUri\n    -- Open the document first - HLS requires this for references to work\n    lspDoc <- openDoc filePath \"haskell\"\n    -- getReferences returns [Location]\n    locs <- getReferences lspDoc lspPos True  -- includeDeclaration = True\n    pure $ map fromLocation locs\n\n  Definition doc pos -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n        lspPos = toPosition pos\n    -- getDefinitions returns [Location] | [LocationLink]\n    result <- getDefinitions lspDoc lspPos\n    pure $ fromDefinitionResult result\n\n  CodeActions doc rng -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n", "criteria": "CRITERIA_0341", "selected": "SELECTED_0341", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "runLSP", "range": {"end": {"character": 6, "line": 180}, "start": {"character": 0, "line": 180}}}
{"example_id": "0342", "variation": "positive_semantic", "code": "runLSP session = interpret $ \\case\n  Diagnostics _doc ->\n    -- Diagnostics come via notifications, not requests\n    -- Would need to track them in session state\n    pure []\n\n  Hover doc pos -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n        lspPos = toPosition pos\n    -- lsp-test's getHover takes TextDocumentIdentifier and Position\n    result <- getHover lspDoc lspPos\n    pure $ fromHoverResult result\n\n  References doc pos -> sendM $ executeSession session $ do\n    let lspPos = toPosition pos\n        filePath = uriToFilePath doc.tdiUri\n    -- Open the document first - HLS requires this for references to work\n    lspDoc <- openDoc filePath \"haskell\"\n    -- getReferences returns [Location]\n    locs <- getReferences lspDoc lspPos True  -- includeDeclaration = True\n    pure $ map fromLocation locs\n\n  Definition doc pos -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n        lspPos = toPosition pos\n    -- getDefinitions returns [Location] | [LocationLink]\n    result <- getDefinitions lspDoc lspPos\n    pure $ fromDefinitionResult result\n\n  CodeActions doc rng -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n", "criteria": "CRITERIA_0342", "selected": "SELECTED_0342", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "runLSP", "range": {"end": {"character": 6, "line": 180}, "start": {"character": 0, "line": 180}}}
{"example_id": "0343", "variation": "negative_1", "code": "runLSP session = interpret $ \\case\n  Diagnostics _doc ->\n    -- Diagnostics come via notifications, not requests\n    -- Would need to track them in session state\n    pure []\n\n  Hover doc pos -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n        lspPos = toPosition pos\n    -- lsp-test's getHover takes TextDocumentIdentifier and Position\n    result <- getHover lspDoc lspPos\n    pure $ fromHoverResult result\n\n  References doc pos -> sendM $ executeSession session $ do\n    let lspPos = toPosition pos\n        filePath = uriToFilePath doc.tdiUri\n    -- Open the document first - HLS requires this for references to work\n    lspDoc <- openDoc filePath \"haskell\"\n    -- getReferences returns [Location]\n    locs <- getReferences lspDoc lspPos True  -- includeDeclaration = True\n    pure $ map fromLocation locs\n\n  Definition doc pos -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n        lspPos = toPosition pos\n    -- getDefinitions returns [Location] | [LocationLink]\n    result <- getDefinitions lspDoc lspPos\n    pure $ fromDefinitionResult result\n\n  CodeActions doc rng -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n", "criteria": "CRITERIA_0343", "selected": "SELECTED_0343", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "runLSP", "range": {"end": {"character": 6, "line": 180}, "start": {"character": 0, "line": 180}}}
{"example_id": "0344", "variation": "negative_2", "code": "runLSP session = interpret $ \\case\n  Diagnostics _doc ->\n    -- Diagnostics come via notifications, not requests\n    -- Would need to track them in session state\n    pure []\n\n  Hover doc pos -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n        lspPos = toPosition pos\n    -- lsp-test's getHover takes TextDocumentIdentifier and Position\n    result <- getHover lspDoc lspPos\n    pure $ fromHoverResult result\n\n  References doc pos -> sendM $ executeSession session $ do\n    let lspPos = toPosition pos\n        filePath = uriToFilePath doc.tdiUri\n    -- Open the document first - HLS requires this for references to work\n    lspDoc <- openDoc filePath \"haskell\"\n    -- getReferences returns [Location]\n    locs <- getReferences lspDoc lspPos True  -- includeDeclaration = True\n    pure $ map fromLocation locs\n\n  Definition doc pos -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n        lspPos = toPosition pos\n    -- getDefinitions returns [Location] | [LocationLink]\n    result <- getDefinitions lspDoc lspPos\n    pure $ fromDefinitionResult result\n\n  CodeActions doc rng -> sendM $ executeSession session $ do\n    let lspDoc = toTextDocumentId doc\n", "criteria": "CRITERIA_0344", "selected": "SELECTED_0344", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "runLSP", "range": {"end": {"character": 6, "line": 180}, "start": {"character": 0, "line": 180}}}
{"example_id": "0345", "variation": "positive_structure", "code": "runLLMCore hooks config mChatOps dispatcher = interpret $ \\case\n  RunTurnOp systemPrompt userContent schema tools -> do\n    sendM hooks.onTurnStart\n\n    priorHistory <- case mChatOps of\n      Nothing -> pure []  -- Compression: no prior history\n      Just ops -> ops.choGetHistory\n\n    let userText = extractText userContent\n    logDebug $ \"[LLM] Prior history: \" <> T.pack (show (length priorHistory)) <> \" messages\"\n    logDebug $ \"[LLM] User action: \" <> userText\n\n    let clientConfig = Client.ClientConfig\n          { Client.apiKey = config.llmApiKey\n          , Client.defaultModel = config.llmModel\n          , Client.defaultMaxTokens = config.llmMaxTokens\n          }\n        outputSchema = if schema == toJSON () then Nothing else Just schema\n        actionMsg = Message User userContent\n        initialMessages = priorHistory ++ [actionMsg]\n\n    loopResult <- toolLoop clientConfig systemPrompt outputSchema tools initialMessages [] [] []\n\n    case loopResult of\n      ToolLoopBroke breakReason -> do\n        logInfo $ \"[LLM] Turn broken by tool: \" <> breakReason\n        sendM hooks.onTurnEnd\n        return (TurnBroken breakReason)\n\n      ToolLoopTransitioned target payload -> do\n        logInfo $ \"[LLM] Tool initiated transition to \" <> target\n", "criteria": "CRITERIA_0345", "selected": "SELECTED_0345", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMCore", "range": {"end": {"character": 10, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0346", "variation": "positive_semantic", "code": "runLLMCore hooks config mChatOps dispatcher = interpret $ \\case\n  RunTurnOp systemPrompt userContent schema tools -> do\n    sendM hooks.onTurnStart\n\n    priorHistory <- case mChatOps of\n      Nothing -> pure []  -- Compression: no prior history\n      Just ops -> ops.choGetHistory\n\n    let userText = extractText userContent\n    logDebug $ \"[LLM] Prior history: \" <> T.pack (show (length priorHistory)) <> \" messages\"\n    logDebug $ \"[LLM] User action: \" <> userText\n\n    let clientConfig = Client.ClientConfig\n          { Client.apiKey = config.llmApiKey\n          , Client.defaultModel = config.llmModel\n          , Client.defaultMaxTokens = config.llmMaxTokens\n          }\n        outputSchema = if schema == toJSON () then Nothing else Just schema\n        actionMsg = Message User userContent\n        initialMessages = priorHistory ++ [actionMsg]\n\n    loopResult <- toolLoop clientConfig systemPrompt outputSchema tools initialMessages [] [] []\n\n    case loopResult of\n      ToolLoopBroke breakReason -> do\n        logInfo $ \"[LLM] Turn broken by tool: \" <> breakReason\n        sendM hooks.onTurnEnd\n        return (TurnBroken breakReason)\n\n      ToolLoopTransitioned target payload -> do\n        logInfo $ \"[LLM] Tool initiated transition to \" <> target\n", "criteria": "CRITERIA_0346", "selected": "SELECTED_0346", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMCore", "range": {"end": {"character": 10, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0347", "variation": "negative_1", "code": "runLLMCore hooks config mChatOps dispatcher = interpret $ \\case\n  RunTurnOp systemPrompt userContent schema tools -> do\n    sendM hooks.onTurnStart\n\n    priorHistory <- case mChatOps of\n      Nothing -> pure []  -- Compression: no prior history\n      Just ops -> ops.choGetHistory\n\n    let userText = extractText userContent\n    logDebug $ \"[LLM] Prior history: \" <> T.pack (show (length priorHistory)) <> \" messages\"\n    logDebug $ \"[LLM] User action: \" <> userText\n\n    let clientConfig = Client.ClientConfig\n          { Client.apiKey = config.llmApiKey\n          , Client.defaultModel = config.llmModel\n          , Client.defaultMaxTokens = config.llmMaxTokens\n          }\n        outputSchema = if schema == toJSON () then Nothing else Just schema\n        actionMsg = Message User userContent\n        initialMessages = priorHistory ++ [actionMsg]\n\n    loopResult <- toolLoop clientConfig systemPrompt outputSchema tools initialMessages [] [] []\n\n    case loopResult of\n      ToolLoopBroke breakReason -> do\n        logInfo $ \"[LLM] Turn broken by tool: \" <> breakReason\n        sendM hooks.onTurnEnd\n        return (TurnBroken breakReason)\n\n      ToolLoopTransitioned target payload -> do\n        logInfo $ \"[LLM] Tool initiated transition to \" <> target\n", "criteria": "CRITERIA_0347", "selected": "SELECTED_0347", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMCore", "range": {"end": {"character": 10, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0348", "variation": "negative_2", "code": "runLLMCore hooks config mChatOps dispatcher = interpret $ \\case\n  RunTurnOp systemPrompt userContent schema tools -> do\n    sendM hooks.onTurnStart\n\n    priorHistory <- case mChatOps of\n      Nothing -> pure []  -- Compression: no prior history\n      Just ops -> ops.choGetHistory\n\n    let userText = extractText userContent\n    logDebug $ \"[LLM] Prior history: \" <> T.pack (show (length priorHistory)) <> \" messages\"\n    logDebug $ \"[LLM] User action: \" <> userText\n\n    let clientConfig = Client.ClientConfig\n          { Client.apiKey = config.llmApiKey\n          , Client.defaultModel = config.llmModel\n          , Client.defaultMaxTokens = config.llmMaxTokens\n          }\n        outputSchema = if schema == toJSON () then Nothing else Just schema\n        actionMsg = Message User userContent\n        initialMessages = priorHistory ++ [actionMsg]\n\n    loopResult <- toolLoop clientConfig systemPrompt outputSchema tools initialMessages [] [] []\n\n    case loopResult of\n      ToolLoopBroke breakReason -> do\n        logInfo $ \"[LLM] Turn broken by tool: \" <> breakReason\n        sendM hooks.onTurnEnd\n        return (TurnBroken breakReason)\n\n      ToolLoopTransitioned target payload -> do\n        logInfo $ \"[LLM] Tool initiated transition to \" <> target\n", "criteria": "CRITERIA_0348", "selected": "SELECTED_0348", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMCore", "range": {"end": {"character": 10, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0349", "variation": "positive_structure", "code": "runLLM config = interpret $ \\case\n  RunTurnOp systemPrompt userContent schema tools -> do\n    priorHistory <- getHistory\n\n    let userText = extractText userContent\n    logDebug $ \"[LLM] Prior history: \" <> T.pack (show (length priorHistory)) <> \" messages\"\n    logDebug $ \"[LLM] User action: \" <> userText\n\n    let clientConfig = Client.ClientConfig\n          { Client.apiKey = config.llmApiKey\n          , Client.defaultModel = config.llmModel\n          , Client.defaultMaxTokens = config.llmMaxTokens\n          }\n        outputSchema = if schema == toJSON () then Nothing else Just schema\n        userMsg = Message User userContent\n        turnReq = Client.TurnRequest\n          { Client.prompt = userText\n          , Client.priorMessages = priorHistory\n          , Client.systemPrompt = Just systemPrompt\n          , Client.outputSchema = outputSchema\n          , Client.tools = tools\n          , Client.toolInterpreter = stubToolInterpreter\n          , Client.thinkingBudget = config.llmThinkingBudget\n          }\n\n    result <- sendM $ Client.runTurnRequest clientConfig turnReq\n    case result of\n      Left err -> do\n        logWarn $ \"[LLM] API error: \" <> T.pack (show err)\n        pure $ TurnCompleted TurnResult\n          { trOutput = toJSON ()\n", "criteria": "CRITERIA_0349", "selected": "SELECTED_0349", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLM", "range": {"end": {"character": 6, "line": 406}, "start": {"character": 0, "line": 406}}}
{"example_id": "0350", "variation": "positive_semantic", "code": "runLLM config = interpret $ \\case\n  RunTurnOp systemPrompt userContent schema tools -> do\n    priorHistory <- getHistory\n\n    let userText = extractText userContent\n    logDebug $ \"[LLM] Prior history: \" <> T.pack (show (length priorHistory)) <> \" messages\"\n    logDebug $ \"[LLM] User action: \" <> userText\n\n    let clientConfig = Client.ClientConfig\n          { Client.apiKey = config.llmApiKey\n          , Client.defaultModel = config.llmModel\n          , Client.defaultMaxTokens = config.llmMaxTokens\n          }\n        outputSchema = if schema == toJSON () then Nothing else Just schema\n        userMsg = Message User userContent\n        turnReq = Client.TurnRequest\n          { Client.prompt = userText\n          , Client.priorMessages = priorHistory\n          , Client.systemPrompt = Just systemPrompt\n          , Client.outputSchema = outputSchema\n          , Client.tools = tools\n          , Client.toolInterpreter = stubToolInterpreter\n          , Client.thinkingBudget = config.llmThinkingBudget\n          }\n\n    result <- sendM $ Client.runTurnRequest clientConfig turnReq\n    case result of\n      Left err -> do\n        logWarn $ \"[LLM] API error: \" <> T.pack (show err)\n        pure $ TurnCompleted TurnResult\n          { trOutput = toJSON ()\n", "criteria": "CRITERIA_0350", "selected": "SELECTED_0350", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLM", "range": {"end": {"character": 6, "line": 406}, "start": {"character": 0, "line": 406}}}
{"example_id": "0351", "variation": "negative_1", "code": "runLLM config = interpret $ \\case\n  RunTurnOp systemPrompt userContent schema tools -> do\n    priorHistory <- getHistory\n\n    let userText = extractText userContent\n    logDebug $ \"[LLM] Prior history: \" <> T.pack (show (length priorHistory)) <> \" messages\"\n    logDebug $ \"[LLM] User action: \" <> userText\n\n    let clientConfig = Client.ClientConfig\n          { Client.apiKey = config.llmApiKey\n          , Client.defaultModel = config.llmModel\n          , Client.defaultMaxTokens = config.llmMaxTokens\n          }\n        outputSchema = if schema == toJSON () then Nothing else Just schema\n        userMsg = Message User userContent\n        turnReq = Client.TurnRequest\n          { Client.prompt = userText\n          , Client.priorMessages = priorHistory\n          , Client.systemPrompt = Just systemPrompt\n          , Client.outputSchema = outputSchema\n          , Client.tools = tools\n          , Client.toolInterpreter = stubToolInterpreter\n          , Client.thinkingBudget = config.llmThinkingBudget\n          }\n\n    result <- sendM $ Client.runTurnRequest clientConfig turnReq\n    case result of\n      Left err -> do\n        logWarn $ \"[LLM] API error: \" <> T.pack (show err)\n        pure $ TurnCompleted TurnResult\n          { trOutput = toJSON ()\n", "criteria": "CRITERIA_0351", "selected": "SELECTED_0351", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLM", "range": {"end": {"character": 6, "line": 406}, "start": {"character": 0, "line": 406}}}
{"example_id": "0352", "variation": "negative_2", "code": "runLLM config = interpret $ \\case\n  RunTurnOp systemPrompt userContent schema tools -> do\n    priorHistory <- getHistory\n\n    let userText = extractText userContent\n    logDebug $ \"[LLM] Prior history: \" <> T.pack (show (length priorHistory)) <> \" messages\"\n    logDebug $ \"[LLM] User action: \" <> userText\n\n    let clientConfig = Client.ClientConfig\n          { Client.apiKey = config.llmApiKey\n          , Client.defaultModel = config.llmModel\n          , Client.defaultMaxTokens = config.llmMaxTokens\n          }\n        outputSchema = if schema == toJSON () then Nothing else Just schema\n        userMsg = Message User userContent\n        turnReq = Client.TurnRequest\n          { Client.prompt = userText\n          , Client.priorMessages = priorHistory\n          , Client.systemPrompt = Just systemPrompt\n          , Client.outputSchema = outputSchema\n          , Client.tools = tools\n          , Client.toolInterpreter = stubToolInterpreter\n          , Client.thinkingBudget = config.llmThinkingBudget\n          }\n\n    result <- sendM $ Client.runTurnRequest clientConfig turnReq\n    case result of\n      Left err -> do\n        logWarn $ \"[LLM] API error: \" <> T.pack (show err)\n        pure $ TurnCompleted TurnResult\n          { trOutput = toJSON ()\n", "criteria": "CRITERIA_0352", "selected": "SELECTED_0352", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLM", "range": {"end": {"character": 6, "line": 406}, "start": {"character": 0, "line": 406}}}
{"example_id": "0353", "variation": "positive_structure", "code": "runLLMWithTools config = runLLMWithToolsHooked @targets @effs @event @a noHooks config\n\n-- | Run the LLM effect with hooks for lifecycle events\n-- Uses shared 'runLLMCore' with ChatHistory operations enabled.\n", "criteria": "CRITERIA_0353", "selected": "SELECTED_0353", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMWithTools", "range": {"end": {"character": 15, "line": 472}, "start": {"character": 0, "line": 472}}}
{"example_id": "0354", "variation": "positive_semantic", "code": "runLLMWithTools config = runLLMWithToolsHooked @targets @effs @event @a noHooks config\n\n-- | Run the LLM effect with hooks for lifecycle events\n-- Uses shared 'runLLMCore' with ChatHistory operations enabled.\n", "criteria": "CRITERIA_0354", "selected": "SELECTED_0354", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMWithTools", "range": {"end": {"character": 15, "line": 472}, "start": {"character": 0, "line": 472}}}
{"example_id": "0355", "variation": "negative_1", "code": "runLLMWithTools config = runLLMWithToolsHooked @targets @effs @event @a noHooks config\n\n-- | Run the LLM effect with hooks for lifecycle events\n-- Uses shared 'runLLMCore' with ChatHistory operations enabled.\n", "criteria": "CRITERIA_0355", "selected": "SELECTED_0355", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMWithTools", "range": {"end": {"character": 15, "line": 472}, "start": {"character": 0, "line": 472}}}
{"example_id": "0356", "variation": "negative_2", "code": "runLLMWithTools config = runLLMWithToolsHooked @targets @effs @event @a noHooks config\n\n-- | Run the LLM effect with hooks for lifecycle events\n-- Uses shared 'runLLMCore' with ChatHistory operations enabled.\n", "criteria": "CRITERIA_0356", "selected": "SELECTED_0356", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMWithTools", "range": {"end": {"character": 15, "line": 472}, "start": {"character": 0, "line": 472}}}
{"example_id": "0357", "variation": "positive_structure", "code": "runLLMWithToolsHooked hooks config dispatcher =\n  let chatOps = ChatHistoryOps\n        { choGetHistory = getHistory\n        , choAppendMessages = appendMessages\n        }\n  in runLLMCore hooks config (Just chatOps) dispatcher\n\n-- | Run the LLM effect for compression - NO ChatHistory access.\n-- This is used during history compression to prevent infinite recursion.\n-- The 'NotMember ChatHistory effs' constraint is a compile-time guarantee\n-- that ChatHistory cannot be accessed by the compression LLM or its tools.\n", "criteria": "CRITERIA_0357", "selected": "SELECTED_0357", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMWithToolsHooked", "range": {"end": {"character": 21, "line": 484}, "start": {"character": 0, "line": 484}}}
{"example_id": "0358", "variation": "positive_semantic", "code": "runLLMWithToolsHooked hooks config dispatcher =\n  let chatOps = ChatHistoryOps\n        { choGetHistory = getHistory\n        , choAppendMessages = appendMessages\n        }\n  in runLLMCore hooks config (Just chatOps) dispatcher\n\n-- | Run the LLM effect for compression - NO ChatHistory access.\n-- This is used during history compression to prevent infinite recursion.\n-- The 'NotMember ChatHistory effs' constraint is a compile-time guarantee\n-- that ChatHistory cannot be accessed by the compression LLM or its tools.\n", "criteria": "CRITERIA_0358", "selected": "SELECTED_0358", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMWithToolsHooked", "range": {"end": {"character": 21, "line": 484}, "start": {"character": 0, "line": 484}}}
{"example_id": "0359", "variation": "negative_1", "code": "runLLMWithToolsHooked hooks config dispatcher =\n  let chatOps = ChatHistoryOps\n        { choGetHistory = getHistory\n        , choAppendMessages = appendMessages\n        }\n  in runLLMCore hooks config (Just chatOps) dispatcher\n\n-- | Run the LLM effect for compression - NO ChatHistory access.\n-- This is used during history compression to prevent infinite recursion.\n-- The 'NotMember ChatHistory effs' constraint is a compile-time guarantee\n-- that ChatHistory cannot be accessed by the compression LLM or its tools.\n", "criteria": "CRITERIA_0359", "selected": "SELECTED_0359", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMWithToolsHooked", "range": {"end": {"character": 21, "line": 484}, "start": {"character": 0, "line": 484}}}
{"example_id": "0360", "variation": "negative_2", "code": "runLLMWithToolsHooked hooks config dispatcher =\n  let chatOps = ChatHistoryOps\n        { choGetHistory = getHistory\n        , choAppendMessages = appendMessages\n        }\n  in runLLMCore hooks config (Just chatOps) dispatcher\n\n-- | Run the LLM effect for compression - NO ChatHistory access.\n-- This is used during history compression to prevent infinite recursion.\n-- The 'NotMember ChatHistory effs' constraint is a compile-time guarantee\n-- that ChatHistory cannot be accessed by the compression LLM or its tools.\n", "criteria": "CRITERIA_0360", "selected": "SELECTED_0360", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMWithToolsHooked", "range": {"end": {"character": 21, "line": 484}, "start": {"character": 0, "line": 484}}}
{"example_id": "0361", "variation": "positive_structure", "code": "runLLMForCompression config =\n  runLLMCore noHooks config Nothing  -- Nothing = no ChatHistory ops\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CHAT HISTORY RUNNERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run the ChatHistory effect backed by SQLite database\n", "criteria": "CRITERIA_0361", "selected": "SELECTED_0361", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMForCompression", "range": {"end": {"character": 20, "line": 505}, "start": {"character": 0, "line": 505}}}
{"example_id": "0362", "variation": "positive_semantic", "code": "runLLMForCompression config =\n  runLLMCore noHooks config Nothing  -- Nothing = no ChatHistory ops\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CHAT HISTORY RUNNERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run the ChatHistory effect backed by SQLite database\n", "criteria": "CRITERIA_0362", "selected": "SELECTED_0362", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMForCompression", "range": {"end": {"character": 20, "line": 505}, "start": {"character": 0, "line": 505}}}
{"example_id": "0363", "variation": "negative_1", "code": "runLLMForCompression config =\n  runLLMCore noHooks config Nothing  -- Nothing = no ChatHistory ops\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CHAT HISTORY RUNNERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run the ChatHistory effect backed by SQLite database\n", "criteria": "CRITERIA_0363", "selected": "SELECTED_0363", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMForCompression", "range": {"end": {"character": 20, "line": 505}, "start": {"character": 0, "line": 505}}}
{"example_id": "0364", "variation": "negative_2", "code": "runLLMForCompression config =\n  runLLMCore noHooks config Nothing  -- Nothing = no ChatHistory ops\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CHAT HISTORY RUNNERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run the ChatHistory effect backed by SQLite database\n", "criteria": "CRITERIA_0364", "selected": "SELECTED_0364", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runLLMForCompression", "range": {"end": {"character": 20, "line": 505}, "start": {"character": 0, "line": 505}}}
{"example_id": "0365", "variation": "positive_structure", "code": "runChatHistoryWithDB conn gameId mCursor action = do\n  initialHistory <- sendM $ case mCursor of\n    Nothing     -> Storage.loadMessages conn gameId\n    Just cursor -> Storage.loadMessagesAfter conn gameId cursor\n\n  ref <- sendM $ newIORef initialHistory\n\n  interpret (\\case\n    GetHistory -> sendM $ readIORef ref\n    AppendMessages msgs -> sendM $ do\n      modifyIORef ref (++ msgs)\n      Storage.appendMessages conn gameId msgs\n    ClearHistory -> sendM $ writeIORef ref []\n    ) action\n\n-- | Run the ChatHistory effect with automatic compression.\n-- When the estimated token count exceeds the threshold, older messages\n-- are compressed using an LLM call (with restricted effect stack).\n--\n-- The compression LLM has access to tools but NOT to ChatHistory,\n-- which prevents infinite recursion.\n--\n-- __Note__: Compression is performed synchronously within 'AppendMessages'.\n-- If the compression LLM call takes significant time (likely for API calls),\n-- this will block the caller until compression completes.\n", "criteria": "CRITERIA_0365", "selected": "SELECTED_0365", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runChatHistoryWithDB", "range": {"end": {"character": 20, "line": 520}, "start": {"character": 0, "line": 520}}}
{"example_id": "0366", "variation": "positive_semantic", "code": "runChatHistoryWithDB conn gameId mCursor action = do\n  initialHistory <- sendM $ case mCursor of\n    Nothing     -> Storage.loadMessages conn gameId\n    Just cursor -> Storage.loadMessagesAfter conn gameId cursor\n\n  ref <- sendM $ newIORef initialHistory\n\n  interpret (\\case\n    GetHistory -> sendM $ readIORef ref\n    AppendMessages msgs -> sendM $ do\n      modifyIORef ref (++ msgs)\n      Storage.appendMessages conn gameId msgs\n    ClearHistory -> sendM $ writeIORef ref []\n    ) action\n\n-- | Run the ChatHistory effect with automatic compression.\n-- When the estimated token count exceeds the threshold, older messages\n-- are compressed using an LLM call (with restricted effect stack).\n--\n-- The compression LLM has access to tools but NOT to ChatHistory,\n-- which prevents infinite recursion.\n--\n-- __Note__: Compression is performed synchronously within 'AppendMessages'.\n-- If the compression LLM call takes significant time (likely for API calls),\n-- this will block the caller until compression completes.\n", "criteria": "CRITERIA_0366", "selected": "SELECTED_0366", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runChatHistoryWithDB", "range": {"end": {"character": 20, "line": 520}, "start": {"character": 0, "line": 520}}}
{"example_id": "0367", "variation": "negative_1", "code": "runChatHistoryWithDB conn gameId mCursor action = do\n  initialHistory <- sendM $ case mCursor of\n    Nothing     -> Storage.loadMessages conn gameId\n    Just cursor -> Storage.loadMessagesAfter conn gameId cursor\n\n  ref <- sendM $ newIORef initialHistory\n\n  interpret (\\case\n    GetHistory -> sendM $ readIORef ref\n    AppendMessages msgs -> sendM $ do\n      modifyIORef ref (++ msgs)\n      Storage.appendMessages conn gameId msgs\n    ClearHistory -> sendM $ writeIORef ref []\n    ) action\n\n-- | Run the ChatHistory effect with automatic compression.\n-- When the estimated token count exceeds the threshold, older messages\n-- are compressed using an LLM call (with restricted effect stack).\n--\n-- The compression LLM has access to tools but NOT to ChatHistory,\n-- which prevents infinite recursion.\n--\n-- __Note__: Compression is performed synchronously within 'AppendMessages'.\n-- If the compression LLM call takes significant time (likely for API calls),\n-- this will block the caller until compression completes.\n", "criteria": "CRITERIA_0367", "selected": "SELECTED_0367", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runChatHistoryWithDB", "range": {"end": {"character": 20, "line": 520}, "start": {"character": 0, "line": 520}}}
{"example_id": "0368", "variation": "negative_2", "code": "runChatHistoryWithDB conn gameId mCursor action = do\n  initialHistory <- sendM $ case mCursor of\n    Nothing     -> Storage.loadMessages conn gameId\n    Just cursor -> Storage.loadMessagesAfter conn gameId cursor\n\n  ref <- sendM $ newIORef initialHistory\n\n  interpret (\\case\n    GetHistory -> sendM $ readIORef ref\n    AppendMessages msgs -> sendM $ do\n      modifyIORef ref (++ msgs)\n      Storage.appendMessages conn gameId msgs\n    ClearHistory -> sendM $ writeIORef ref []\n    ) action\n\n-- | Run the ChatHistory effect with automatic compression.\n-- When the estimated token count exceeds the threshold, older messages\n-- are compressed using an LLM call (with restricted effect stack).\n--\n-- The compression LLM has access to tools but NOT to ChatHistory,\n-- which prevents infinite recursion.\n--\n-- __Note__: Compression is performed synchronously within 'AppendMessages'.\n-- If the compression LLM call takes significant time (likely for API calls),\n-- this will block the caller until compression completes.\n", "criteria": "CRITERIA_0368", "selected": "SELECTED_0368", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runChatHistoryWithDB", "range": {"end": {"character": 20, "line": 520}, "start": {"character": 0, "line": 520}}}
{"example_id": "0369", "variation": "positive_structure", "code": "runChatHistoryWithCompression config action = do\n  historyRef <- sendM $ newIORef ([] :: [Message])\n\n  interpret (\\case\n    GetHistory -> sendM $ readIORef historyRef\n\n    ClearHistory -> sendM $ writeIORef historyRef []\n\n    AppendMessages newMsgs -> do\n      currentHistory <- sendM $ readIORef historyRef\n      let updatedHistory = currentHistory ++ newMsgs\n          tokenCount = estimateTokens updatedHistory\n\n      if tokenCount > config.chcTokenThreshold\n        then do\n          logInfo $ \"[ChatHistory] Compressing: \" <> T.pack (show tokenCount)\n                 <> \" tokens > \" <> T.pack (show config.chcTokenThreshold) <> \" threshold\"\n          compressed <- compressHistory config updatedHistory\n          sendM $ writeIORef historyRef compressed\n        else\n          sendM $ writeIORef historyRef updatedHistory\n    ) action\n\n-- | Compress old messages using the compression LLM\n", "criteria": "CRITERIA_0369", "selected": "SELECTED_0369", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runChatHistoryWithCompression", "range": {"end": {"character": 29, "line": 557}, "start": {"character": 0, "line": 557}}}
{"example_id": "0370", "variation": "positive_semantic", "code": "runChatHistoryWithCompression config action = do\n  historyRef <- sendM $ newIORef ([] :: [Message])\n\n  interpret (\\case\n    GetHistory -> sendM $ readIORef historyRef\n\n    ClearHistory -> sendM $ writeIORef historyRef []\n\n    AppendMessages newMsgs -> do\n      currentHistory <- sendM $ readIORef historyRef\n      let updatedHistory = currentHistory ++ newMsgs\n          tokenCount = estimateTokens updatedHistory\n\n      if tokenCount > config.chcTokenThreshold\n        then do\n          logInfo $ \"[ChatHistory] Compressing: \" <> T.pack (show tokenCount)\n                 <> \" tokens > \" <> T.pack (show config.chcTokenThreshold) <> \" threshold\"\n          compressed <- compressHistory config updatedHistory\n          sendM $ writeIORef historyRef compressed\n        else\n          sendM $ writeIORef historyRef updatedHistory\n    ) action\n\n-- | Compress old messages using the compression LLM\n", "criteria": "CRITERIA_0370", "selected": "SELECTED_0370", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runChatHistoryWithCompression", "range": {"end": {"character": 29, "line": 557}, "start": {"character": 0, "line": 557}}}
{"example_id": "0371", "variation": "negative_1", "code": "runChatHistoryWithCompression config action = do\n  historyRef <- sendM $ newIORef ([] :: [Message])\n\n  interpret (\\case\n    GetHistory -> sendM $ readIORef historyRef\n\n    ClearHistory -> sendM $ writeIORef historyRef []\n\n    AppendMessages newMsgs -> do\n      currentHistory <- sendM $ readIORef historyRef\n      let updatedHistory = currentHistory ++ newMsgs\n          tokenCount = estimateTokens updatedHistory\n\n      if tokenCount > config.chcTokenThreshold\n        then do\n          logInfo $ \"[ChatHistory] Compressing: \" <> T.pack (show tokenCount)\n                 <> \" tokens > \" <> T.pack (show config.chcTokenThreshold) <> \" threshold\"\n          compressed <- compressHistory config updatedHistory\n          sendM $ writeIORef historyRef compressed\n        else\n          sendM $ writeIORef historyRef updatedHistory\n    ) action\n\n-- | Compress old messages using the compression LLM\n", "criteria": "CRITERIA_0371", "selected": "SELECTED_0371", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runChatHistoryWithCompression", "range": {"end": {"character": 29, "line": 557}, "start": {"character": 0, "line": 557}}}
{"example_id": "0372", "variation": "negative_2", "code": "runChatHistoryWithCompression config action = do\n  historyRef <- sendM $ newIORef ([] :: [Message])\n\n  interpret (\\case\n    GetHistory -> sendM $ readIORef historyRef\n\n    ClearHistory -> sendM $ writeIORef historyRef []\n\n    AppendMessages newMsgs -> do\n      currentHistory <- sendM $ readIORef historyRef\n      let updatedHistory = currentHistory ++ newMsgs\n          tokenCount = estimateTokens updatedHistory\n\n      if tokenCount > config.chcTokenThreshold\n        then do\n          logInfo $ \"[ChatHistory] Compressing: \" <> T.pack (show tokenCount)\n                 <> \" tokens > \" <> T.pack (show config.chcTokenThreshold) <> \" threshold\"\n          compressed <- compressHistory config updatedHistory\n          sendM $ writeIORef historyRef compressed\n        else\n          sendM $ writeIORef historyRef updatedHistory\n    ) action\n\n-- | Compress old messages using the compression LLM\n", "criteria": "CRITERIA_0372", "selected": "SELECTED_0372", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runChatHistoryWithCompression", "range": {"end": {"character": 29, "line": 557}, "start": {"character": 0, "line": 557}}}
{"example_id": "0373", "variation": "positive_structure", "code": "runCompressionLLM config userPrompt = do\n  let cc = config.chcCompression\n\n  -- Use the LLM effect from the stack\n  -- The caller provides the interpreter (real API or mock for tests)\n  outcome <- runTurnContent cc.ccPrompt [TextBlock userPrompt] cc.ccSchema cc.ccTools\n  pure $ case outcome of\n    TurnBroken reason ->\n      -- Fallback: just use a placeholder\n      [Message Assistant [TextBlock $ \"[Compressed history - interrupted: \" <> reason <> \"]\"]]\n\n    TurnTransitionHint target _payload ->\n      -- Fallback: compression shouldn't trigger transitions\n      [Message Assistant [TextBlock $ \"[Compressed history - unexpected transition to \" <> target <> \"]\"]]\n\n    TurnCompleted parseResult -> case parseResult of\n      TurnParsed tr ->\n        -- Extract summary from the structured output\n        case extractSummary tr.trOutput of\n          Just summary -> [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> summary]]\n          Nothing -> [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> tr.trNarrative]]\n      TurnParseFailed{tpfNarrative = narr} ->\n        -- Fallback on parse failure\n        [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> narr]]\n  where\n    -- Extract summary from structured output.\n    -- Tries common field names: \"summary\", \"coSummary\", \"text\", \"content\"\n    extractSummary :: Value -> Maybe Text\n    extractSummary (Object obj) =\n      let candidates = [\"summary\", \"coSummary\", \"text\", \"content\"]\n      in foldr (\\key acc -> case KM.lookup key obj of\n", "criteria": "CRITERIA_0373", "selected": "SELECTED_0373", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runCompressionLLM", "range": {"end": {"character": 17, "line": 627}, "start": {"character": 0, "line": 627}}}
{"example_id": "0374", "variation": "positive_semantic", "code": "runCompressionLLM config userPrompt = do\n  let cc = config.chcCompression\n\n  -- Use the LLM effect from the stack\n  -- The caller provides the interpreter (real API or mock for tests)\n  outcome <- runTurnContent cc.ccPrompt [TextBlock userPrompt] cc.ccSchema cc.ccTools\n  pure $ case outcome of\n    TurnBroken reason ->\n      -- Fallback: just use a placeholder\n      [Message Assistant [TextBlock $ \"[Compressed history - interrupted: \" <> reason <> \"]\"]]\n\n    TurnTransitionHint target _payload ->\n      -- Fallback: compression shouldn't trigger transitions\n      [Message Assistant [TextBlock $ \"[Compressed history - unexpected transition to \" <> target <> \"]\"]]\n\n    TurnCompleted parseResult -> case parseResult of\n      TurnParsed tr ->\n        -- Extract summary from the structured output\n        case extractSummary tr.trOutput of\n          Just summary -> [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> summary]]\n          Nothing -> [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> tr.trNarrative]]\n      TurnParseFailed{tpfNarrative = narr} ->\n        -- Fallback on parse failure\n        [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> narr]]\n  where\n    -- Extract summary from structured output.\n    -- Tries common field names: \"summary\", \"coSummary\", \"text\", \"content\"\n    extractSummary :: Value -> Maybe Text\n    extractSummary (Object obj) =\n      let candidates = [\"summary\", \"coSummary\", \"text\", \"content\"]\n      in foldr (\\key acc -> case KM.lookup key obj of\n", "criteria": "CRITERIA_0374", "selected": "SELECTED_0374", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runCompressionLLM", "range": {"end": {"character": 17, "line": 627}, "start": {"character": 0, "line": 627}}}
{"example_id": "0375", "variation": "negative_1", "code": "runCompressionLLM config userPrompt = do\n  let cc = config.chcCompression\n\n  -- Use the LLM effect from the stack\n  -- The caller provides the interpreter (real API or mock for tests)\n  outcome <- runTurnContent cc.ccPrompt [TextBlock userPrompt] cc.ccSchema cc.ccTools\n  pure $ case outcome of\n    TurnBroken reason ->\n      -- Fallback: just use a placeholder\n      [Message Assistant [TextBlock $ \"[Compressed history - interrupted: \" <> reason <> \"]\"]]\n\n    TurnTransitionHint target _payload ->\n      -- Fallback: compression shouldn't trigger transitions\n      [Message Assistant [TextBlock $ \"[Compressed history - unexpected transition to \" <> target <> \"]\"]]\n\n    TurnCompleted parseResult -> case parseResult of\n      TurnParsed tr ->\n        -- Extract summary from the structured output\n        case extractSummary tr.trOutput of\n          Just summary -> [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> summary]]\n          Nothing -> [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> tr.trNarrative]]\n      TurnParseFailed{tpfNarrative = narr} ->\n        -- Fallback on parse failure\n        [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> narr]]\n  where\n    -- Extract summary from structured output.\n    -- Tries common field names: \"summary\", \"coSummary\", \"text\", \"content\"\n    extractSummary :: Value -> Maybe Text\n    extractSummary (Object obj) =\n      let candidates = [\"summary\", \"coSummary\", \"text\", \"content\"]\n      in foldr (\\key acc -> case KM.lookup key obj of\n", "criteria": "CRITERIA_0375", "selected": "SELECTED_0375", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runCompressionLLM", "range": {"end": {"character": 17, "line": 627}, "start": {"character": 0, "line": 627}}}
{"example_id": "0376", "variation": "negative_2", "code": "runCompressionLLM config userPrompt = do\n  let cc = config.chcCompression\n\n  -- Use the LLM effect from the stack\n  -- The caller provides the interpreter (real API or mock for tests)\n  outcome <- runTurnContent cc.ccPrompt [TextBlock userPrompt] cc.ccSchema cc.ccTools\n  pure $ case outcome of\n    TurnBroken reason ->\n      -- Fallback: just use a placeholder\n      [Message Assistant [TextBlock $ \"[Compressed history - interrupted: \" <> reason <> \"]\"]]\n\n    TurnTransitionHint target _payload ->\n      -- Fallback: compression shouldn't trigger transitions\n      [Message Assistant [TextBlock $ \"[Compressed history - unexpected transition to \" <> target <> \"]\"]]\n\n    TurnCompleted parseResult -> case parseResult of\n      TurnParsed tr ->\n        -- Extract summary from the structured output\n        case extractSummary tr.trOutput of\n          Just summary -> [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> summary]]\n          Nothing -> [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> tr.trNarrative]]\n      TurnParseFailed{tpfNarrative = narr} ->\n        -- Fallback on parse failure\n        [Message Assistant [TextBlock $ \"[Compressed history]\\n\" <> narr]]\n  where\n    -- Extract summary from structured output.\n    -- Tries common field names: \"summary\", \"coSummary\", \"text\", \"content\"\n    extractSummary :: Value -> Maybe Text\n    extractSummary (Object obj) =\n      let candidates = [\"summary\", \"coSummary\", \"text\", \"content\"]\n      in foldr (\\key acc -> case KM.lookup key obj of\n", "criteria": "CRITERIA_0376", "selected": "SELECTED_0376", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runCompressionLLM", "range": {"end": {"character": 17, "line": 627}, "start": {"character": 0, "line": 627}}}
{"example_id": "0377", "variation": "positive_structure", "code": "runGame initialState llmConfig eventHandler inputHandler minLogLevel =\n  runM\n    . runTime\n    . runRandom\n    . runEmit eventHandler\n    . runState initialState\n    . runChatHistory\n    . runLog minLogLevel\n    . runRequestInput inputHandler\n    . runLLM llmConfig\n\n-- Helper: Extract text content from content blocks\n", "criteria": "CRITERIA_0377", "selected": "SELECTED_0377", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runGame", "range": {"end": {"character": 7, "line": 696}, "start": {"character": 0, "line": 696}}}
{"example_id": "0378", "variation": "positive_semantic", "code": "runGame initialState llmConfig eventHandler inputHandler minLogLevel =\n  runM\n    . runTime\n    . runRandom\n    . runEmit eventHandler\n    . runState initialState\n    . runChatHistory\n    . runLog minLogLevel\n    . runRequestInput inputHandler\n    . runLLM llmConfig\n\n-- Helper: Extract text content from content blocks\n", "criteria": "CRITERIA_0378", "selected": "SELECTED_0378", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runGame", "range": {"end": {"character": 7, "line": 696}, "start": {"character": 0, "line": 696}}}
{"example_id": "0379", "variation": "negative_1", "code": "runGame initialState llmConfig eventHandler inputHandler minLogLevel =\n  runM\n    . runTime\n    . runRandom\n    . runEmit eventHandler\n    . runState initialState\n    . runChatHistory\n    . runLog minLogLevel\n    . runRequestInput inputHandler\n    . runLLM llmConfig\n\n-- Helper: Extract text content from content blocks\n", "criteria": "CRITERIA_0379", "selected": "SELECTED_0379", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runGame", "range": {"end": {"character": 7, "line": 696}, "start": {"character": 0, "line": 696}}}
{"example_id": "0380", "variation": "negative_2", "code": "runGame initialState llmConfig eventHandler inputHandler minLogLevel =\n  runM\n    . runTime\n    . runRandom\n    . runEmit eventHandler\n    . runState initialState\n    . runChatHistory\n    . runLog minLogLevel\n    . runRequestInput inputHandler\n    . runLLM llmConfig\n\n-- Helper: Extract text content from content blocks\n", "criteria": "CRITERIA_0380", "selected": "SELECTED_0380", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "runGame", "range": {"end": {"character": 7, "line": 696}, "start": {"character": 0, "line": 696}}}
{"example_id": "0381", "variation": "positive_structure", "code": "runTurnRequest config turnReq = do\n  -- Build output format if schema provided\n  let outputFmt = case turnReq.outputSchema of\n        Nothing -> Nothing\n        Just schema -> Just OutputFormat\n          { outputType = \"json_schema\"\n          , outputSchema = schema\n          }\n\n  -- Build thinking config if budget provided\n  let thinkingCfg = case turnReq.thinkingBudget of\n        Nothing -> Nothing\n        Just budget -> Just ThinkingConfig\n          { thinkingType = \"enabled\"\n          , budgetTokens = budget\n          }\n\n  -- Build initial request\n  -- Note: when thinking is enabled, tool_choice must be \"auto\" or \"none\"\n  -- Build messages with prior history + new user message\n  let allMessages = turnReq.priorMessages ++ [Message User [TextBlock turnReq.prompt]]\n      initialRequest = MessagesRequest\n        { model = config.defaultModel\n        , messages = allMessages\n        , maxTokens = config.defaultMaxTokens\n        , system = turnReq.systemPrompt\n        , tools = if null turnReq.tools then Nothing else Just turnReq.tools\n        , toolChoice = if null turnReq.tools then Nothing else Just ToolChoiceAuto\n        , outputFormat = outputFmt\n        , thinking = thinkingCfg\n        }\n", "criteria": "CRITERIA_0381", "selected": "SELECTED_0381", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Anthropic/Client.hs", "name": "runTurnRequest", "range": {"end": {"character": 14, "line": 169}, "start": {"character": 0, "line": 169}}}
{"example_id": "0382", "variation": "positive_semantic", "code": "runTurnRequest config turnReq = do\n  -- Build output format if schema provided\n  let outputFmt = case turnReq.outputSchema of\n        Nothing -> Nothing\n        Just schema -> Just OutputFormat\n          { outputType = \"json_schema\"\n          , outputSchema = schema\n          }\n\n  -- Build thinking config if budget provided\n  let thinkingCfg = case turnReq.thinkingBudget of\n        Nothing -> Nothing\n        Just budget -> Just ThinkingConfig\n          { thinkingType = \"enabled\"\n          , budgetTokens = budget\n          }\n\n  -- Build initial request\n  -- Note: when thinking is enabled, tool_choice must be \"auto\" or \"none\"\n  -- Build messages with prior history + new user message\n  let allMessages = turnReq.priorMessages ++ [Message User [TextBlock turnReq.prompt]]\n      initialRequest = MessagesRequest\n        { model = config.defaultModel\n        , messages = allMessages\n        , maxTokens = config.defaultMaxTokens\n        , system = turnReq.systemPrompt\n        , tools = if null turnReq.tools then Nothing else Just turnReq.tools\n        , toolChoice = if null turnReq.tools then Nothing else Just ToolChoiceAuto\n        , outputFormat = outputFmt\n        , thinking = thinkingCfg\n        }\n", "criteria": "CRITERIA_0382", "selected": "SELECTED_0382", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Anthropic/Client.hs", "name": "runTurnRequest", "range": {"end": {"character": 14, "line": 169}, "start": {"character": 0, "line": 169}}}
{"example_id": "0383", "variation": "negative_1", "code": "runTurnRequest config turnReq = do\n  -- Build output format if schema provided\n  let outputFmt = case turnReq.outputSchema of\n        Nothing -> Nothing\n        Just schema -> Just OutputFormat\n          { outputType = \"json_schema\"\n          , outputSchema = schema\n          }\n\n  -- Build thinking config if budget provided\n  let thinkingCfg = case turnReq.thinkingBudget of\n        Nothing -> Nothing\n        Just budget -> Just ThinkingConfig\n          { thinkingType = \"enabled\"\n          , budgetTokens = budget\n          }\n\n  -- Build initial request\n  -- Note: when thinking is enabled, tool_choice must be \"auto\" or \"none\"\n  -- Build messages with prior history + new user message\n  let allMessages = turnReq.priorMessages ++ [Message User [TextBlock turnReq.prompt]]\n      initialRequest = MessagesRequest\n        { model = config.defaultModel\n        , messages = allMessages\n        , maxTokens = config.defaultMaxTokens\n        , system = turnReq.systemPrompt\n        , tools = if null turnReq.tools then Nothing else Just turnReq.tools\n        , toolChoice = if null turnReq.tools then Nothing else Just ToolChoiceAuto\n        , outputFormat = outputFmt\n        , thinking = thinkingCfg\n        }\n", "criteria": "CRITERIA_0383", "selected": "SELECTED_0383", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Anthropic/Client.hs", "name": "runTurnRequest", "range": {"end": {"character": 14, "line": 169}, "start": {"character": 0, "line": 169}}}
{"example_id": "0384", "variation": "negative_2", "code": "runTurnRequest config turnReq = do\n  -- Build output format if schema provided\n  let outputFmt = case turnReq.outputSchema of\n        Nothing -> Nothing\n        Just schema -> Just OutputFormat\n          { outputType = \"json_schema\"\n          , outputSchema = schema\n          }\n\n  -- Build thinking config if budget provided\n  let thinkingCfg = case turnReq.thinkingBudget of\n        Nothing -> Nothing\n        Just budget -> Just ThinkingConfig\n          { thinkingType = \"enabled\"\n          , budgetTokens = budget\n          }\n\n  -- Build initial request\n  -- Note: when thinking is enabled, tool_choice must be \"auto\" or \"none\"\n  -- Build messages with prior history + new user message\n  let allMessages = turnReq.priorMessages ++ [Message User [TextBlock turnReq.prompt]]\n      initialRequest = MessagesRequest\n        { model = config.defaultModel\n        , messages = allMessages\n        , maxTokens = config.defaultMaxTokens\n        , system = turnReq.systemPrompt\n        , tools = if null turnReq.tools then Nothing else Just turnReq.tools\n        , toolChoice = if null turnReq.tools then Nothing else Just ToolChoiceAuto\n        , outputFormat = outputFmt\n        , thinking = thinkingCfg\n        }\n", "criteria": "CRITERIA_0384", "selected": "SELECTED_0384", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Anthropic/Client.hs", "name": "runTurnRequest", "range": {"end": {"character": 14, "line": 169}, "start": {"character": 0, "line": 169}}}
{"example_id": "0385", "variation": "positive_structure", "code": "runCLIWithLLM desc parser handler = do\n  let combinedParser = (,) <$> parser <*> outputFormatParser\n      parserInfo' = info (combinedParser <**> helper)\n        ( fullDesc\n        <> progDesc (T.unpack desc)\n        )\n  (input, fmt) <- execParser parserInfo'\n  result <- handler input\n  TIO.putStrLn (formatOutput fmt result)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CLIENT CONFIG HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Create a default ClientConfig for CLI tools.\n--\n-- Uses Claude Sonnet 4 with sensible defaults:\n--\n-- * Model: claude-sonnet-4-20250514\n-- * Max tokens: 2048\n--\n-- @\n-- config = makeClientConfig \"sk-ant-...\"\n-- @\n", "criteria": "CRITERIA_0385", "selected": "SELECTED_0385", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Graph/CLI/Runner.hs", "name": "runCLIWithLLM", "range": {"end": {"character": 13, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0386", "variation": "positive_semantic", "code": "runCLIWithLLM desc parser handler = do\n  let combinedParser = (,) <$> parser <*> outputFormatParser\n      parserInfo' = info (combinedParser <**> helper)\n        ( fullDesc\n        <> progDesc (T.unpack desc)\n        )\n  (input, fmt) <- execParser parserInfo'\n  result <- handler input\n  TIO.putStrLn (formatOutput fmt result)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CLIENT CONFIG HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Create a default ClientConfig for CLI tools.\n--\n-- Uses Claude Sonnet 4 with sensible defaults:\n--\n-- * Model: claude-sonnet-4-20250514\n-- * Max tokens: 2048\n--\n-- @\n-- config = makeClientConfig \"sk-ant-...\"\n-- @\n", "criteria": "CRITERIA_0386", "selected": "SELECTED_0386", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Graph/CLI/Runner.hs", "name": "runCLIWithLLM", "range": {"end": {"character": 13, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0387", "variation": "negative_1", "code": "runCLIWithLLM desc parser handler = do\n  let combinedParser = (,) <$> parser <*> outputFormatParser\n      parserInfo' = info (combinedParser <**> helper)\n        ( fullDesc\n        <> progDesc (T.unpack desc)\n        )\n  (input, fmt) <- execParser parserInfo'\n  result <- handler input\n  TIO.putStrLn (formatOutput fmt result)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CLIENT CONFIG HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Create a default ClientConfig for CLI tools.\n--\n-- Uses Claude Sonnet 4 with sensible defaults:\n--\n-- * Model: claude-sonnet-4-20250514\n-- * Max tokens: 2048\n--\n-- @\n-- config = makeClientConfig \"sk-ant-...\"\n-- @\n", "criteria": "CRITERIA_0387", "selected": "SELECTED_0387", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Graph/CLI/Runner.hs", "name": "runCLIWithLLM", "range": {"end": {"character": 13, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0388", "variation": "negative_2", "code": "runCLIWithLLM desc parser handler = do\n  let combinedParser = (,) <$> parser <*> outputFormatParser\n      parserInfo' = info (combinedParser <**> helper)\n        ( fullDesc\n        <> progDesc (T.unpack desc)\n        )\n  (input, fmt) <- execParser parserInfo'\n  result <- handler input\n  TIO.putStrLn (formatOutput fmt result)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CLIENT CONFIG HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Create a default ClientConfig for CLI tools.\n--\n-- Uses Claude Sonnet 4 with sensible defaults:\n--\n-- * Model: claude-sonnet-4-20250514\n-- * Max tokens: 2048\n--\n-- @\n-- config = makeClientConfig \"sk-ant-...\"\n-- @\n", "criteria": "CRITERIA_0388", "selected": "SELECTED_0388", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Graph/CLI/Runner.hs", "name": "runCLIWithLLM", "range": {"end": {"character": 13, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0389", "variation": "positive_structure", "code": "runTeachGemmaHTTP endpoint = interpret $ \\case\n  SelectRelevantSymbols topic sym candidates -> do\n    sendM $ putStrLn $ \"[TeachGemma] Candidates: \" <> T.unpack (T.intercalate \", \" candidates)\n\n    -- If no candidates, nothing to select\n    if null candidates\n      then do\n        sendM $ putStrLn \"[TeachGemma] No candidates to select from\"\n        pure []\n      else do\n        sendM $ putStrLn $ \"[TeachGemma] HTTP call to \" <> T.unpack endpoint\n          <> \" for: \" <> T.unpack (lsName sym)\n        result <- sendM $ callOllamaSelect endpoint topic sym candidates\n        case result of\n          Right selected -> do\n            sendM $ putStrLn $ \"[TeachGemma] Selected: \" <> T.unpack (T.intercalate \", \" selected)\n            -- Validate: only return candidates that were in the input\n            let valid = filter (`elem` candidates) selected\n            if null valid && not (null selected)\n              then do\n                sendM $ putStrLn \"[TeachGemma] Selection invalid, using all candidates\"\n                pure candidates  -- Fallback\n              else pure valid\n          Left err -> do\n            sendM $ putStrLn $ \"[TeachGemma] ERROR: \" <> T.unpack err\n            sendM $ putStrLn \"[TeachGemma] Selection failed, using all candidates\"\n            pure candidates  -- Fallback: return all candidates\n\n\n-- | Call Ollama's /api/chat endpoint for symbol selection.\n--\n", "criteria": "CRITERIA_0389", "selected": "SELECTED_0389", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "runTeachGemmaHTTP", "range": {"end": {"character": 17, "line": 184}, "start": {"character": 0, "line": 184}}}
{"example_id": "0390", "variation": "positive_semantic", "code": "runTeachGemmaHTTP endpoint = interpret $ \\case\n  SelectRelevantSymbols topic sym candidates -> do\n    sendM $ putStrLn $ \"[TeachGemma] Candidates: \" <> T.unpack (T.intercalate \", \" candidates)\n\n    -- If no candidates, nothing to select\n    if null candidates\n      then do\n        sendM $ putStrLn \"[TeachGemma] No candidates to select from\"\n        pure []\n      else do\n        sendM $ putStrLn $ \"[TeachGemma] HTTP call to \" <> T.unpack endpoint\n          <> \" for: \" <> T.unpack (lsName sym)\n        result <- sendM $ callOllamaSelect endpoint topic sym candidates\n        case result of\n          Right selected -> do\n            sendM $ putStrLn $ \"[TeachGemma] Selected: \" <> T.unpack (T.intercalate \", \" selected)\n            -- Validate: only return candidates that were in the input\n            let valid = filter (`elem` candidates) selected\n            if null valid && not (null selected)\n              then do\n                sendM $ putStrLn \"[TeachGemma] Selection invalid, using all candidates\"\n                pure candidates  -- Fallback\n              else pure valid\n          Left err -> do\n            sendM $ putStrLn $ \"[TeachGemma] ERROR: \" <> T.unpack err\n            sendM $ putStrLn \"[TeachGemma] Selection failed, using all candidates\"\n            pure candidates  -- Fallback: return all candidates\n\n\n-- | Call Ollama's /api/chat endpoint for symbol selection.\n--\n", "criteria": "CRITERIA_0390", "selected": "SELECTED_0390", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "runTeachGemmaHTTP", "range": {"end": {"character": 17, "line": 184}, "start": {"character": 0, "line": 184}}}
{"example_id": "0391", "variation": "negative_1", "code": "runTeachGemmaHTTP endpoint = interpret $ \\case\n  SelectRelevantSymbols topic sym candidates -> do\n    sendM $ putStrLn $ \"[TeachGemma] Candidates: \" <> T.unpack (T.intercalate \", \" candidates)\n\n    -- If no candidates, nothing to select\n    if null candidates\n      then do\n        sendM $ putStrLn \"[TeachGemma] No candidates to select from\"\n        pure []\n      else do\n        sendM $ putStrLn $ \"[TeachGemma] HTTP call to \" <> T.unpack endpoint\n          <> \" for: \" <> T.unpack (lsName sym)\n        result <- sendM $ callOllamaSelect endpoint topic sym candidates\n        case result of\n          Right selected -> do\n            sendM $ putStrLn $ \"[TeachGemma] Selected: \" <> T.unpack (T.intercalate \", \" selected)\n            -- Validate: only return candidates that were in the input\n            let valid = filter (`elem` candidates) selected\n            if null valid && not (null selected)\n              then do\n                sendM $ putStrLn \"[TeachGemma] Selection invalid, using all candidates\"\n                pure candidates  -- Fallback\n              else pure valid\n          Left err -> do\n            sendM $ putStrLn $ \"[TeachGemma] ERROR: \" <> T.unpack err\n            sendM $ putStrLn \"[TeachGemma] Selection failed, using all candidates\"\n            pure candidates  -- Fallback: return all candidates\n\n\n-- | Call Ollama's /api/chat endpoint for symbol selection.\n--\n", "criteria": "CRITERIA_0391", "selected": "SELECTED_0391", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "runTeachGemmaHTTP", "range": {"end": {"character": 17, "line": 184}, "start": {"character": 0, "line": 184}}}
{"example_id": "0392", "variation": "negative_2", "code": "runTeachGemmaHTTP endpoint = interpret $ \\case\n  SelectRelevantSymbols topic sym candidates -> do\n    sendM $ putStrLn $ \"[TeachGemma] Candidates: \" <> T.unpack (T.intercalate \", \" candidates)\n\n    -- If no candidates, nothing to select\n    if null candidates\n      then do\n        sendM $ putStrLn \"[TeachGemma] No candidates to select from\"\n        pure []\n      else do\n        sendM $ putStrLn $ \"[TeachGemma] HTTP call to \" <> T.unpack endpoint\n          <> \" for: \" <> T.unpack (lsName sym)\n        result <- sendM $ callOllamaSelect endpoint topic sym candidates\n        case result of\n          Right selected -> do\n            sendM $ putStrLn $ \"[TeachGemma] Selected: \" <> T.unpack (T.intercalate \", \" selected)\n            -- Validate: only return candidates that were in the input\n            let valid = filter (`elem` candidates) selected\n            if null valid && not (null selected)\n              then do\n                sendM $ putStrLn \"[TeachGemma] Selection invalid, using all candidates\"\n                pure candidates  -- Fallback\n              else pure valid\n          Left err -> do\n            sendM $ putStrLn $ \"[TeachGemma] ERROR: \" <> T.unpack err\n            sendM $ putStrLn \"[TeachGemma] Selection failed, using all candidates\"\n            pure candidates  -- Fallback: return all candidates\n\n\n-- | Call Ollama's /api/chat endpoint for symbol selection.\n--\n", "criteria": "CRITERIA_0392", "selected": "SELECTED_0392", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "runTeachGemmaHTTP", "range": {"end": {"character": 17, "line": 184}, "start": {"character": 0, "line": 184}}}
{"example_id": "0393", "variation": "positive_structure", "code": "runTeachGemmaMock = interpret $ \\case\n  SelectRelevantSymbols _topic _sym candidates -> pure candidates\n", "criteria": "CRITERIA_0393", "selected": "SELECTED_0393", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "runTeachGemmaMock", "range": {"end": {"character": 17, "line": 371}, "start": {"character": 0, "line": 371}}}
{"example_id": "0394", "variation": "positive_semantic", "code": "runTeachGemmaMock = interpret $ \\case\n  SelectRelevantSymbols _topic _sym candidates -> pure candidates\n", "criteria": "CRITERIA_0394", "selected": "SELECTED_0394", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "runTeachGemmaMock", "range": {"end": {"character": 17, "line": 371}, "start": {"character": 0, "line": 371}}}
{"example_id": "0395", "variation": "negative_1", "code": "runTeachGemmaMock = interpret $ \\case\n  SelectRelevantSymbols _topic _sym candidates -> pure candidates\n", "criteria": "CRITERIA_0395", "selected": "SELECTED_0395", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "runTeachGemmaMock", "range": {"end": {"character": 17, "line": 371}, "start": {"character": 0, "line": 371}}}
{"example_id": "0396", "variation": "negative_2", "code": "runTeachGemmaMock = interpret $ \\case\n  SelectRelevantSymbols _topic _sym candidates -> pure candidates\n", "criteria": "CRITERIA_0396", "selected": "SELECTED_0396", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "runTeachGemmaMock", "range": {"end": {"character": 17, "line": 371}, "start": {"character": 0, "line": 371}}}
{"example_id": "0397", "variation": "positive_structure", "code": "runServer config = do\n  let tidepoolDir = config.projectDir </> \".tidepool\"\n  let socketPath = tidepoolDir </> \"control.sock\"\n\n  -- Setup .tidepool directory\n  createDirectoryIfMissing True tidepoolDir\n  TIO.putStrLn $ \"Created .tidepool directory at \" <> T.pack tidepoolDir\n  hFlush stdout\n\n  -- Clean up stale socket\n  staleExists <- doesFileExist socketPath\n  when staleExists $ do\n    TIO.putStrLn \"Removing stale socket file...\"\n    removeFile socketPath\n\n  TIO.putStrLn $ \"Starting LSP session for project: \" <> T.pack config.projectDir\n  hFlush stdout\n\n  -- Start LSP session and run server\n  withLSPSession config.projectDir $ \\lspSession -> do\n    TIO.putStrLn \"LSP session initialized\"\n    hFlush stdout\n\n    bracket (setupSocket socketPath) (closeSocket socketPath) $ \\sock -> do\n      TIO.putStrLn $ \"Control server listening on \" <> T.pack socketPath\n      hFlush stdout\n\n      forever $ do\n        (conn, _peer) <- accept sock\n        void $ forkIO $ handleConnection lspSession conn `finally` close conn\n\n", "criteria": "CRITERIA_0397", "selected": "SELECTED_0397", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "runServer", "range": {"end": {"character": 9, "line": 52}, "start": {"character": 0, "line": 52}}}
{"example_id": "0398", "variation": "positive_semantic", "code": "runServer config = do\n  let tidepoolDir = config.projectDir </> \".tidepool\"\n  let socketPath = tidepoolDir </> \"control.sock\"\n\n  -- Setup .tidepool directory\n  createDirectoryIfMissing True tidepoolDir\n  TIO.putStrLn $ \"Created .tidepool directory at \" <> T.pack tidepoolDir\n  hFlush stdout\n\n  -- Clean up stale socket\n  staleExists <- doesFileExist socketPath\n  when staleExists $ do\n    TIO.putStrLn \"Removing stale socket file...\"\n    removeFile socketPath\n\n  TIO.putStrLn $ \"Starting LSP session for project: \" <> T.pack config.projectDir\n  hFlush stdout\n\n  -- Start LSP session and run server\n  withLSPSession config.projectDir $ \\lspSession -> do\n    TIO.putStrLn \"LSP session initialized\"\n    hFlush stdout\n\n    bracket (setupSocket socketPath) (closeSocket socketPath) $ \\sock -> do\n      TIO.putStrLn $ \"Control server listening on \" <> T.pack socketPath\n      hFlush stdout\n\n      forever $ do\n        (conn, _peer) <- accept sock\n        void $ forkIO $ handleConnection lspSession conn `finally` close conn\n\n", "criteria": "CRITERIA_0398", "selected": "SELECTED_0398", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "runServer", "range": {"end": {"character": 9, "line": 52}, "start": {"character": 0, "line": 52}}}
{"example_id": "0399", "variation": "negative_1", "code": "runServer config = do\n  let tidepoolDir = config.projectDir </> \".tidepool\"\n  let socketPath = tidepoolDir </> \"control.sock\"\n\n  -- Setup .tidepool directory\n  createDirectoryIfMissing True tidepoolDir\n  TIO.putStrLn $ \"Created .tidepool directory at \" <> T.pack tidepoolDir\n  hFlush stdout\n\n  -- Clean up stale socket\n  staleExists <- doesFileExist socketPath\n  when staleExists $ do\n    TIO.putStrLn \"Removing stale socket file...\"\n    removeFile socketPath\n\n  TIO.putStrLn $ \"Starting LSP session for project: \" <> T.pack config.projectDir\n  hFlush stdout\n\n  -- Start LSP session and run server\n  withLSPSession config.projectDir $ \\lspSession -> do\n    TIO.putStrLn \"LSP session initialized\"\n    hFlush stdout\n\n    bracket (setupSocket socketPath) (closeSocket socketPath) $ \\sock -> do\n      TIO.putStrLn $ \"Control server listening on \" <> T.pack socketPath\n      hFlush stdout\n\n      forever $ do\n        (conn, _peer) <- accept sock\n        void $ forkIO $ handleConnection lspSession conn `finally` close conn\n\n", "criteria": "CRITERIA_0399", "selected": "SELECTED_0399", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "runServer", "range": {"end": {"character": 9, "line": 52}, "start": {"character": 0, "line": 52}}}
{"example_id": "0400", "variation": "negative_2", "code": "runServer config = do\n  let tidepoolDir = config.projectDir </> \".tidepool\"\n  let socketPath = tidepoolDir </> \"control.sock\"\n\n  -- Setup .tidepool directory\n  createDirectoryIfMissing True tidepoolDir\n  TIO.putStrLn $ \"Created .tidepool directory at \" <> T.pack tidepoolDir\n  hFlush stdout\n\n  -- Clean up stale socket\n  staleExists <- doesFileExist socketPath\n  when staleExists $ do\n    TIO.putStrLn \"Removing stale socket file...\"\n    removeFile socketPath\n\n  TIO.putStrLn $ \"Starting LSP session for project: \" <> T.pack config.projectDir\n  hFlush stdout\n\n  -- Start LSP session and run server\n  withLSPSession config.projectDir $ \\lspSession -> do\n    TIO.putStrLn \"LSP session initialized\"\n    hFlush stdout\n\n    bracket (setupSocket socketPath) (closeSocket socketPath) $ \\sock -> do\n      TIO.putStrLn $ \"Control server listening on \" <> T.pack socketPath\n      hFlush stdout\n\n      forever $ do\n        (conn, _peer) <- accept sock\n        void $ forkIO $ handleConnection lspSession conn `finally` close conn\n\n", "criteria": "CRITERIA_0400", "selected": "SELECTED_0400", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "runServer", "range": {"end": {"character": 9, "line": 52}, "start": {"character": 0, "line": 52}}}
{"example_id": "0401", "variation": "positive_structure", "code": "handleHook input = do\n  TIO.putStrLn $ \"  session=\" <> input.sessionId\n  TIO.putStrLn $ \"  cwd=\" <> input.cwd\n  hFlush stdout\n\n  pure $ hookSuccess $ makeResponse input.hookEventName input\n\n-- | Create appropriate response based on hook type.\n", "criteria": "CRITERIA_0401", "selected": "SELECTED_0401", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/Hook.hs", "name": "handleHook", "range": {"end": {"character": 10, "line": 19}, "start": {"character": 0, "line": 19}}}
{"example_id": "0402", "variation": "positive_semantic", "code": "handleHook input = do\n  TIO.putStrLn $ \"  session=\" <> input.sessionId\n  TIO.putStrLn $ \"  cwd=\" <> input.cwd\n  hFlush stdout\n\n  pure $ hookSuccess $ makeResponse input.hookEventName input\n\n-- | Create appropriate response based on hook type.\n", "criteria": "CRITERIA_0402", "selected": "SELECTED_0402", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/Hook.hs", "name": "handleHook", "range": {"end": {"character": 10, "line": 19}, "start": {"character": 0, "line": 19}}}
{"example_id": "0403", "variation": "negative_1", "code": "handleHook input = do\n  TIO.putStrLn $ \"  session=\" <> input.sessionId\n  TIO.putStrLn $ \"  cwd=\" <> input.cwd\n  hFlush stdout\n\n  pure $ hookSuccess $ makeResponse input.hookEventName input\n\n-- | Create appropriate response based on hook type.\n", "criteria": "CRITERIA_0403", "selected": "SELECTED_0403", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/Hook.hs", "name": "handleHook", "range": {"end": {"character": 10, "line": 19}, "start": {"character": 0, "line": 19}}}
{"example_id": "0404", "variation": "negative_2", "code": "handleHook input = do\n  TIO.putStrLn $ \"  session=\" <> input.sessionId\n  TIO.putStrLn $ \"  cwd=\" <> input.cwd\n  hFlush stdout\n\n  pure $ hookSuccess $ makeResponse input.hookEventName input\n\n-- | Create appropriate response based on hook type.\n", "criteria": "CRITERIA_0404", "selected": "SELECTED_0404", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/Hook.hs", "name": "handleHook", "range": {"end": {"character": 10, "line": 19}, "start": {"character": 0, "line": 19}}}
{"example_id": "0405", "variation": "positive_structure", "code": "handleMcpTool lspSession reqId toolName args = do\n  TIO.putStrLn $ \"  tool=\" <> toolName\n  hFlush stdout\n\n  case toolName of\n    \"teach\" -> handleTeachTool lspSession reqId args\n    _ -> do\n      TIO.putStrLn $ \"  (unknown tool)\"\n      hFlush stdout\n      pure $ mcpToolError reqId $\n        \"Tool not found: \" <> toolName <> \". Available tools: teach\"\n\n\n-- | Handle the teach tool.\n--\n-- Generates teaching documents from LSP + Gemma that explain a topic\n-- in prerequisite order.\n", "criteria": "CRITERIA_0405", "selected": "SELECTED_0405", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/MCP.hs", "name": "handleMcpTool", "range": {"end": {"character": 13, "line": 27}, "start": {"character": 0, "line": 27}}}
{"example_id": "0406", "variation": "positive_semantic", "code": "handleMcpTool lspSession reqId toolName args = do\n  TIO.putStrLn $ \"  tool=\" <> toolName\n  hFlush stdout\n\n  case toolName of\n    \"teach\" -> handleTeachTool lspSession reqId args\n    _ -> do\n      TIO.putStrLn $ \"  (unknown tool)\"\n      hFlush stdout\n      pure $ mcpToolError reqId $\n        \"Tool not found: \" <> toolName <> \". Available tools: teach\"\n\n\n-- | Handle the teach tool.\n--\n-- Generates teaching documents from LSP + Gemma that explain a topic\n-- in prerequisite order.\n", "criteria": "CRITERIA_0406", "selected": "SELECTED_0406", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/MCP.hs", "name": "handleMcpTool", "range": {"end": {"character": 13, "line": 27}, "start": {"character": 0, "line": 27}}}
{"example_id": "0407", "variation": "negative_1", "code": "handleMcpTool lspSession reqId toolName args = do\n  TIO.putStrLn $ \"  tool=\" <> toolName\n  hFlush stdout\n\n  case toolName of\n    \"teach\" -> handleTeachTool lspSession reqId args\n    _ -> do\n      TIO.putStrLn $ \"  (unknown tool)\"\n      hFlush stdout\n      pure $ mcpToolError reqId $\n        \"Tool not found: \" <> toolName <> \". Available tools: teach\"\n\n\n-- | Handle the teach tool.\n--\n-- Generates teaching documents from LSP + Gemma that explain a topic\n-- in prerequisite order.\n", "criteria": "CRITERIA_0407", "selected": "SELECTED_0407", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/MCP.hs", "name": "handleMcpTool", "range": {"end": {"character": 13, "line": 27}, "start": {"character": 0, "line": 27}}}
{"example_id": "0408", "variation": "negative_2", "code": "handleMcpTool lspSession reqId toolName args = do\n  TIO.putStrLn $ \"  tool=\" <> toolName\n  hFlush stdout\n\n  case toolName of\n    \"teach\" -> handleTeachTool lspSession reqId args\n    _ -> do\n      TIO.putStrLn $ \"  (unknown tool)\"\n      hFlush stdout\n      pure $ mcpToolError reqId $\n        \"Tool not found: \" <> toolName <> \". Available tools: teach\"\n\n\n-- | Handle the teach tool.\n--\n-- Generates teaching documents from LSP + Gemma that explain a topic\n-- in prerequisite order.\n", "criteria": "CRITERIA_0408", "selected": "SELECTED_0408", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/MCP.hs", "name": "handleMcpTool", "range": {"end": {"character": 13, "line": 27}, "start": {"character": 0, "line": 27}}}
{"example_id": "0409", "variation": "positive_structure", "code": "handleTeachTool lspSession reqId args = do\n  case fromJSON args of\n    Error err -> do\n      TIO.putStrLn $ \"  parse error: \" <> T.pack err\n      hFlush stdout\n      pure $ mcpToolError reqId $ \"Invalid teach arguments: \" <> T.pack err\n\n    Success query -> do\n      TIO.putStrLn $ \"  topic=\" <> tqTopic query\n      TIO.putStrLn $ \"  seeds=\" <> T.intercalate \", \" (tqSeeds query)\n      TIO.putStrLn $ \"  budget=\" <> T.pack (show $ tqBudget query)\n      hFlush stdout\n\n      -- Require GEMMA_ENDPOINT\n      maybeEndpoint <- lookupEnv \"GEMMA_ENDPOINT\"\n      case maybeEndpoint of\n        Nothing -> do\n          TIO.putStrLn \"  error: GEMMA_ENDPOINT not set\"\n          hFlush stdout\n          pure $ mcpToolError reqId \"GEMMA_ENDPOINT environment variable not set\"\n\n        Just ep -> do\n          TIO.putStrLn $ \"  gemma=\" <> T.pack ep\n          hFlush stdout\n\n          resultOrErr <- try $ runM $ runLog Debug $ runTeachGemmaHTTP (T.pack ep) $ runLSP lspSession $\n            teach defaultTeachConfig query\n\n          case resultOrErr of\n            Left (e :: SomeException) -> do\n              TIO.putStrLn $ \"  error: \" <> T.pack (show e)\n", "criteria": "CRITERIA_0409", "selected": "SELECTED_0409", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/MCP.hs", "name": "handleTeachTool", "range": {"end": {"character": 15, "line": 45}, "start": {"character": 0, "line": 45}}}
{"example_id": "0410", "variation": "positive_semantic", "code": "handleTeachTool lspSession reqId args = do\n  case fromJSON args of\n    Error err -> do\n      TIO.putStrLn $ \"  parse error: \" <> T.pack err\n      hFlush stdout\n      pure $ mcpToolError reqId $ \"Invalid teach arguments: \" <> T.pack err\n\n    Success query -> do\n      TIO.putStrLn $ \"  topic=\" <> tqTopic query\n      TIO.putStrLn $ \"  seeds=\" <> T.intercalate \", \" (tqSeeds query)\n      TIO.putStrLn $ \"  budget=\" <> T.pack (show $ tqBudget query)\n      hFlush stdout\n\n      -- Require GEMMA_ENDPOINT\n      maybeEndpoint <- lookupEnv \"GEMMA_ENDPOINT\"\n      case maybeEndpoint of\n        Nothing -> do\n          TIO.putStrLn \"  error: GEMMA_ENDPOINT not set\"\n          hFlush stdout\n          pure $ mcpToolError reqId \"GEMMA_ENDPOINT environment variable not set\"\n\n        Just ep -> do\n          TIO.putStrLn $ \"  gemma=\" <> T.pack ep\n          hFlush stdout\n\n          resultOrErr <- try $ runM $ runLog Debug $ runTeachGemmaHTTP (T.pack ep) $ runLSP lspSession $\n            teach defaultTeachConfig query\n\n          case resultOrErr of\n            Left (e :: SomeException) -> do\n              TIO.putStrLn $ \"  error: \" <> T.pack (show e)\n", "criteria": "CRITERIA_0410", "selected": "SELECTED_0410", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/MCP.hs", "name": "handleTeachTool", "range": {"end": {"character": 15, "line": 45}, "start": {"character": 0, "line": 45}}}
{"example_id": "0411", "variation": "negative_1", "code": "handleTeachTool lspSession reqId args = do\n  case fromJSON args of\n    Error err -> do\n      TIO.putStrLn $ \"  parse error: \" <> T.pack err\n      hFlush stdout\n      pure $ mcpToolError reqId $ \"Invalid teach arguments: \" <> T.pack err\n\n    Success query -> do\n      TIO.putStrLn $ \"  topic=\" <> tqTopic query\n      TIO.putStrLn $ \"  seeds=\" <> T.intercalate \", \" (tqSeeds query)\n      TIO.putStrLn $ \"  budget=\" <> T.pack (show $ tqBudget query)\n      hFlush stdout\n\n      -- Require GEMMA_ENDPOINT\n      maybeEndpoint <- lookupEnv \"GEMMA_ENDPOINT\"\n      case maybeEndpoint of\n        Nothing -> do\n          TIO.putStrLn \"  error: GEMMA_ENDPOINT not set\"\n          hFlush stdout\n          pure $ mcpToolError reqId \"GEMMA_ENDPOINT environment variable not set\"\n\n        Just ep -> do\n          TIO.putStrLn $ \"  gemma=\" <> T.pack ep\n          hFlush stdout\n\n          resultOrErr <- try $ runM $ runLog Debug $ runTeachGemmaHTTP (T.pack ep) $ runLSP lspSession $\n            teach defaultTeachConfig query\n\n          case resultOrErr of\n            Left (e :: SomeException) -> do\n              TIO.putStrLn $ \"  error: \" <> T.pack (show e)\n", "criteria": "CRITERIA_0411", "selected": "SELECTED_0411", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/MCP.hs", "name": "handleTeachTool", "range": {"end": {"character": 15, "line": 45}, "start": {"character": 0, "line": 45}}}
{"example_id": "0412", "variation": "negative_2", "code": "handleTeachTool lspSession reqId args = do\n  case fromJSON args of\n    Error err -> do\n      TIO.putStrLn $ \"  parse error: \" <> T.pack err\n      hFlush stdout\n      pure $ mcpToolError reqId $ \"Invalid teach arguments: \" <> T.pack err\n\n    Success query -> do\n      TIO.putStrLn $ \"  topic=\" <> tqTopic query\n      TIO.putStrLn $ \"  seeds=\" <> T.intercalate \", \" (tqSeeds query)\n      TIO.putStrLn $ \"  budget=\" <> T.pack (show $ tqBudget query)\n      hFlush stdout\n\n      -- Require GEMMA_ENDPOINT\n      maybeEndpoint <- lookupEnv \"GEMMA_ENDPOINT\"\n      case maybeEndpoint of\n        Nothing -> do\n          TIO.putStrLn \"  error: GEMMA_ENDPOINT not set\"\n          hFlush stdout\n          pure $ mcpToolError reqId \"GEMMA_ENDPOINT environment variable not set\"\n\n        Just ep -> do\n          TIO.putStrLn $ \"  gemma=\" <> T.pack ep\n          hFlush stdout\n\n          resultOrErr <- try $ runM $ runLog Debug $ runTeachGemmaHTTP (T.pack ep) $ runLSP lspSession $\n            teach defaultTeachConfig query\n\n          case resultOrErr of\n            Left (e :: SomeException) -> do\n              TIO.putStrLn $ \"  error: \" <> T.pack (show e)\n", "criteria": "CRITERIA_0412", "selected": "SELECTED_0412", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler/MCP.hs", "name": "handleTeachTool", "range": {"end": {"character": 15, "line": 45}, "start": {"character": 0, "line": 45}}}
{"example_id": "0413", "variation": "positive_structure", "code": "handleMessage lspSession = \\case\n  HookEvent input -> handleHook input\n  McpToolCall reqId name args -> handleMcpTool lspSession reqId name args\n", "criteria": "CRITERIA_0413", "selected": "SELECTED_0413", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler.hs", "name": "handleMessage", "range": {"end": {"character": 13, "line": 12}, "start": {"character": 0, "line": 12}}}
{"example_id": "0414", "variation": "positive_semantic", "code": "handleMessage lspSession = \\case\n  HookEvent input -> handleHook input\n  McpToolCall reqId name args -> handleMcpTool lspSession reqId name args\n", "criteria": "CRITERIA_0414", "selected": "SELECTED_0414", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler.hs", "name": "handleMessage", "range": {"end": {"character": 13, "line": 12}, "start": {"character": 0, "line": 12}}}
{"example_id": "0415", "variation": "negative_1", "code": "handleMessage lspSession = \\case\n  HookEvent input -> handleHook input\n  McpToolCall reqId name args -> handleMcpTool lspSession reqId name args\n", "criteria": "CRITERIA_0415", "selected": "SELECTED_0415", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler.hs", "name": "handleMessage", "range": {"end": {"character": 13, "line": 12}, "start": {"character": 0, "line": 12}}}
{"example_id": "0416", "variation": "negative_2", "code": "handleMessage lspSession = \\case\n  HookEvent input -> handleHook input\n  McpToolCall reqId name args -> handleMcpTool lspSession reqId name args\n", "criteria": "CRITERIA_0416", "selected": "SELECTED_0416", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Handler.hs", "name": "handleMessage", "range": {"end": {"character": 13, "line": 12}, "start": {"character": 0, "line": 12}}}
{"example_id": "0417", "variation": "positive_structure", "code": "handleConnection lspSession conn = do\n  TIO.putStrLn \"Connection received\"\n  hFlush stdout\n\n  -- FIXME: Add socket timeout (30s) to match Rust client timeout.\n  -- Currently server can block indefinitely on slow clients.\n  -- Use System.Timeout.timeout (30 * 1000000) around the handler.\n\n  (do\n    -- Read until newline (NDJSON framing)\n    -- Now covered by exception handler\n    msgBytes <- readUntilNewline conn\n\n    case eitherDecodeStrict msgBytes of\n      Left err -> do\n        TIO.putStrLn $ \"Parse error: \" <> T.pack err\n        -- Send error response\n        let response = hookError $ T.pack $ \"JSON parse error: \" <> err\n        sendResponse conn response\n\n      Right msg -> do\n        logMessage msg\n        response <- handleMessage lspSession msg\n        logResponse response\n        sendResponse conn response\n    )\n  `catch` \\(e :: SomeException) -> do\n    TIO.putStrLn $ \"Connection error: \" <> T.pack (show e)\n    -- Send error response to client instead of leaving them hanging\n    sendResponse conn $ hookError $ \"Connection error: \" <> T.pack (show e)\n\n", "criteria": "CRITERIA_0417", "selected": "SELECTED_0417", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "handleConnection", "range": {"end": {"character": 16, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0418", "variation": "positive_semantic", "code": "handleConnection lspSession conn = do\n  TIO.putStrLn \"Connection received\"\n  hFlush stdout\n\n  -- FIXME: Add socket timeout (30s) to match Rust client timeout.\n  -- Currently server can block indefinitely on slow clients.\n  -- Use System.Timeout.timeout (30 * 1000000) around the handler.\n\n  (do\n    -- Read until newline (NDJSON framing)\n    -- Now covered by exception handler\n    msgBytes <- readUntilNewline conn\n\n    case eitherDecodeStrict msgBytes of\n      Left err -> do\n        TIO.putStrLn $ \"Parse error: \" <> T.pack err\n        -- Send error response\n        let response = hookError $ T.pack $ \"JSON parse error: \" <> err\n        sendResponse conn response\n\n      Right msg -> do\n        logMessage msg\n        response <- handleMessage lspSession msg\n        logResponse response\n        sendResponse conn response\n    )\n  `catch` \\(e :: SomeException) -> do\n    TIO.putStrLn $ \"Connection error: \" <> T.pack (show e)\n    -- Send error response to client instead of leaving them hanging\n    sendResponse conn $ hookError $ \"Connection error: \" <> T.pack (show e)\n\n", "criteria": "CRITERIA_0418", "selected": "SELECTED_0418", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "handleConnection", "range": {"end": {"character": 16, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0419", "variation": "negative_1", "code": "handleConnection lspSession conn = do\n  TIO.putStrLn \"Connection received\"\n  hFlush stdout\n\n  -- FIXME: Add socket timeout (30s) to match Rust client timeout.\n  -- Currently server can block indefinitely on slow clients.\n  -- Use System.Timeout.timeout (30 * 1000000) around the handler.\n\n  (do\n    -- Read until newline (NDJSON framing)\n    -- Now covered by exception handler\n    msgBytes <- readUntilNewline conn\n\n    case eitherDecodeStrict msgBytes of\n      Left err -> do\n        TIO.putStrLn $ \"Parse error: \" <> T.pack err\n        -- Send error response\n        let response = hookError $ T.pack $ \"JSON parse error: \" <> err\n        sendResponse conn response\n\n      Right msg -> do\n        logMessage msg\n        response <- handleMessage lspSession msg\n        logResponse response\n        sendResponse conn response\n    )\n  `catch` \\(e :: SomeException) -> do\n    TIO.putStrLn $ \"Connection error: \" <> T.pack (show e)\n    -- Send error response to client instead of leaving them hanging\n    sendResponse conn $ hookError $ \"Connection error: \" <> T.pack (show e)\n\n", "criteria": "CRITERIA_0419", "selected": "SELECTED_0419", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "handleConnection", "range": {"end": {"character": 16, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0420", "variation": "negative_2", "code": "handleConnection lspSession conn = do\n  TIO.putStrLn \"Connection received\"\n  hFlush stdout\n\n  -- FIXME: Add socket timeout (30s) to match Rust client timeout.\n  -- Currently server can block indefinitely on slow clients.\n  -- Use System.Timeout.timeout (30 * 1000000) around the handler.\n\n  (do\n    -- Read until newline (NDJSON framing)\n    -- Now covered by exception handler\n    msgBytes <- readUntilNewline conn\n\n    case eitherDecodeStrict msgBytes of\n      Left err -> do\n        TIO.putStrLn $ \"Parse error: \" <> T.pack err\n        -- Send error response\n        let response = hookError $ T.pack $ \"JSON parse error: \" <> err\n        sendResponse conn response\n\n      Right msg -> do\n        logMessage msg\n        response <- handleMessage lspSession msg\n        logResponse response\n        sendResponse conn response\n    )\n  `catch` \\(e :: SomeException) -> do\n    TIO.putStrLn $ \"Connection error: \" <> T.pack (show e)\n    -- Send error response to client instead of leaving them hanging\n    sendResponse conn $ hookError $ \"Connection error: \" <> T.pack (show e)\n\n", "criteria": "CRITERIA_0420", "selected": "SELECTED_0420", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "handleConnection", "range": {"end": {"character": 16, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0421", "variation": "positive_structure", "code": "mkLLMEnv config = do\n  manager <- newManager tlsManagerSettings\n  pure LLMEnv { leConfig = config, leManager = manager }\n\n\n", "criteria": "CRITERIA_0421", "selected": "SELECTED_0421", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "mkLLMEnv", "range": {"end": {"character": 8, "line": 145}, "start": {"character": 0, "line": 145}}}
{"example_id": "0422", "variation": "positive_semantic", "code": "mkLLMEnv config = do\n  manager <- newManager tlsManagerSettings\n  pure LLMEnv { leConfig = config, leManager = manager }\n\n\n", "criteria": "CRITERIA_0422", "selected": "SELECTED_0422", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "mkLLMEnv", "range": {"end": {"character": 8, "line": 145}, "start": {"character": 0, "line": 145}}}
{"example_id": "0423", "variation": "negative_1", "code": "mkLLMEnv config = do\n  manager <- newManager tlsManagerSettings\n  pure LLMEnv { leConfig = config, leManager = manager }\n\n\n", "criteria": "CRITERIA_0423", "selected": "SELECTED_0423", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "mkLLMEnv", "range": {"end": {"character": 8, "line": 145}, "start": {"character": 0, "line": 145}}}
{"example_id": "0424", "variation": "negative_2", "code": "mkLLMEnv config = do\n  manager <- newManager tlsManagerSettings\n  pure LLMEnv { leConfig = config, leManager = manager }\n\n\n", "criteria": "CRITERIA_0424", "selected": "SELECTED_0424", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "mkLLMEnv", "range": {"end": {"character": 8, "line": 145}, "start": {"character": 0, "line": 145}}}
{"example_id": "0425", "variation": "positive_structure", "code": "mkMemorySnapshot scopes = MemorySnapshot\n  { snapVersion = currentSnapshotVersion\n  , snapScopes = scopes\n  }\n\n-- | Pattern for read-only access to snapshot scopes.\n--\n-- Use this pattern to extract scopes without exposing the version field:\n--\n-- @\n-- case snapshot of\n--   MemorySnapshotScopes scopes -> Map.lookup \"myNode\" scopes\n-- @\n", "criteria": "CRITERIA_0425", "selected": "SELECTED_0425", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "mkMemorySnapshot", "range": {"end": {"character": 16, "line": 313}, "start": {"character": 0, "line": 313}}}
{"example_id": "0426", "variation": "positive_semantic", "code": "mkMemorySnapshot scopes = MemorySnapshot\n  { snapVersion = currentSnapshotVersion\n  , snapScopes = scopes\n  }\n\n-- | Pattern for read-only access to snapshot scopes.\n--\n-- Use this pattern to extract scopes without exposing the version field:\n--\n-- @\n-- case snapshot of\n--   MemorySnapshotScopes scopes -> Map.lookup \"myNode\" scopes\n-- @\n", "criteria": "CRITERIA_0426", "selected": "SELECTED_0426", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "mkMemorySnapshot", "range": {"end": {"character": 16, "line": 313}, "start": {"character": 0, "line": 313}}}
{"example_id": "0427", "variation": "negative_1", "code": "mkMemorySnapshot scopes = MemorySnapshot\n  { snapVersion = currentSnapshotVersion\n  , snapScopes = scopes\n  }\n\n-- | Pattern for read-only access to snapshot scopes.\n--\n-- Use this pattern to extract scopes without exposing the version field:\n--\n-- @\n-- case snapshot of\n--   MemorySnapshotScopes scopes -> Map.lookup \"myNode\" scopes\n-- @\n", "criteria": "CRITERIA_0427", "selected": "SELECTED_0427", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "mkMemorySnapshot", "range": {"end": {"character": 16, "line": 313}, "start": {"character": 0, "line": 313}}}
{"example_id": "0428", "variation": "negative_2", "code": "mkMemorySnapshot scopes = MemorySnapshot\n  { snapVersion = currentSnapshotVersion\n  , snapScopes = scopes\n  }\n\n-- | Pattern for read-only access to snapshot scopes.\n--\n-- Use this pattern to extract scopes without exposing the version field:\n--\n-- @\n-- case snapshot of\n--   MemorySnapshotScopes scopes -> Map.lookup \"myNode\" scopes\n-- @\n", "criteria": "CRITERIA_0428", "selected": "SELECTED_0428", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "mkMemorySnapshot", "range": {"end": {"character": 16, "line": 313}, "start": {"character": 0, "line": 313}}}
{"example_id": "0429", "variation": "positive_structure", "code": "mkEdgeContext loc hover snippet depth parent =\n  let edgeType = inferEdgeType hover snippet\n  in EdgeContext\n    { ecEdgeType    = edgeType\n    , ecLocation    = loc\n    , ecHover       = hover\n    , ecSnippet     = snippet\n    , ecDepth       = depth\n    , ecParent      = parent\n    -- Extract type-specific fields\n    , ecTypeName    = extractTypeName edgeType hover\n    , ecFunctionSig = extractFunctionSig edgeType hover\n    , ecPatterns    = extractPatterns edgeType snippet\n    , ecConstraints = extractConstraints edgeType hover\n    }\n\n-- | Extract type name from hover for TypeReference edges.\n", "criteria": "CRITERIA_0429", "selected": "SELECTED_0429", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "mkEdgeContext", "range": {"end": {"character": 13, "line": 137}, "start": {"character": 0, "line": 137}}}
{"example_id": "0430", "variation": "positive_semantic", "code": "mkEdgeContext loc hover snippet depth parent =\n  let edgeType = inferEdgeType hover snippet\n  in EdgeContext\n    { ecEdgeType    = edgeType\n    , ecLocation    = loc\n    , ecHover       = hover\n    , ecSnippet     = snippet\n    , ecDepth       = depth\n    , ecParent      = parent\n    -- Extract type-specific fields\n    , ecTypeName    = extractTypeName edgeType hover\n    , ecFunctionSig = extractFunctionSig edgeType hover\n    , ecPatterns    = extractPatterns edgeType snippet\n    , ecConstraints = extractConstraints edgeType hover\n    }\n\n-- | Extract type name from hover for TypeReference edges.\n", "criteria": "CRITERIA_0430", "selected": "SELECTED_0430", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "mkEdgeContext", "range": {"end": {"character": 13, "line": 137}, "start": {"character": 0, "line": 137}}}
{"example_id": "0431", "variation": "negative_1", "code": "mkEdgeContext loc hover snippet depth parent =\n  let edgeType = inferEdgeType hover snippet\n  in EdgeContext\n    { ecEdgeType    = edgeType\n    , ecLocation    = loc\n    , ecHover       = hover\n    , ecSnippet     = snippet\n    , ecDepth       = depth\n    , ecParent      = parent\n    -- Extract type-specific fields\n    , ecTypeName    = extractTypeName edgeType hover\n    , ecFunctionSig = extractFunctionSig edgeType hover\n    , ecPatterns    = extractPatterns edgeType snippet\n    , ecConstraints = extractConstraints edgeType hover\n    }\n\n-- | Extract type name from hover for TypeReference edges.\n", "criteria": "CRITERIA_0431", "selected": "SELECTED_0431", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "mkEdgeContext", "range": {"end": {"character": 13, "line": 137}, "start": {"character": 0, "line": 137}}}
{"example_id": "0432", "variation": "negative_2", "code": "mkEdgeContext loc hover snippet depth parent =\n  let edgeType = inferEdgeType hover snippet\n  in EdgeContext\n    { ecEdgeType    = edgeType\n    , ecLocation    = loc\n    , ecHover       = hover\n    , ecSnippet     = snippet\n    , ecDepth       = depth\n    , ecParent      = parent\n    -- Extract type-specific fields\n    , ecTypeName    = extractTypeName edgeType hover\n    , ecFunctionSig = extractFunctionSig edgeType hover\n    , ecPatterns    = extractPatterns edgeType snippet\n    , ecConstraints = extractConstraints edgeType hover\n    }\n\n-- | Extract type name from hover for TypeReference edges.\n", "criteria": "CRITERIA_0432", "selected": "SELECTED_0432", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "mkEdgeContext", "range": {"end": {"character": 13, "line": 137}, "start": {"character": 0, "line": 137}}}
{"example_id": "0433", "variation": "positive_structure", "code": "mkScoringContext query edge = ScoringContext\n  { scQuery       = query\n  , scEdgeType    = edgeTypeToText (ecEdgeType edge)\n  , scLocation    = ecLocation edge\n  , scHover       = ecHover edge\n  , scSnippet     = ecSnippet edge\n  , scDepth       = ecDepth edge\n  , scTypeInfo    = ecTypeName edge\n  , scPatterns    = ecPatterns edge\n  , scConstraints = ecConstraints edge\n  }\n\n\n-- | Render the Turn 2 prompt for FunctionGemma.\n--\n-- This is the user request that asks the model to rate the edge.\n-- Turn 1 (function declaration) is prepended by the interpreter.\n", "criteria": "CRITERIA_0433", "selected": "SELECTED_0433", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "mkScoringContext", "range": {"end": {"character": 16, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0434", "variation": "positive_semantic", "code": "mkScoringContext query edge = ScoringContext\n  { scQuery       = query\n  , scEdgeType    = edgeTypeToText (ecEdgeType edge)\n  , scLocation    = ecLocation edge\n  , scHover       = ecHover edge\n  , scSnippet     = ecSnippet edge\n  , scDepth       = ecDepth edge\n  , scTypeInfo    = ecTypeName edge\n  , scPatterns    = ecPatterns edge\n  , scConstraints = ecConstraints edge\n  }\n\n\n-- | Render the Turn 2 prompt for FunctionGemma.\n--\n-- This is the user request that asks the model to rate the edge.\n-- Turn 1 (function declaration) is prepended by the interpreter.\n", "criteria": "CRITERIA_0434", "selected": "SELECTED_0434", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "mkScoringContext", "range": {"end": {"character": 16, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0435", "variation": "negative_1", "code": "mkScoringContext query edge = ScoringContext\n  { scQuery       = query\n  , scEdgeType    = edgeTypeToText (ecEdgeType edge)\n  , scLocation    = ecLocation edge\n  , scHover       = ecHover edge\n  , scSnippet     = ecSnippet edge\n  , scDepth       = ecDepth edge\n  , scTypeInfo    = ecTypeName edge\n  , scPatterns    = ecPatterns edge\n  , scConstraints = ecConstraints edge\n  }\n\n\n-- | Render the Turn 2 prompt for FunctionGemma.\n--\n-- This is the user request that asks the model to rate the edge.\n-- Turn 1 (function declaration) is prepended by the interpreter.\n", "criteria": "CRITERIA_0435", "selected": "SELECTED_0435", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "mkScoringContext", "range": {"end": {"character": 16, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0436", "variation": "negative_2", "code": "mkScoringContext query edge = ScoringContext\n  { scQuery       = query\n  , scEdgeType    = edgeTypeToText (ecEdgeType edge)\n  , scLocation    = ecLocation edge\n  , scHover       = ecHover edge\n  , scSnippet     = ecSnippet edge\n  , scDepth       = ecDepth edge\n  , scTypeInfo    = ecTypeName edge\n  , scPatterns    = ecPatterns edge\n  , scConstraints = ecConstraints edge\n  }\n\n\n-- | Render the Turn 2 prompt for FunctionGemma.\n--\n-- This is the user request that asks the model to rate the edge.\n-- Turn 1 (function declaration) is prepended by the interpreter.\n", "criteria": "CRITERIA_0436", "selected": "SELECTED_0436", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "mkScoringContext", "range": {"end": {"character": 16, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0437", "variation": "positive_structure", "code": "toolUseToResultId (ToolUseId t) = ToolResultId t\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- REQUEST TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | A complete Messages API request\n", "criteria": "CRITERIA_0437", "selected": "SELECTED_0437", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Anthropic/Types.hs", "name": "toolUseToResultId", "range": {"end": {"character": 17, "line": 72}, "start": {"character": 0, "line": 72}}}
{"example_id": "0438", "variation": "positive_semantic", "code": "toolUseToResultId (ToolUseId t) = ToolResultId t\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- REQUEST TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | A complete Messages API request\n", "criteria": "CRITERIA_0438", "selected": "SELECTED_0438", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Anthropic/Types.hs", "name": "toolUseToResultId", "range": {"end": {"character": 17, "line": 72}, "start": {"character": 0, "line": 72}}}
{"example_id": "0439", "variation": "negative_1", "code": "toolUseToResultId (ToolUseId t) = ToolResultId t\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- REQUEST TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | A complete Messages API request\n", "criteria": "CRITERIA_0439", "selected": "SELECTED_0439", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Anthropic/Types.hs", "name": "toolUseToResultId", "range": {"end": {"character": 17, "line": 72}, "start": {"character": 0, "line": 72}}}
{"example_id": "0440", "variation": "negative_2", "code": "toolUseToResultId (ToolUseId t) = ToolResultId t\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- REQUEST TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | A complete Messages API request\n", "criteria": "CRITERIA_0440", "selected": "SELECTED_0440", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Anthropic/Types.hs", "name": "toolUseToResultId", "range": {"end": {"character": 17, "line": 72}, "start": {"character": 0, "line": 72}}}
{"example_id": "0441", "variation": "positive_structure", "code": "toolErrorToText = \\case\n  ToolNotFound name ->\n    \"Unknown tool: \" <> name\n  ToolValidationFailed{tveToolName, tveParseError} ->\n    \"Tool '\" <> tveToolName <> \"' input validation failed: \" <> tveParseError\n  ToolExecutionFailed msg ->\n    \"Tool execution failed: \" <> msg\n\n-- | Build content blocks from text + images\n", "criteria": "CRITERIA_0441", "selected": "SELECTED_0441", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "toolErrorToText", "range": {"end": {"character": 15, "line": 370}, "start": {"character": 0, "line": 370}}}
{"example_id": "0442", "variation": "positive_semantic", "code": "toolErrorToText = \\case\n  ToolNotFound name ->\n    \"Unknown tool: \" <> name\n  ToolValidationFailed{tveToolName, tveParseError} ->\n    \"Tool '\" <> tveToolName <> \"' input validation failed: \" <> tveParseError\n  ToolExecutionFailed msg ->\n    \"Tool execution failed: \" <> msg\n\n-- | Build content blocks from text + images\n", "criteria": "CRITERIA_0442", "selected": "SELECTED_0442", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "toolErrorToText", "range": {"end": {"character": 15, "line": 370}, "start": {"character": 0, "line": 370}}}
{"example_id": "0443", "variation": "negative_1", "code": "toolErrorToText = \\case\n  ToolNotFound name ->\n    \"Unknown tool: \" <> name\n  ToolValidationFailed{tveToolName, tveParseError} ->\n    \"Tool '\" <> tveToolName <> \"' input validation failed: \" <> tveParseError\n  ToolExecutionFailed msg ->\n    \"Tool execution failed: \" <> msg\n\n-- | Build content blocks from text + images\n", "criteria": "CRITERIA_0443", "selected": "SELECTED_0443", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "toolErrorToText", "range": {"end": {"character": 15, "line": 370}, "start": {"character": 0, "line": 370}}}
{"example_id": "0444", "variation": "negative_2", "code": "toolErrorToText = \\case\n  ToolNotFound name ->\n    \"Unknown tool: \" <> name\n  ToolValidationFailed{tveToolName, tveParseError} ->\n    \"Tool '\" <> tveToolName <> \"' input validation failed: \" <> tveParseError\n  ToolExecutionFailed msg ->\n    \"Tool execution failed: \" <> msg\n\n-- | Build content blocks from text + images\n", "criteria": "CRITERIA_0444", "selected": "SELECTED_0444", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "toolErrorToText", "range": {"end": {"character": 15, "line": 370}, "start": {"character": 0, "line": 370}}}
{"example_id": "0445", "variation": "positive_structure", "code": "toolInfoToJSON ti = object\n  [ \"name\" .= ti.tiName\n  , \"description\" .= ti.tiDescription\n  , \"input_schema\" .= schemaToValue ti.tiInputSchema\n  ]\n\n-- | Convert a tool instance to 'ToolInfo'.\n--\n-- This extracts the metadata (name, description, schemas) from a tool\n-- instance using the 'ToolDef' typeclass methods.\n--\n-- @\n-- data SearchTool = SearchTool\n-- -- ... ToolDef instance ...\n--\n-- info = toolToInfo SearchTool\n-- @\n", "criteria": "CRITERIA_0445", "selected": "SELECTED_0445", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Tool.hs", "name": "toolInfoToJSON", "range": {"end": {"character": 14, "line": 231}, "start": {"character": 0, "line": 231}}}
{"example_id": "0446", "variation": "positive_semantic", "code": "toolInfoToJSON ti = object\n  [ \"name\" .= ti.tiName\n  , \"description\" .= ti.tiDescription\n  , \"input_schema\" .= schemaToValue ti.tiInputSchema\n  ]\n\n-- | Convert a tool instance to 'ToolInfo'.\n--\n-- This extracts the metadata (name, description, schemas) from a tool\n-- instance using the 'ToolDef' typeclass methods.\n--\n-- @\n-- data SearchTool = SearchTool\n-- -- ... ToolDef instance ...\n--\n-- info = toolToInfo SearchTool\n-- @\n", "criteria": "CRITERIA_0446", "selected": "SELECTED_0446", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Tool.hs", "name": "toolInfoToJSON", "range": {"end": {"character": 14, "line": 231}, "start": {"character": 0, "line": 231}}}
{"example_id": "0447", "variation": "negative_1", "code": "toolInfoToJSON ti = object\n  [ \"name\" .= ti.tiName\n  , \"description\" .= ti.tiDescription\n  , \"input_schema\" .= schemaToValue ti.tiInputSchema\n  ]\n\n-- | Convert a tool instance to 'ToolInfo'.\n--\n-- This extracts the metadata (name, description, schemas) from a tool\n-- instance using the 'ToolDef' typeclass methods.\n--\n-- @\n-- data SearchTool = SearchTool\n-- -- ... ToolDef instance ...\n--\n-- info = toolToInfo SearchTool\n-- @\n", "criteria": "CRITERIA_0447", "selected": "SELECTED_0447", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Tool.hs", "name": "toolInfoToJSON", "range": {"end": {"character": 14, "line": 231}, "start": {"character": 0, "line": 231}}}
{"example_id": "0448", "variation": "negative_2", "code": "toolInfoToJSON ti = object\n  [ \"name\" .= ti.tiName\n  , \"description\" .= ti.tiDescription\n  , \"input_schema\" .= schemaToValue ti.tiInputSchema\n  ]\n\n-- | Convert a tool instance to 'ToolInfo'.\n--\n-- This extracts the metadata (name, description, schemas) from a tool\n-- instance using the 'ToolDef' typeclass methods.\n--\n-- @\n-- data SearchTool = SearchTool\n-- -- ... ToolDef instance ...\n--\n-- info = toolToInfo SearchTool\n-- @\n", "criteria": "CRITERIA_0448", "selected": "SELECTED_0448", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Tool.hs", "name": "toolInfoToJSON", "range": {"end": {"character": 14, "line": 231}, "start": {"character": 0, "line": 231}}}
{"example_id": "0449", "variation": "positive_structure", "code": "toolToInfo tool = ToolInfo\n  { tiName = toolName tool\n  , tiDescription = toolDescription tool\n  , tiInputSchema = jsonSchema @(ToolInput t)\n  , tiOutputSchema = jsonSchema @(ToolOutput t)\n  , tiInputType = typeRep (Proxy @(ToolInput t))\n  , tiOutputType = typeRep (Proxy @(ToolOutput t))\n  }\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TOOL VALIDATION (Parse Don't Validate)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Validate tool input JSON against a tool's schema, returning evidence.\n--\n-- This implements the \"parse don't validate\" pattern: instead of checking\n-- validity and returning Bool, we parse the input and return either an error\n-- or a 'ValidatedToolInput' that proves the data is valid.\n--\n-- = Usage\n--\n-- @\n-- case validateToolInput tool inputJson of\n--   Left err -> handleError err\n--   Right validated -> executeTool tool (getValidated validated)\n-- @\n--\n-- The 'ValidatedToolInput' wrapper proves that parsing succeeded. Downstream\n-- code receiving @ValidatedToolInput (ToolInput t)@ can trust that the JSON\n-- was valid without re-checking.\n--\n", "criteria": "CRITERIA_0449", "selected": "SELECTED_0449", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Tool.hs", "name": "toolToInfo", "range": {"end": {"character": 10, "line": 249}, "start": {"character": 0, "line": 249}}}
{"example_id": "0450", "variation": "positive_semantic", "code": "toolToInfo tool = ToolInfo\n  { tiName = toolName tool\n  , tiDescription = toolDescription tool\n  , tiInputSchema = jsonSchema @(ToolInput t)\n  , tiOutputSchema = jsonSchema @(ToolOutput t)\n  , tiInputType = typeRep (Proxy @(ToolInput t))\n  , tiOutputType = typeRep (Proxy @(ToolOutput t))\n  }\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TOOL VALIDATION (Parse Don't Validate)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Validate tool input JSON against a tool's schema, returning evidence.\n--\n-- This implements the \"parse don't validate\" pattern: instead of checking\n-- validity and returning Bool, we parse the input and return either an error\n-- or a 'ValidatedToolInput' that proves the data is valid.\n--\n-- = Usage\n--\n-- @\n-- case validateToolInput tool inputJson of\n--   Left err -> handleError err\n--   Right validated -> executeTool tool (getValidated validated)\n-- @\n--\n-- The 'ValidatedToolInput' wrapper proves that parsing succeeded. Downstream\n-- code receiving @ValidatedToolInput (ToolInput t)@ can trust that the JSON\n-- was valid without re-checking.\n--\n", "criteria": "CRITERIA_0450", "selected": "SELECTED_0450", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Tool.hs", "name": "toolToInfo", "range": {"end": {"character": 10, "line": 249}, "start": {"character": 0, "line": 249}}}
{"example_id": "0451", "variation": "negative_1", "code": "toolToInfo tool = ToolInfo\n  { tiName = toolName tool\n  , tiDescription = toolDescription tool\n  , tiInputSchema = jsonSchema @(ToolInput t)\n  , tiOutputSchema = jsonSchema @(ToolOutput t)\n  , tiInputType = typeRep (Proxy @(ToolInput t))\n  , tiOutputType = typeRep (Proxy @(ToolOutput t))\n  }\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TOOL VALIDATION (Parse Don't Validate)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Validate tool input JSON against a tool's schema, returning evidence.\n--\n-- This implements the \"parse don't validate\" pattern: instead of checking\n-- validity and returning Bool, we parse the input and return either an error\n-- or a 'ValidatedToolInput' that proves the data is valid.\n--\n-- = Usage\n--\n-- @\n-- case validateToolInput tool inputJson of\n--   Left err -> handleError err\n--   Right validated -> executeTool tool (getValidated validated)\n-- @\n--\n-- The 'ValidatedToolInput' wrapper proves that parsing succeeded. Downstream\n-- code receiving @ValidatedToolInput (ToolInput t)@ can trust that the JSON\n-- was valid without re-checking.\n--\n", "criteria": "CRITERIA_0451", "selected": "SELECTED_0451", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Tool.hs", "name": "toolToInfo", "range": {"end": {"character": 10, "line": 249}, "start": {"character": 0, "line": 249}}}
{"example_id": "0452", "variation": "negative_2", "code": "toolToInfo tool = ToolInfo\n  { tiName = toolName tool\n  , tiDescription = toolDescription tool\n  , tiInputSchema = jsonSchema @(ToolInput t)\n  , tiOutputSchema = jsonSchema @(ToolOutput t)\n  , tiInputType = typeRep (Proxy @(ToolInput t))\n  , tiOutputType = typeRep (Proxy @(ToolOutput t))\n  }\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TOOL VALIDATION (Parse Don't Validate)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Validate tool input JSON against a tool's schema, returning evidence.\n--\n-- This implements the \"parse don't validate\" pattern: instead of checking\n-- validity and returning Bool, we parse the input and return either an error\n-- or a 'ValidatedToolInput' that proves the data is valid.\n--\n-- = Usage\n--\n-- @\n-- case validateToolInput tool inputJson of\n--   Left err -> handleError err\n--   Right validated -> executeTool tool (getValidated validated)\n-- @\n--\n-- The 'ValidatedToolInput' wrapper proves that parsing succeeded. Downstream\n-- code receiving @ValidatedToolInput (ToolInput t)@ can trust that the JSON\n-- was valid without re-checking.\n--\n", "criteria": "CRITERIA_0452", "selected": "SELECTED_0452", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Tool.hs", "name": "toolToInfo", "range": {"end": {"character": 10, "line": 249}, "start": {"character": 0, "line": 249}}}
{"example_id": "0453", "variation": "positive_structure", "code": "toolDefsToAnthropic = fmap toAnthropicTool\n\n-- | Convert a collection of tools to CloudFlare AI format.\n--\n-- @\n-- tools :: [MyTool]\n-- cfTools :: [CfTool]\n-- cfTools = toolDefsToCf tools\n-- @\n", "criteria": "CRITERIA_0453", "selected": "SELECTED_0453", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Tool/Convert.hs", "name": "toolDefsToAnthropic", "range": {"end": {"character": 19, "line": 138}, "start": {"character": 0, "line": 138}}}
{"example_id": "0454", "variation": "positive_semantic", "code": "toolDefsToAnthropic = fmap toAnthropicTool\n\n-- | Convert a collection of tools to CloudFlare AI format.\n--\n-- @\n-- tools :: [MyTool]\n-- cfTools :: [CfTool]\n-- cfTools = toolDefsToCf tools\n-- @\n", "criteria": "CRITERIA_0454", "selected": "SELECTED_0454", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Tool/Convert.hs", "name": "toolDefsToAnthropic", "range": {"end": {"character": 19, "line": 138}, "start": {"character": 0, "line": 138}}}
{"example_id": "0455", "variation": "negative_1", "code": "toolDefsToAnthropic = fmap toAnthropicTool\n\n-- | Convert a collection of tools to CloudFlare AI format.\n--\n-- @\n-- tools :: [MyTool]\n-- cfTools :: [CfTool]\n-- cfTools = toolDefsToCf tools\n-- @\n", "criteria": "CRITERIA_0455", "selected": "SELECTED_0455", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Tool/Convert.hs", "name": "toolDefsToAnthropic", "range": {"end": {"character": 19, "line": 138}, "start": {"character": 0, "line": 138}}}
{"example_id": "0456", "variation": "negative_2", "code": "toolDefsToAnthropic = fmap toAnthropicTool\n\n-- | Convert a collection of tools to CloudFlare AI format.\n--\n-- @\n-- tools :: [MyTool]\n-- cfTools :: [CfTool]\n-- cfTools = toolDefsToCf tools\n-- @\n", "criteria": "CRITERIA_0456", "selected": "SELECTED_0456", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Tool/Convert.hs", "name": "toolDefsToAnthropic", "range": {"end": {"character": 19, "line": 138}, "start": {"character": 0, "line": 138}}}
{"example_id": "0457", "variation": "positive_structure", "code": "toolDefsToCf = fmap toCfTool\n", "criteria": "CRITERIA_0457", "selected": "SELECTED_0457", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Tool/Convert.hs", "name": "toolDefsToCf", "range": {"end": {"character": 12, "line": 148}, "start": {"character": 0, "line": 148}}}
{"example_id": "0458", "variation": "positive_semantic", "code": "toolDefsToCf = fmap toCfTool\n", "criteria": "CRITERIA_0458", "selected": "SELECTED_0458", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Tool/Convert.hs", "name": "toolDefsToCf", "range": {"end": {"character": 12, "line": 148}, "start": {"character": 0, "line": 148}}}
{"example_id": "0459", "variation": "negative_1", "code": "toolDefsToCf = fmap toCfTool\n", "criteria": "CRITERIA_0459", "selected": "SELECTED_0459", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Tool/Convert.hs", "name": "toolDefsToCf", "range": {"end": {"character": 12, "line": 148}, "start": {"character": 0, "line": 148}}}
{"example_id": "0460", "variation": "negative_2", "code": "toolDefsToCf = fmap toCfTool\n", "criteria": "CRITERIA_0460", "selected": "SELECTED_0460", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Tool/Convert.hs", "name": "toolDefsToCf", "range": {"end": {"character": 12, "line": 148}, "start": {"character": 0, "line": 148}}}
{"example_id": "0461", "variation": "positive_structure", "code": "toolToExport ti = ToolExport\n  { txName = ti.tiName\n  , txDescription = ti.tiDescription\n  , txInputSchema = schemaToValue ti.tiInputSchema\n  }\n\n-- | Convert ClaudeCodeInfo to ClaudeCodeExport.\n", "criteria": "CRITERIA_0461", "selected": "SELECTED_0461", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Export.hs", "name": "toolToExport", "range": {"end": {"character": 12, "line": 261}, "start": {"character": 0, "line": 261}}}
{"example_id": "0462", "variation": "positive_semantic", "code": "toolToExport ti = ToolExport\n  { txName = ti.tiName\n  , txDescription = ti.tiDescription\n  , txInputSchema = schemaToValue ti.tiInputSchema\n  }\n\n-- | Convert ClaudeCodeInfo to ClaudeCodeExport.\n", "criteria": "CRITERIA_0462", "selected": "SELECTED_0462", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Export.hs", "name": "toolToExport", "range": {"end": {"character": 12, "line": 261}, "start": {"character": 0, "line": 261}}}
{"example_id": "0463", "variation": "negative_1", "code": "toolToExport ti = ToolExport\n  { txName = ti.tiName\n  , txDescription = ti.tiDescription\n  , txInputSchema = schemaToValue ti.tiInputSchema\n  }\n\n-- | Convert ClaudeCodeInfo to ClaudeCodeExport.\n", "criteria": "CRITERIA_0463", "selected": "SELECTED_0463", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Export.hs", "name": "toolToExport", "range": {"end": {"character": 12, "line": 261}, "start": {"character": 0, "line": 261}}}
{"example_id": "0464", "variation": "negative_2", "code": "toolToExport ti = ToolExport\n  { txName = ti.tiName\n  , txDescription = ti.tiDescription\n  , txInputSchema = schemaToValue ti.tiInputSchema\n  }\n\n-- | Convert ClaudeCodeInfo to ClaudeCodeExport.\n", "criteria": "CRITERIA_0464", "selected": "SELECTED_0464", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Export.hs", "name": "toolToExport", "range": {"end": {"character": 12, "line": 261}, "start": {"character": 0, "line": 261}}}
{"example_id": "0465", "variation": "positive_structure", "code": "toMermaid = toMermaidWithConfig defaultConfig\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GRAPH-TO-MERMAID (TYPE-DRIVEN)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate Mermaid diagram directly from a graph type.\n--\n-- This is a convenience function that combines 'makeGraphInfo' with 'toMermaid'.\n-- It extracts graph structure at compile time and generates the diagram.\n--\n-- @\n-- data SupportGraph mode = SupportGraph\n--   { sgEntry    :: mode :- EntryNode Message\n--   , sgClassify :: mode :- LLMNode :@ Input Message :@ Schema Intent\n--   , sgRoute    :: mode :- LogicNode :@ Input Intent :@ UsesEffects '[Goto \"sgRefund\" Message, Goto \"sgFaq\" Message]\n--   , sgRefund   :: mode :- LLMNode :@ Input Message :@ Schema Response\n--   , sgFaq      :: mode :- LLMNode :@ Input Message :@ Schema Response\n--   , sgExit     :: mode :- ExitNode Response\n--   }\n--   deriving Generic\n--\n-- -- Generate Mermaid diagram:\n-- mermaidOutput :: Text\n-- mermaidOutput = graphToMermaid (Proxy @SupportGraph)\n-- @\n", "criteria": "CRITERIA_0465", "selected": "SELECTED_0465", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toMermaid", "range": {"end": {"character": 9, "line": 89}, "start": {"character": 0, "line": 89}}}
{"example_id": "0466", "variation": "positive_semantic", "code": "toMermaid = toMermaidWithConfig defaultConfig\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GRAPH-TO-MERMAID (TYPE-DRIVEN)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate Mermaid diagram directly from a graph type.\n--\n-- This is a convenience function that combines 'makeGraphInfo' with 'toMermaid'.\n-- It extracts graph structure at compile time and generates the diagram.\n--\n-- @\n-- data SupportGraph mode = SupportGraph\n--   { sgEntry    :: mode :- EntryNode Message\n--   , sgClassify :: mode :- LLMNode :@ Input Message :@ Schema Intent\n--   , sgRoute    :: mode :- LogicNode :@ Input Intent :@ UsesEffects '[Goto \"sgRefund\" Message, Goto \"sgFaq\" Message]\n--   , sgRefund   :: mode :- LLMNode :@ Input Message :@ Schema Response\n--   , sgFaq      :: mode :- LLMNode :@ Input Message :@ Schema Response\n--   , sgExit     :: mode :- ExitNode Response\n--   }\n--   deriving Generic\n--\n-- -- Generate Mermaid diagram:\n-- mermaidOutput :: Text\n-- mermaidOutput = graphToMermaid (Proxy @SupportGraph)\n-- @\n", "criteria": "CRITERIA_0466", "selected": "SELECTED_0466", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toMermaid", "range": {"end": {"character": 9, "line": 89}, "start": {"character": 0, "line": 89}}}
{"example_id": "0467", "variation": "negative_1", "code": "toMermaid = toMermaidWithConfig defaultConfig\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GRAPH-TO-MERMAID (TYPE-DRIVEN)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate Mermaid diagram directly from a graph type.\n--\n-- This is a convenience function that combines 'makeGraphInfo' with 'toMermaid'.\n-- It extracts graph structure at compile time and generates the diagram.\n--\n-- @\n-- data SupportGraph mode = SupportGraph\n--   { sgEntry    :: mode :- EntryNode Message\n--   , sgClassify :: mode :- LLMNode :@ Input Message :@ Schema Intent\n--   , sgRoute    :: mode :- LogicNode :@ Input Intent :@ UsesEffects '[Goto \"sgRefund\" Message, Goto \"sgFaq\" Message]\n--   , sgRefund   :: mode :- LLMNode :@ Input Message :@ Schema Response\n--   , sgFaq      :: mode :- LLMNode :@ Input Message :@ Schema Response\n--   , sgExit     :: mode :- ExitNode Response\n--   }\n--   deriving Generic\n--\n-- -- Generate Mermaid diagram:\n-- mermaidOutput :: Text\n-- mermaidOutput = graphToMermaid (Proxy @SupportGraph)\n-- @\n", "criteria": "CRITERIA_0467", "selected": "SELECTED_0467", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toMermaid", "range": {"end": {"character": 9, "line": 89}, "start": {"character": 0, "line": 89}}}
{"example_id": "0468", "variation": "negative_2", "code": "toMermaid = toMermaidWithConfig defaultConfig\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GRAPH-TO-MERMAID (TYPE-DRIVEN)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate Mermaid diagram directly from a graph type.\n--\n-- This is a convenience function that combines 'makeGraphInfo' with 'toMermaid'.\n-- It extracts graph structure at compile time and generates the diagram.\n--\n-- @\n-- data SupportGraph mode = SupportGraph\n--   { sgEntry    :: mode :- EntryNode Message\n--   , sgClassify :: mode :- LLMNode :@ Input Message :@ Schema Intent\n--   , sgRoute    :: mode :- LogicNode :@ Input Intent :@ UsesEffects '[Goto \"sgRefund\" Message, Goto \"sgFaq\" Message]\n--   , sgRefund   :: mode :- LLMNode :@ Input Message :@ Schema Response\n--   , sgFaq      :: mode :- LLMNode :@ Input Message :@ Schema Response\n--   , sgExit     :: mode :- ExitNode Response\n--   }\n--   deriving Generic\n--\n-- -- Generate Mermaid diagram:\n-- mermaidOutput :: Text\n-- mermaidOutput = graphToMermaid (Proxy @SupportGraph)\n-- @\n", "criteria": "CRITERIA_0468", "selected": "SELECTED_0468", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toMermaid", "range": {"end": {"character": 9, "line": 89}, "start": {"character": 0, "line": 89}}}
{"example_id": "0469", "variation": "positive_structure", "code": "toMermaidWithConfig config info = T.unlines $\n  [ \"flowchart \" <> config.mcDirection\n  , \"\"\n  , \"    %% EntryNode and Exit\"\n  , \"    entry((\" <> config.mcEntryLabel <> \"))\"\n  , \"    exit__((\" <> config.mcExitLabel <> \"))\"\n  , \"\"\n  ]\n  ++ nodeDeclarations config info\n  ++ [\"\"]\n  ++ groupDeclarations info\n  ++ [\"\"]\n  ++ edgeDeclarations config info\n\n-- | Generate node declarations.\n", "criteria": "CRITERIA_0469", "selected": "SELECTED_0469", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toMermaidWithConfig", "range": {"end": {"character": 19, "line": 143}, "start": {"character": 0, "line": 143}}}
{"example_id": "0470", "variation": "positive_semantic", "code": "toMermaidWithConfig config info = T.unlines $\n  [ \"flowchart \" <> config.mcDirection\n  , \"\"\n  , \"    %% EntryNode and Exit\"\n  , \"    entry((\" <> config.mcEntryLabel <> \"))\"\n  , \"    exit__((\" <> config.mcExitLabel <> \"))\"\n  , \"\"\n  ]\n  ++ nodeDeclarations config info\n  ++ [\"\"]\n  ++ groupDeclarations info\n  ++ [\"\"]\n  ++ edgeDeclarations config info\n\n-- | Generate node declarations.\n", "criteria": "CRITERIA_0470", "selected": "SELECTED_0470", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toMermaidWithConfig", "range": {"end": {"character": 19, "line": 143}, "start": {"character": 0, "line": 143}}}
{"example_id": "0471", "variation": "negative_1", "code": "toMermaidWithConfig config info = T.unlines $\n  [ \"flowchart \" <> config.mcDirection\n  , \"\"\n  , \"    %% EntryNode and Exit\"\n  , \"    entry((\" <> config.mcEntryLabel <> \"))\"\n  , \"    exit__((\" <> config.mcExitLabel <> \"))\"\n  , \"\"\n  ]\n  ++ nodeDeclarations config info\n  ++ [\"\"]\n  ++ groupDeclarations info\n  ++ [\"\"]\n  ++ edgeDeclarations config info\n\n-- | Generate node declarations.\n", "criteria": "CRITERIA_0471", "selected": "SELECTED_0471", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toMermaidWithConfig", "range": {"end": {"character": 19, "line": 143}, "start": {"character": 0, "line": 143}}}
{"example_id": "0472", "variation": "negative_2", "code": "toMermaidWithConfig config info = T.unlines $\n  [ \"flowchart \" <> config.mcDirection\n  , \"\"\n  , \"    %% EntryNode and Exit\"\n  , \"    entry((\" <> config.mcEntryLabel <> \"))\"\n  , \"    exit__((\" <> config.mcExitLabel <> \"))\"\n  , \"\"\n  ]\n  ++ nodeDeclarations config info\n  ++ [\"\"]\n  ++ groupDeclarations info\n  ++ [\"\"]\n  ++ edgeDeclarations config info\n\n-- | Generate node declarations.\n", "criteria": "CRITERIA_0472", "selected": "SELECTED_0472", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toMermaidWithConfig", "range": {"end": {"character": 19, "line": 143}, "start": {"character": 0, "line": 143}}}
{"example_id": "0473", "variation": "positive_structure", "code": "toSequenceDiagram config info path = T.unlines $\n  [ \"sequenceDiagram\"\n  , \"\"\n  , \"    %% Participants\"\n  , \"    participant EntryNode\"\n  ]\n  ++ map renderParticipant path.pathSteps\n  ++ [ \"    participant Exit\"\n     , \"\"\n     , \"    %% Message flow\"\n     ]\n  ++ sequenceMessages config info path\n\n-- | Render a participant declaration.\n", "criteria": "CRITERIA_0473", "selected": "SELECTED_0473", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toSequenceDiagram", "range": {"end": {"character": 17, "line": 509}, "start": {"character": 0, "line": 509}}}
{"example_id": "0474", "variation": "positive_semantic", "code": "toSequenceDiagram config info path = T.unlines $\n  [ \"sequenceDiagram\"\n  , \"\"\n  , \"    %% Participants\"\n  , \"    participant EntryNode\"\n  ]\n  ++ map renderParticipant path.pathSteps\n  ++ [ \"    participant Exit\"\n     , \"\"\n     , \"    %% Message flow\"\n     ]\n  ++ sequenceMessages config info path\n\n-- | Render a participant declaration.\n", "criteria": "CRITERIA_0474", "selected": "SELECTED_0474", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toSequenceDiagram", "range": {"end": {"character": 17, "line": 509}, "start": {"character": 0, "line": 509}}}
{"example_id": "0475", "variation": "negative_1", "code": "toSequenceDiagram config info path = T.unlines $\n  [ \"sequenceDiagram\"\n  , \"\"\n  , \"    %% Participants\"\n  , \"    participant EntryNode\"\n  ]\n  ++ map renderParticipant path.pathSteps\n  ++ [ \"    participant Exit\"\n     , \"\"\n     , \"    %% Message flow\"\n     ]\n  ++ sequenceMessages config info path\n\n-- | Render a participant declaration.\n", "criteria": "CRITERIA_0475", "selected": "SELECTED_0475", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toSequenceDiagram", "range": {"end": {"character": 17, "line": 509}, "start": {"character": 0, "line": 509}}}
{"example_id": "0476", "variation": "negative_2", "code": "toSequenceDiagram config info path = T.unlines $\n  [ \"sequenceDiagram\"\n  , \"\"\n  , \"    %% Participants\"\n  , \"    participant EntryNode\"\n  ]\n  ++ map renderParticipant path.pathSteps\n  ++ [ \"    participant Exit\"\n     , \"\"\n     , \"    %% Message flow\"\n     ]\n  ++ sequenceMessages config info path\n\n-- | Render a participant declaration.\n", "criteria": "CRITERIA_0476", "selected": "SELECTED_0476", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toSequenceDiagram", "range": {"end": {"character": 17, "line": 509}, "start": {"character": 0, "line": 509}}}
{"example_id": "0477", "variation": "positive_structure", "code": "toStateDiagram = toStateDiagramWithConfig defaultConfig\n\n-- | Generate Mermaid state diagram with custom configuration.\n", "criteria": "CRITERIA_0477", "selected": "SELECTED_0477", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toStateDiagram", "range": {"end": {"character": 14, "line": 387}, "start": {"character": 0, "line": 387}}}
{"example_id": "0478", "variation": "positive_semantic", "code": "toStateDiagram = toStateDiagramWithConfig defaultConfig\n\n-- | Generate Mermaid state diagram with custom configuration.\n", "criteria": "CRITERIA_0478", "selected": "SELECTED_0478", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toStateDiagram", "range": {"end": {"character": 14, "line": 387}, "start": {"character": 0, "line": 387}}}
{"example_id": "0479", "variation": "negative_1", "code": "toStateDiagram = toStateDiagramWithConfig defaultConfig\n\n-- | Generate Mermaid state diagram with custom configuration.\n", "criteria": "CRITERIA_0479", "selected": "SELECTED_0479", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toStateDiagram", "range": {"end": {"character": 14, "line": 387}, "start": {"character": 0, "line": 387}}}
{"example_id": "0480", "variation": "negative_2", "code": "toStateDiagram = toStateDiagramWithConfig defaultConfig\n\n-- | Generate Mermaid state diagram with custom configuration.\n", "criteria": "CRITERIA_0480", "selected": "SELECTED_0480", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toStateDiagram", "range": {"end": {"character": 14, "line": 387}, "start": {"character": 0, "line": 387}}}
{"example_id": "0481", "variation": "positive_structure", "code": "toStateDiagramWithConfig config info = T.unlines $\n  [ \"stateDiagram-v2\"\n  , \"\"\n  ]\n  ++ stateDefinitions config info\n  ++ [\"\"]\n  ++ stateTransitions config info\n\n-- | Generate state definitions with annotations.\n", "criteria": "CRITERIA_0481", "selected": "SELECTED_0481", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toStateDiagramWithConfig", "range": {"end": {"character": 24, "line": 391}, "start": {"character": 0, "line": 391}}}
{"example_id": "0482", "variation": "positive_semantic", "code": "toStateDiagramWithConfig config info = T.unlines $\n  [ \"stateDiagram-v2\"\n  , \"\"\n  ]\n  ++ stateDefinitions config info\n  ++ [\"\"]\n  ++ stateTransitions config info\n\n-- | Generate state definitions with annotations.\n", "criteria": "CRITERIA_0482", "selected": "SELECTED_0482", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toStateDiagramWithConfig", "range": {"end": {"character": 24, "line": 391}, "start": {"character": 0, "line": 391}}}
{"example_id": "0483", "variation": "negative_1", "code": "toStateDiagramWithConfig config info = T.unlines $\n  [ \"stateDiagram-v2\"\n  , \"\"\n  ]\n  ++ stateDefinitions config info\n  ++ [\"\"]\n  ++ stateTransitions config info\n\n-- | Generate state definitions with annotations.\n", "criteria": "CRITERIA_0483", "selected": "SELECTED_0483", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toStateDiagramWithConfig", "range": {"end": {"character": 24, "line": 391}, "start": {"character": 0, "line": 391}}}
{"example_id": "0484", "variation": "negative_2", "code": "toStateDiagramWithConfig config info = T.unlines $\n  [ \"stateDiagram-v2\"\n  , \"\"\n  ]\n  ++ stateDefinitions config info\n  ++ [\"\"]\n  ++ stateTransitions config info\n\n-- | Generate state definitions with annotations.\n", "criteria": "CRITERIA_0484", "selected": "SELECTED_0484", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "toStateDiagramWithConfig", "range": {"end": {"character": 24, "line": 391}, "start": {"character": 0, "line": 391}}}
{"example_id": "0485", "variation": "positive_structure", "code": "toKebabCase = \\case\n  [] -> []\n  (c:cs) -> toLower c : go c cs\n  where\n    go :: Char -> String -> String\n    go _ [] = []\n    go prev (c:cs)\n      | isUpper c && not (isUpper prev)\n          = '-' : toLower c : go c cs\n      | otherwise\n          = toLower c : go c cs\n\n-- | Generate error message for missing field documentation.\n", "criteria": "CRITERIA_0485", "selected": "SELECTED_0485", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "toKebabCase", "range": {"end": {"character": 11, "line": 542}, "start": {"character": 0, "line": 542}}}
{"example_id": "0486", "variation": "positive_semantic", "code": "toKebabCase = \\case\n  [] -> []\n  (c:cs) -> toLower c : go c cs\n  where\n    go :: Char -> String -> String\n    go _ [] = []\n    go prev (c:cs)\n      | isUpper c && not (isUpper prev)\n          = '-' : toLower c : go c cs\n      | otherwise\n          = toLower c : go c cs\n\n-- | Generate error message for missing field documentation.\n", "criteria": "CRITERIA_0486", "selected": "SELECTED_0486", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "toKebabCase", "range": {"end": {"character": 11, "line": 542}, "start": {"character": 0, "line": 542}}}
{"example_id": "0487", "variation": "negative_1", "code": "toKebabCase = \\case\n  [] -> []\n  (c:cs) -> toLower c : go c cs\n  where\n    go :: Char -> String -> String\n    go _ [] = []\n    go prev (c:cs)\n      | isUpper c && not (isUpper prev)\n          = '-' : toLower c : go c cs\n      | otherwise\n          = toLower c : go c cs\n\n-- | Generate error message for missing field documentation.\n", "criteria": "CRITERIA_0487", "selected": "SELECTED_0487", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "toKebabCase", "range": {"end": {"character": 11, "line": 542}, "start": {"character": 0, "line": 542}}}
{"example_id": "0488", "variation": "negative_2", "code": "toKebabCase = \\case\n  [] -> []\n  (c:cs) -> toLower c : go c cs\n  where\n    go :: Char -> String -> String\n    go _ [] = []\n    go prev (c:cs)\n      | isUpper c && not (isUpper prev)\n          = '-' : toLower c : go c cs\n      | otherwise\n          = toLower c : go c cs\n\n-- | Generate error message for missing field documentation.\n", "criteria": "CRITERIA_0488", "selected": "SELECTED_0488", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "toKebabCase", "range": {"end": {"character": 11, "line": 542}, "start": {"character": 0, "line": 542}}}
{"example_id": "0489", "variation": "positive_structure", "code": "toolCallOptions = defaultOptions\n  { fieldLabelModifier = camelToSnake . dropPrefix \"tc\"\n  , omitNothingFields = True\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- JSON HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Drop a prefix from a field name.\n--\n-- @dropPrefix \"so\" \"soSessionId\" = \"SessionId\"@\n", "criteria": "CRITERIA_0489", "selected": "SELECTED_0489", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "toolCallOptions", "range": {"end": {"character": 15, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "0490", "variation": "positive_semantic", "code": "toolCallOptions = defaultOptions\n  { fieldLabelModifier = camelToSnake . dropPrefix \"tc\"\n  , omitNothingFields = True\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- JSON HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Drop a prefix from a field name.\n--\n-- @dropPrefix \"so\" \"soSessionId\" = \"SessionId\"@\n", "criteria": "CRITERIA_0490", "selected": "SELECTED_0490", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "toolCallOptions", "range": {"end": {"character": 15, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "0491", "variation": "negative_1", "code": "toolCallOptions = defaultOptions\n  { fieldLabelModifier = camelToSnake . dropPrefix \"tc\"\n  , omitNothingFields = True\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- JSON HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Drop a prefix from a field name.\n--\n-- @dropPrefix \"so\" \"soSessionId\" = \"SessionId\"@\n", "criteria": "CRITERIA_0491", "selected": "SELECTED_0491", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "toolCallOptions", "range": {"end": {"character": 15, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "0492", "variation": "negative_2", "code": "toolCallOptions = defaultOptions\n  { fieldLabelModifier = camelToSnake . dropPrefix \"tc\"\n  , omitNothingFields = True\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- JSON HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Drop a prefix from a field name.\n--\n-- @dropPrefix \"so\" \"soSessionId\" = \"SessionId\"@\n", "criteria": "CRITERIA_0492", "selected": "SELECTED_0492", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Session.hs", "name": "toolCallOptions", "range": {"end": {"character": 15, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "0493", "variation": "positive_structure", "code": "toTextDocumentId doc = L.TextDocumentIdentifier\n  { L._uri = L.Uri doc.tdiUri\n  }\n\n", "criteria": "CRITERIA_0493", "selected": "SELECTED_0493", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toTextDocumentId", "range": {"end": {"character": 16, "line": 281}, "start": {"character": 0, "line": 281}}}
{"example_id": "0494", "variation": "positive_semantic", "code": "toTextDocumentId doc = L.TextDocumentIdentifier\n  { L._uri = L.Uri doc.tdiUri\n  }\n\n", "criteria": "CRITERIA_0494", "selected": "SELECTED_0494", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toTextDocumentId", "range": {"end": {"character": 16, "line": 281}, "start": {"character": 0, "line": 281}}}
{"example_id": "0495", "variation": "negative_1", "code": "toTextDocumentId doc = L.TextDocumentIdentifier\n  { L._uri = L.Uri doc.tdiUri\n  }\n\n", "criteria": "CRITERIA_0495", "selected": "SELECTED_0495", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toTextDocumentId", "range": {"end": {"character": 16, "line": 281}, "start": {"character": 0, "line": 281}}}
{"example_id": "0496", "variation": "negative_2", "code": "toTextDocumentId doc = L.TextDocumentIdentifier\n  { L._uri = L.Uri doc.tdiUri\n  }\n\n", "criteria": "CRITERIA_0496", "selected": "SELECTED_0496", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toTextDocumentId", "range": {"end": {"character": 16, "line": 281}, "start": {"character": 0, "line": 281}}}
{"example_id": "0497", "variation": "positive_structure", "code": "toPosition pos = L.Position\n  { L._line = fromIntegral pos.posLine\n  , L._character = fromIntegral pos.posCharacter\n  }\n\n", "criteria": "CRITERIA_0497", "selected": "SELECTED_0497", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toPosition", "range": {"end": {"character": 10, "line": 286}, "start": {"character": 0, "line": 286}}}
{"example_id": "0498", "variation": "positive_semantic", "code": "toPosition pos = L.Position\n  { L._line = fromIntegral pos.posLine\n  , L._character = fromIntegral pos.posCharacter\n  }\n\n", "criteria": "CRITERIA_0498", "selected": "SELECTED_0498", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toPosition", "range": {"end": {"character": 10, "line": 286}, "start": {"character": 0, "line": 286}}}
{"example_id": "0499", "variation": "negative_1", "code": "toPosition pos = L.Position\n  { L._line = fromIntegral pos.posLine\n  , L._character = fromIntegral pos.posCharacter\n  }\n\n", "criteria": "CRITERIA_0499", "selected": "SELECTED_0499", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toPosition", "range": {"end": {"character": 10, "line": 286}, "start": {"character": 0, "line": 286}}}
{"example_id": "0500", "variation": "negative_2", "code": "toPosition pos = L.Position\n  { L._line = fromIntegral pos.posLine\n  , L._character = fromIntegral pos.posCharacter\n  }\n\n", "criteria": "CRITERIA_0500", "selected": "SELECTED_0500", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toPosition", "range": {"end": {"character": 10, "line": 286}, "start": {"character": 0, "line": 286}}}
{"example_id": "0501", "variation": "positive_structure", "code": "toRange rng = L.Range\n  { L._start = toPosition rng.rangeStart\n  , L._end = toPosition rng.rangeEnd\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TYPE CONVERSIONS: lsp-types -> Our types\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0501", "selected": "SELECTED_0501", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toRange", "range": {"end": {"character": 7, "line": 292}, "start": {"character": 0, "line": 292}}}
{"example_id": "0502", "variation": "positive_semantic", "code": "toRange rng = L.Range\n  { L._start = toPosition rng.rangeStart\n  , L._end = toPosition rng.rangeEnd\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TYPE CONVERSIONS: lsp-types -> Our types\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0502", "selected": "SELECTED_0502", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toRange", "range": {"end": {"character": 7, "line": 292}, "start": {"character": 0, "line": 292}}}
{"example_id": "0503", "variation": "negative_1", "code": "toRange rng = L.Range\n  { L._start = toPosition rng.rangeStart\n  , L._end = toPosition rng.rangeEnd\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TYPE CONVERSIONS: lsp-types -> Our types\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0503", "selected": "SELECTED_0503", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toRange", "range": {"end": {"character": 7, "line": 292}, "start": {"character": 0, "line": 292}}}
{"example_id": "0504", "variation": "negative_2", "code": "toRange rng = L.Range\n  { L._start = toPosition rng.rangeStart\n  , L._end = toPosition rng.rangeEnd\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TYPE CONVERSIONS: lsp-types -> Our types\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0504", "selected": "SELECTED_0504", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "toRange", "range": {"end": {"character": 7, "line": 292}, "start": {"character": 0, "line": 292}}}
{"example_id": "0505", "variation": "positive_structure", "code": "fromPosition pos = Position\n  { posLine = fromIntegral pos._line\n  , posCharacter = fromIntegral pos._character\n  }\n\n", "criteria": "CRITERIA_0505", "selected": "SELECTED_0505", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromPosition", "range": {"end": {"character": 12, "line": 303}, "start": {"character": 0, "line": 303}}}
{"example_id": "0506", "variation": "positive_semantic", "code": "fromPosition pos = Position\n  { posLine = fromIntegral pos._line\n  , posCharacter = fromIntegral pos._character\n  }\n\n", "criteria": "CRITERIA_0506", "selected": "SELECTED_0506", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromPosition", "range": {"end": {"character": 12, "line": 303}, "start": {"character": 0, "line": 303}}}
{"example_id": "0507", "variation": "negative_1", "code": "fromPosition pos = Position\n  { posLine = fromIntegral pos._line\n  , posCharacter = fromIntegral pos._character\n  }\n\n", "criteria": "CRITERIA_0507", "selected": "SELECTED_0507", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromPosition", "range": {"end": {"character": 12, "line": 303}, "start": {"character": 0, "line": 303}}}
{"example_id": "0508", "variation": "negative_2", "code": "fromPosition pos = Position\n  { posLine = fromIntegral pos._line\n  , posCharacter = fromIntegral pos._character\n  }\n\n", "criteria": "CRITERIA_0508", "selected": "SELECTED_0508", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromPosition", "range": {"end": {"character": 12, "line": 303}, "start": {"character": 0, "line": 303}}}
{"example_id": "0509", "variation": "positive_structure", "code": "fromRange rng = Range\n  { rangeStart = fromPosition rng._start\n  , rangeEnd = fromPosition rng._end\n  }\n\n", "criteria": "CRITERIA_0509", "selected": "SELECTED_0509", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromRange", "range": {"end": {"character": 9, "line": 309}, "start": {"character": 0, "line": 309}}}
{"example_id": "0510", "variation": "positive_semantic", "code": "fromRange rng = Range\n  { rangeStart = fromPosition rng._start\n  , rangeEnd = fromPosition rng._end\n  }\n\n", "criteria": "CRITERIA_0510", "selected": "SELECTED_0510", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromRange", "range": {"end": {"character": 9, "line": 309}, "start": {"character": 0, "line": 309}}}
{"example_id": "0511", "variation": "negative_1", "code": "fromRange rng = Range\n  { rangeStart = fromPosition rng._start\n  , rangeEnd = fromPosition rng._end\n  }\n\n", "criteria": "CRITERIA_0511", "selected": "SELECTED_0511", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromRange", "range": {"end": {"character": 9, "line": 309}, "start": {"character": 0, "line": 309}}}
{"example_id": "0512", "variation": "negative_2", "code": "fromRange rng = Range\n  { rangeStart = fromPosition rng._start\n  , rangeEnd = fromPosition rng._end\n  }\n\n", "criteria": "CRITERIA_0512", "selected": "SELECTED_0512", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromRange", "range": {"end": {"character": 9, "line": 309}, "start": {"character": 0, "line": 309}}}
{"example_id": "0513", "variation": "positive_structure", "code": "fromLocation loc = Location\n  { locUri = let L.Uri u = loc._uri in u\n  , locRange = fromRange loc._range\n  }\n\n-- lsp-test's getHover returns Maybe Hover directly\n", "criteria": "CRITERIA_0513", "selected": "SELECTED_0513", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromLocation", "range": {"end": {"character": 12, "line": 315}, "start": {"character": 0, "line": 315}}}
{"example_id": "0514", "variation": "positive_semantic", "code": "fromLocation loc = Location\n  { locUri = let L.Uri u = loc._uri in u\n  , locRange = fromRange loc._range\n  }\n\n-- lsp-test's getHover returns Maybe Hover directly\n", "criteria": "CRITERIA_0514", "selected": "SELECTED_0514", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromLocation", "range": {"end": {"character": 12, "line": 315}, "start": {"character": 0, "line": 315}}}
{"example_id": "0515", "variation": "negative_1", "code": "fromLocation loc = Location\n  { locUri = let L.Uri u = loc._uri in u\n  , locRange = fromRange loc._range\n  }\n\n-- lsp-test's getHover returns Maybe Hover directly\n", "criteria": "CRITERIA_0515", "selected": "SELECTED_0515", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromLocation", "range": {"end": {"character": 12, "line": 315}, "start": {"character": 0, "line": 315}}}
{"example_id": "0516", "variation": "negative_2", "code": "fromLocation loc = Location\n  { locUri = let L.Uri u = loc._uri in u\n  , locRange = fromRange loc._range\n  }\n\n-- lsp-test's getHover returns Maybe Hover directly\n", "criteria": "CRITERIA_0516", "selected": "SELECTED_0516", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromLocation", "range": {"end": {"character": 12, "line": 315}, "start": {"character": 0, "line": 315}}}
{"example_id": "0517", "variation": "positive_structure", "code": "fromHoverResult Nothing = Nothing\n", "criteria": "CRITERIA_0517", "selected": "SELECTED_0517", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromHoverResult", "range": {"end": {"character": 15, "line": 322}, "start": {"character": 0, "line": 322}}}
{"example_id": "0518", "variation": "positive_semantic", "code": "fromHoverResult Nothing = Nothing\n", "criteria": "CRITERIA_0518", "selected": "SELECTED_0518", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromHoverResult", "range": {"end": {"character": 15, "line": 322}, "start": {"character": 0, "line": 322}}}
{"example_id": "0519", "variation": "negative_1", "code": "fromHoverResult Nothing = Nothing\n", "criteria": "CRITERIA_0519", "selected": "SELECTED_0519", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromHoverResult", "range": {"end": {"character": 15, "line": 322}, "start": {"character": 0, "line": 322}}}
{"example_id": "0520", "variation": "negative_2", "code": "fromHoverResult Nothing = Nothing\n", "criteria": "CRITERIA_0520", "selected": "SELECTED_0520", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromHoverResult", "range": {"end": {"character": 15, "line": 322}, "start": {"character": 0, "line": 322}}}
{"example_id": "0521", "variation": "positive_structure", "code": "fromDefinitionResult result = case result of\n  L.InL def -> fromDefinition def\n  L.InR linksOrNull -> case linksOrNull of\n    L.InL links -> map fromDefinitionLink links\n    L.InR L.Null -> []\n  where\n    fromDefinition :: L.Definition -> [Location]\n    fromDefinition d = case d of\n      L.Definition (L.InL loc) -> [fromLocation loc]\n      L.Definition (L.InR locs) -> map fromLocation locs\n\n    fromDefinitionLink :: L.DefinitionLink -> Location\n    fromDefinitionLink (L.DefinitionLink link) = fromLocationLink link\n\n", "criteria": "CRITERIA_0521", "selected": "SELECTED_0521", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromDefinitionResult", "range": {"end": {"character": 20, "line": 344}, "start": {"character": 0, "line": 344}}}
{"example_id": "0522", "variation": "positive_semantic", "code": "fromDefinitionResult result = case result of\n  L.InL def -> fromDefinition def\n  L.InR linksOrNull -> case linksOrNull of\n    L.InL links -> map fromDefinitionLink links\n    L.InR L.Null -> []\n  where\n    fromDefinition :: L.Definition -> [Location]\n    fromDefinition d = case d of\n      L.Definition (L.InL loc) -> [fromLocation loc]\n      L.Definition (L.InR locs) -> map fromLocation locs\n\n    fromDefinitionLink :: L.DefinitionLink -> Location\n    fromDefinitionLink (L.DefinitionLink link) = fromLocationLink link\n\n", "criteria": "CRITERIA_0522", "selected": "SELECTED_0522", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromDefinitionResult", "range": {"end": {"character": 20, "line": 344}, "start": {"character": 0, "line": 344}}}
{"example_id": "0523", "variation": "negative_1", "code": "fromDefinitionResult result = case result of\n  L.InL def -> fromDefinition def\n  L.InR linksOrNull -> case linksOrNull of\n    L.InL links -> map fromDefinitionLink links\n    L.InR L.Null -> []\n  where\n    fromDefinition :: L.Definition -> [Location]\n    fromDefinition d = case d of\n      L.Definition (L.InL loc) -> [fromLocation loc]\n      L.Definition (L.InR locs) -> map fromLocation locs\n\n    fromDefinitionLink :: L.DefinitionLink -> Location\n    fromDefinitionLink (L.DefinitionLink link) = fromLocationLink link\n\n", "criteria": "CRITERIA_0523", "selected": "SELECTED_0523", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromDefinitionResult", "range": {"end": {"character": 20, "line": 344}, "start": {"character": 0, "line": 344}}}
{"example_id": "0524", "variation": "negative_2", "code": "fromDefinitionResult result = case result of\n  L.InL def -> fromDefinition def\n  L.InR linksOrNull -> case linksOrNull of\n    L.InL links -> map fromDefinitionLink links\n    L.InR L.Null -> []\n  where\n    fromDefinition :: L.Definition -> [Location]\n    fromDefinition d = case d of\n      L.Definition (L.InL loc) -> [fromLocation loc]\n      L.Definition (L.InR locs) -> map fromLocation locs\n\n    fromDefinitionLink :: L.DefinitionLink -> Location\n    fromDefinitionLink (L.DefinitionLink link) = fromLocationLink link\n\n", "criteria": "CRITERIA_0524", "selected": "SELECTED_0524", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromDefinitionResult", "range": {"end": {"character": 20, "line": 344}, "start": {"character": 0, "line": 344}}}
{"example_id": "0525", "variation": "positive_structure", "code": "fromLocationLink link = Location\n  { locUri = let L.Uri u = link._targetUri in u\n  , locRange = fromRange link._targetRange\n  }\n\n-- lsp-test's getCodeActions returns [Command |? CodeAction]\n", "criteria": "CRITERIA_0525", "selected": "SELECTED_0525", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromLocationLink", "range": {"end": {"character": 16, "line": 359}, "start": {"character": 0, "line": 359}}}
{"example_id": "0526", "variation": "positive_semantic", "code": "fromLocationLink link = Location\n  { locUri = let L.Uri u = link._targetUri in u\n  , locRange = fromRange link._targetRange\n  }\n\n-- lsp-test's getCodeActions returns [Command |? CodeAction]\n", "criteria": "CRITERIA_0526", "selected": "SELECTED_0526", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromLocationLink", "range": {"end": {"character": 16, "line": 359}, "start": {"character": 0, "line": 359}}}
{"example_id": "0527", "variation": "negative_1", "code": "fromLocationLink link = Location\n  { locUri = let L.Uri u = link._targetUri in u\n  , locRange = fromRange link._targetRange\n  }\n\n-- lsp-test's getCodeActions returns [Command |? CodeAction]\n", "criteria": "CRITERIA_0527", "selected": "SELECTED_0527", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromLocationLink", "range": {"end": {"character": 16, "line": 359}, "start": {"character": 0, "line": 359}}}
{"example_id": "0528", "variation": "negative_2", "code": "fromLocationLink link = Location\n  { locUri = let L.Uri u = link._targetUri in u\n  , locRange = fromRange link._targetRange\n  }\n\n-- lsp-test's getCodeActions returns [Command |? CodeAction]\n", "criteria": "CRITERIA_0528", "selected": "SELECTED_0528", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromLocationLink", "range": {"end": {"character": 16, "line": 359}, "start": {"character": 0, "line": 359}}}
{"example_id": "0529", "variation": "positive_structure", "code": "fromCodeActionsResult items = concatMap fromCommandOrAction items\n\n", "criteria": "CRITERIA_0529", "selected": "SELECTED_0529", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeActionsResult", "range": {"end": {"character": 21, "line": 366}, "start": {"character": 0, "line": 366}}}
{"example_id": "0530", "variation": "positive_semantic", "code": "fromCodeActionsResult items = concatMap fromCommandOrAction items\n\n", "criteria": "CRITERIA_0530", "selected": "SELECTED_0530", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeActionsResult", "range": {"end": {"character": 21, "line": 366}, "start": {"character": 0, "line": 366}}}
{"example_id": "0531", "variation": "negative_1", "code": "fromCodeActionsResult items = concatMap fromCommandOrAction items\n\n", "criteria": "CRITERIA_0531", "selected": "SELECTED_0531", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeActionsResult", "range": {"end": {"character": 21, "line": 366}, "start": {"character": 0, "line": 366}}}
{"example_id": "0532", "variation": "negative_2", "code": "fromCodeActionsResult items = concatMap fromCommandOrAction items\n\n", "criteria": "CRITERIA_0532", "selected": "SELECTED_0532", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeActionsResult", "range": {"end": {"character": 21, "line": 366}, "start": {"character": 0, "line": 366}}}
{"example_id": "0533", "variation": "positive_structure", "code": "fromCommandOrAction cmdOrAction = case cmdOrAction of\n  L.InL _cmd -> []  -- Skip commands\n  L.InR ca -> [fromCodeAction ca]\n\n", "criteria": "CRITERIA_0533", "selected": "SELECTED_0533", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCommandOrAction", "range": {"end": {"character": 19, "line": 369}, "start": {"character": 0, "line": 369}}}
{"example_id": "0534", "variation": "positive_semantic", "code": "fromCommandOrAction cmdOrAction = case cmdOrAction of\n  L.InL _cmd -> []  -- Skip commands\n  L.InR ca -> [fromCodeAction ca]\n\n", "criteria": "CRITERIA_0534", "selected": "SELECTED_0534", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCommandOrAction", "range": {"end": {"character": 19, "line": 369}, "start": {"character": 0, "line": 369}}}
{"example_id": "0535", "variation": "negative_1", "code": "fromCommandOrAction cmdOrAction = case cmdOrAction of\n  L.InL _cmd -> []  -- Skip commands\n  L.InR ca -> [fromCodeAction ca]\n\n", "criteria": "CRITERIA_0535", "selected": "SELECTED_0535", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCommandOrAction", "range": {"end": {"character": 19, "line": 369}, "start": {"character": 0, "line": 369}}}
{"example_id": "0536", "variation": "negative_2", "code": "fromCommandOrAction cmdOrAction = case cmdOrAction of\n  L.InL _cmd -> []  -- Skip commands\n  L.InR ca -> [fromCodeAction ca]\n\n", "criteria": "CRITERIA_0536", "selected": "SELECTED_0536", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCommandOrAction", "range": {"end": {"character": 19, "line": 369}, "start": {"character": 0, "line": 369}}}
{"example_id": "0537", "variation": "positive_structure", "code": "fromCodeAction ca = CodeAction\n  { caTitle = ca._title\n  , caKind = fromCodeActionKind <$> ca._kind\n  , caEdit = fromWorkspaceEditMaybe ca._edit\n  , caCommand = fmap (._title) ca._command\n  }\n\n", "criteria": "CRITERIA_0537", "selected": "SELECTED_0537", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeAction", "range": {"end": {"character": 14, "line": 374}, "start": {"character": 0, "line": 374}}}
{"example_id": "0538", "variation": "positive_semantic", "code": "fromCodeAction ca = CodeAction\n  { caTitle = ca._title\n  , caKind = fromCodeActionKind <$> ca._kind\n  , caEdit = fromWorkspaceEditMaybe ca._edit\n  , caCommand = fmap (._title) ca._command\n  }\n\n", "criteria": "CRITERIA_0538", "selected": "SELECTED_0538", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeAction", "range": {"end": {"character": 14, "line": 374}, "start": {"character": 0, "line": 374}}}
{"example_id": "0539", "variation": "negative_1", "code": "fromCodeAction ca = CodeAction\n  { caTitle = ca._title\n  , caKind = fromCodeActionKind <$> ca._kind\n  , caEdit = fromWorkspaceEditMaybe ca._edit\n  , caCommand = fmap (._title) ca._command\n  }\n\n", "criteria": "CRITERIA_0539", "selected": "SELECTED_0539", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeAction", "range": {"end": {"character": 14, "line": 374}, "start": {"character": 0, "line": 374}}}
{"example_id": "0540", "variation": "negative_2", "code": "fromCodeAction ca = CodeAction\n  { caTitle = ca._title\n  , caKind = fromCodeActionKind <$> ca._kind\n  , caEdit = fromWorkspaceEditMaybe ca._edit\n  , caCommand = fmap (._title) ca._command\n  }\n\n", "criteria": "CRITERIA_0540", "selected": "SELECTED_0540", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeAction", "range": {"end": {"character": 14, "line": 374}, "start": {"character": 0, "line": 374}}}
{"example_id": "0541", "variation": "positive_structure", "code": "fromCodeActionKind k = case k of\n  L.CodeActionKind_QuickFix -> QuickFix\n  L.CodeActionKind_Refactor -> Refactor\n  L.CodeActionKind_RefactorExtract -> RefactorExtract\n  L.CodeActionKind_RefactorInline -> RefactorInline\n  L.CodeActionKind_RefactorRewrite -> RefactorRewrite\n  L.CodeActionKind_Source -> Source\n  L.CodeActionKind_SourceOrganizeImports -> SourceOrganizeImports\n  L.CodeActionKind_SourceFixAll -> SourceFixAll\n  L.CodeActionKind_Custom t -> OtherKind t\n  L.CodeActionKind_Empty -> OtherKind \"\"\n  _ -> OtherKind \"\"  -- Handle any new constructors\n\n-- lsp-test's rename returns WorkspaceEdit directly\n", "criteria": "CRITERIA_0541", "selected": "SELECTED_0541", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeActionKind", "range": {"end": {"character": 18, "line": 382}, "start": {"character": 0, "line": 382}}}
{"example_id": "0542", "variation": "positive_semantic", "code": "fromCodeActionKind k = case k of\n  L.CodeActionKind_QuickFix -> QuickFix\n  L.CodeActionKind_Refactor -> Refactor\n  L.CodeActionKind_RefactorExtract -> RefactorExtract\n  L.CodeActionKind_RefactorInline -> RefactorInline\n  L.CodeActionKind_RefactorRewrite -> RefactorRewrite\n  L.CodeActionKind_Source -> Source\n  L.CodeActionKind_SourceOrganizeImports -> SourceOrganizeImports\n  L.CodeActionKind_SourceFixAll -> SourceFixAll\n  L.CodeActionKind_Custom t -> OtherKind t\n  L.CodeActionKind_Empty -> OtherKind \"\"\n  _ -> OtherKind \"\"  -- Handle any new constructors\n\n-- lsp-test's rename returns WorkspaceEdit directly\n", "criteria": "CRITERIA_0542", "selected": "SELECTED_0542", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeActionKind", "range": {"end": {"character": 18, "line": 382}, "start": {"character": 0, "line": 382}}}
{"example_id": "0543", "variation": "negative_1", "code": "fromCodeActionKind k = case k of\n  L.CodeActionKind_QuickFix -> QuickFix\n  L.CodeActionKind_Refactor -> Refactor\n  L.CodeActionKind_RefactorExtract -> RefactorExtract\n  L.CodeActionKind_RefactorInline -> RefactorInline\n  L.CodeActionKind_RefactorRewrite -> RefactorRewrite\n  L.CodeActionKind_Source -> Source\n  L.CodeActionKind_SourceOrganizeImports -> SourceOrganizeImports\n  L.CodeActionKind_SourceFixAll -> SourceFixAll\n  L.CodeActionKind_Custom t -> OtherKind t\n  L.CodeActionKind_Empty -> OtherKind \"\"\n  _ -> OtherKind \"\"  -- Handle any new constructors\n\n-- lsp-test's rename returns WorkspaceEdit directly\n", "criteria": "CRITERIA_0543", "selected": "SELECTED_0543", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeActionKind", "range": {"end": {"character": 18, "line": 382}, "start": {"character": 0, "line": 382}}}
{"example_id": "0544", "variation": "negative_2", "code": "fromCodeActionKind k = case k of\n  L.CodeActionKind_QuickFix -> QuickFix\n  L.CodeActionKind_Refactor -> Refactor\n  L.CodeActionKind_RefactorExtract -> RefactorExtract\n  L.CodeActionKind_RefactorInline -> RefactorInline\n  L.CodeActionKind_RefactorRewrite -> RefactorRewrite\n  L.CodeActionKind_Source -> Source\n  L.CodeActionKind_SourceOrganizeImports -> SourceOrganizeImports\n  L.CodeActionKind_SourceFixAll -> SourceFixAll\n  L.CodeActionKind_Custom t -> OtherKind t\n  L.CodeActionKind_Empty -> OtherKind \"\"\n  _ -> OtherKind \"\"  -- Handle any new constructors\n\n-- lsp-test's rename returns WorkspaceEdit directly\n", "criteria": "CRITERIA_0544", "selected": "SELECTED_0544", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCodeActionKind", "range": {"end": {"character": 18, "line": 382}, "start": {"character": 0, "line": 382}}}
{"example_id": "0545", "variation": "positive_structure", "code": "fromWorkspaceEditResult we = fromWorkspaceEditMaybe (Just we)\n  & maybe (WorkspaceEdit Map.empty) id\n\n", "criteria": "CRITERIA_0545", "selected": "SELECTED_0545", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceEditResult", "range": {"end": {"character": 23, "line": 397}, "start": {"character": 0, "line": 397}}}
{"example_id": "0546", "variation": "positive_semantic", "code": "fromWorkspaceEditResult we = fromWorkspaceEditMaybe (Just we)\n  & maybe (WorkspaceEdit Map.empty) id\n\n", "criteria": "CRITERIA_0546", "selected": "SELECTED_0546", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceEditResult", "range": {"end": {"character": 23, "line": 397}, "start": {"character": 0, "line": 397}}}
{"example_id": "0547", "variation": "negative_1", "code": "fromWorkspaceEditResult we = fromWorkspaceEditMaybe (Just we)\n  & maybe (WorkspaceEdit Map.empty) id\n\n", "criteria": "CRITERIA_0547", "selected": "SELECTED_0547", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceEditResult", "range": {"end": {"character": 23, "line": 397}, "start": {"character": 0, "line": 397}}}
{"example_id": "0548", "variation": "negative_2", "code": "fromWorkspaceEditResult we = fromWorkspaceEditMaybe (Just we)\n  & maybe (WorkspaceEdit Map.empty) id\n\n", "criteria": "CRITERIA_0548", "selected": "SELECTED_0548", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceEditResult", "range": {"end": {"character": 23, "line": 397}, "start": {"character": 0, "line": 397}}}
{"example_id": "0549", "variation": "positive_structure", "code": "fromWorkspaceEditMaybe Nothing = Nothing\n", "criteria": "CRITERIA_0549", "selected": "SELECTED_0549", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceEditMaybe", "range": {"end": {"character": 22, "line": 401}, "start": {"character": 0, "line": 401}}}
{"example_id": "0550", "variation": "positive_semantic", "code": "fromWorkspaceEditMaybe Nothing = Nothing\n", "criteria": "CRITERIA_0550", "selected": "SELECTED_0550", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceEditMaybe", "range": {"end": {"character": 22, "line": 401}, "start": {"character": 0, "line": 401}}}
{"example_id": "0551", "variation": "negative_1", "code": "fromWorkspaceEditMaybe Nothing = Nothing\n", "criteria": "CRITERIA_0551", "selected": "SELECTED_0551", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceEditMaybe", "range": {"end": {"character": 22, "line": 401}, "start": {"character": 0, "line": 401}}}
{"example_id": "0552", "variation": "negative_2", "code": "fromWorkspaceEditMaybe Nothing = Nothing\n", "criteria": "CRITERIA_0552", "selected": "SELECTED_0552", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceEditMaybe", "range": {"end": {"character": 22, "line": 401}, "start": {"character": 0, "line": 401}}}
{"example_id": "0553", "variation": "positive_structure", "code": "fromTextEdit te = TextEdit\n  { teRange = fromRange te._range\n  , teNewText = te._newText\n  }\n\n", "criteria": "CRITERIA_0553", "selected": "SELECTED_0553", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromTextEdit", "range": {"end": {"character": 12, "line": 411}, "start": {"character": 0, "line": 411}}}
{"example_id": "0554", "variation": "positive_semantic", "code": "fromTextEdit te = TextEdit\n  { teRange = fromRange te._range\n  , teNewText = te._newText\n  }\n\n", "criteria": "CRITERIA_0554", "selected": "SELECTED_0554", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromTextEdit", "range": {"end": {"character": 12, "line": 411}, "start": {"character": 0, "line": 411}}}
{"example_id": "0555", "variation": "negative_1", "code": "fromTextEdit te = TextEdit\n  { teRange = fromRange te._range\n  , teNewText = te._newText\n  }\n\n", "criteria": "CRITERIA_0555", "selected": "SELECTED_0555", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromTextEdit", "range": {"end": {"character": 12, "line": 411}, "start": {"character": 0, "line": 411}}}
{"example_id": "0556", "variation": "negative_2", "code": "fromTextEdit te = TextEdit\n  { teRange = fromRange te._range\n  , teNewText = te._newText\n  }\n\n", "criteria": "CRITERIA_0556", "selected": "SELECTED_0556", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromTextEdit", "range": {"end": {"character": 12, "line": 411}, "start": {"character": 0, "line": 411}}}
{"example_id": "0557", "variation": "positive_structure", "code": "fromCompletionItem ci = CompletionItem\n  { ciLabel = ci._label\n  , ciKind = fromCompletionItemKind <$> ci._kind\n  , ciDetail = ci._detail\n  , ciDocumentation = extractDocumentation <$> ci._documentation\n  , ciInsertText = ci._insertText\n  }\n\n", "criteria": "CRITERIA_0557", "selected": "SELECTED_0557", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCompletionItem", "range": {"end": {"character": 18, "line": 417}, "start": {"character": 0, "line": 417}}}
{"example_id": "0558", "variation": "positive_semantic", "code": "fromCompletionItem ci = CompletionItem\n  { ciLabel = ci._label\n  , ciKind = fromCompletionItemKind <$> ci._kind\n  , ciDetail = ci._detail\n  , ciDocumentation = extractDocumentation <$> ci._documentation\n  , ciInsertText = ci._insertText\n  }\n\n", "criteria": "CRITERIA_0558", "selected": "SELECTED_0558", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCompletionItem", "range": {"end": {"character": 18, "line": 417}, "start": {"character": 0, "line": 417}}}
{"example_id": "0559", "variation": "negative_1", "code": "fromCompletionItem ci = CompletionItem\n  { ciLabel = ci._label\n  , ciKind = fromCompletionItemKind <$> ci._kind\n  , ciDetail = ci._detail\n  , ciDocumentation = extractDocumentation <$> ci._documentation\n  , ciInsertText = ci._insertText\n  }\n\n", "criteria": "CRITERIA_0559", "selected": "SELECTED_0559", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCompletionItem", "range": {"end": {"character": 18, "line": 417}, "start": {"character": 0, "line": 417}}}
{"example_id": "0560", "variation": "negative_2", "code": "fromCompletionItem ci = CompletionItem\n  { ciLabel = ci._label\n  , ciKind = fromCompletionItemKind <$> ci._kind\n  , ciDetail = ci._detail\n  , ciDocumentation = extractDocumentation <$> ci._documentation\n  , ciInsertText = ci._insertText\n  }\n\n", "criteria": "CRITERIA_0560", "selected": "SELECTED_0560", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCompletionItem", "range": {"end": {"character": 18, "line": 417}, "start": {"character": 0, "line": 417}}}
{"example_id": "0561", "variation": "positive_structure", "code": "fromCompletionItemKind k = case k of\n  L.CompletionItemKind_Text -> CIKText\n  L.CompletionItemKind_Method -> CIKMethod\n  L.CompletionItemKind_Function -> CIKFunction\n  L.CompletionItemKind_Constructor -> CIKConstructor\n  L.CompletionItemKind_Field -> CIKField\n  L.CompletionItemKind_Variable -> CIKVariable\n  L.CompletionItemKind_Class -> CIKClass\n  L.CompletionItemKind_Interface -> CIKInterface\n  L.CompletionItemKind_Module -> CIKModule\n  L.CompletionItemKind_Property -> CIKProperty\n  L.CompletionItemKind_Unit -> CIKUnit\n  L.CompletionItemKind_Value -> CIKValue\n  L.CompletionItemKind_Enum -> CIKEnum\n  L.CompletionItemKind_Keyword -> CIKKeyword\n  L.CompletionItemKind_Snippet -> CIKSnippet\n  L.CompletionItemKind_Color -> CIKColor\n  L.CompletionItemKind_File -> CIKFile\n  L.CompletionItemKind_Reference -> CIKReference\n  L.CompletionItemKind_Folder -> CIKFolder\n  L.CompletionItemKind_EnumMember -> CIKEnumMember\n  L.CompletionItemKind_Constant -> CIKConstant\n  L.CompletionItemKind_Struct -> CIKStruct\n  L.CompletionItemKind_Event -> CIKEvent\n  L.CompletionItemKind_Operator -> CIKOperator\n  L.CompletionItemKind_TypeParameter -> CIKTypeParameter\n\n-- Result type is [SymbolInformation] |? ([WorkspaceSymbol] |? Null)\n", "criteria": "CRITERIA_0561", "selected": "SELECTED_0561", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCompletionItemKind", "range": {"end": {"character": 22, "line": 431}, "start": {"character": 0, "line": 431}}}
{"example_id": "0562", "variation": "positive_semantic", "code": "fromCompletionItemKind k = case k of\n  L.CompletionItemKind_Text -> CIKText\n  L.CompletionItemKind_Method -> CIKMethod\n  L.CompletionItemKind_Function -> CIKFunction\n  L.CompletionItemKind_Constructor -> CIKConstructor\n  L.CompletionItemKind_Field -> CIKField\n  L.CompletionItemKind_Variable -> CIKVariable\n  L.CompletionItemKind_Class -> CIKClass\n  L.CompletionItemKind_Interface -> CIKInterface\n  L.CompletionItemKind_Module -> CIKModule\n  L.CompletionItemKind_Property -> CIKProperty\n  L.CompletionItemKind_Unit -> CIKUnit\n  L.CompletionItemKind_Value -> CIKValue\n  L.CompletionItemKind_Enum -> CIKEnum\n  L.CompletionItemKind_Keyword -> CIKKeyword\n  L.CompletionItemKind_Snippet -> CIKSnippet\n  L.CompletionItemKind_Color -> CIKColor\n  L.CompletionItemKind_File -> CIKFile\n  L.CompletionItemKind_Reference -> CIKReference\n  L.CompletionItemKind_Folder -> CIKFolder\n  L.CompletionItemKind_EnumMember -> CIKEnumMember\n  L.CompletionItemKind_Constant -> CIKConstant\n  L.CompletionItemKind_Struct -> CIKStruct\n  L.CompletionItemKind_Event -> CIKEvent\n  L.CompletionItemKind_Operator -> CIKOperator\n  L.CompletionItemKind_TypeParameter -> CIKTypeParameter\n\n-- Result type is [SymbolInformation] |? ([WorkspaceSymbol] |? Null)\n", "criteria": "CRITERIA_0562", "selected": "SELECTED_0562", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCompletionItemKind", "range": {"end": {"character": 22, "line": 431}, "start": {"character": 0, "line": 431}}}
{"example_id": "0563", "variation": "negative_1", "code": "fromCompletionItemKind k = case k of\n  L.CompletionItemKind_Text -> CIKText\n  L.CompletionItemKind_Method -> CIKMethod\n  L.CompletionItemKind_Function -> CIKFunction\n  L.CompletionItemKind_Constructor -> CIKConstructor\n  L.CompletionItemKind_Field -> CIKField\n  L.CompletionItemKind_Variable -> CIKVariable\n  L.CompletionItemKind_Class -> CIKClass\n  L.CompletionItemKind_Interface -> CIKInterface\n  L.CompletionItemKind_Module -> CIKModule\n  L.CompletionItemKind_Property -> CIKProperty\n  L.CompletionItemKind_Unit -> CIKUnit\n  L.CompletionItemKind_Value -> CIKValue\n  L.CompletionItemKind_Enum -> CIKEnum\n  L.CompletionItemKind_Keyword -> CIKKeyword\n  L.CompletionItemKind_Snippet -> CIKSnippet\n  L.CompletionItemKind_Color -> CIKColor\n  L.CompletionItemKind_File -> CIKFile\n  L.CompletionItemKind_Reference -> CIKReference\n  L.CompletionItemKind_Folder -> CIKFolder\n  L.CompletionItemKind_EnumMember -> CIKEnumMember\n  L.CompletionItemKind_Constant -> CIKConstant\n  L.CompletionItemKind_Struct -> CIKStruct\n  L.CompletionItemKind_Event -> CIKEvent\n  L.CompletionItemKind_Operator -> CIKOperator\n  L.CompletionItemKind_TypeParameter -> CIKTypeParameter\n\n-- Result type is [SymbolInformation] |? ([WorkspaceSymbol] |? Null)\n", "criteria": "CRITERIA_0563", "selected": "SELECTED_0563", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCompletionItemKind", "range": {"end": {"character": 22, "line": 431}, "start": {"character": 0, "line": 431}}}
{"example_id": "0564", "variation": "negative_2", "code": "fromCompletionItemKind k = case k of\n  L.CompletionItemKind_Text -> CIKText\n  L.CompletionItemKind_Method -> CIKMethod\n  L.CompletionItemKind_Function -> CIKFunction\n  L.CompletionItemKind_Constructor -> CIKConstructor\n  L.CompletionItemKind_Field -> CIKField\n  L.CompletionItemKind_Variable -> CIKVariable\n  L.CompletionItemKind_Class -> CIKClass\n  L.CompletionItemKind_Interface -> CIKInterface\n  L.CompletionItemKind_Module -> CIKModule\n  L.CompletionItemKind_Property -> CIKProperty\n  L.CompletionItemKind_Unit -> CIKUnit\n  L.CompletionItemKind_Value -> CIKValue\n  L.CompletionItemKind_Enum -> CIKEnum\n  L.CompletionItemKind_Keyword -> CIKKeyword\n  L.CompletionItemKind_Snippet -> CIKSnippet\n  L.CompletionItemKind_Color -> CIKColor\n  L.CompletionItemKind_File -> CIKFile\n  L.CompletionItemKind_Reference -> CIKReference\n  L.CompletionItemKind_Folder -> CIKFolder\n  L.CompletionItemKind_EnumMember -> CIKEnumMember\n  L.CompletionItemKind_Constant -> CIKConstant\n  L.CompletionItemKind_Struct -> CIKStruct\n  L.CompletionItemKind_Event -> CIKEvent\n  L.CompletionItemKind_Operator -> CIKOperator\n  L.CompletionItemKind_TypeParameter -> CIKTypeParameter\n\n-- Result type is [SymbolInformation] |? ([WorkspaceSymbol] |? Null)\n", "criteria": "CRITERIA_0564", "selected": "SELECTED_0564", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromCompletionItemKind", "range": {"end": {"character": 22, "line": 431}, "start": {"character": 0, "line": 431}}}
{"example_id": "0565", "variation": "positive_structure", "code": "fromSymbolsResult result = case result of\n  L.InL infos -> map fromSymbolInfo infos\n  L.InR wsOrNull -> case wsOrNull of\n    L.InL wsSymbols -> map fromWorkspaceSymbol wsSymbols\n    L.InR L.Null -> []\n\n", "criteria": "CRITERIA_0565", "selected": "SELECTED_0565", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolsResult", "range": {"end": {"character": 17, "line": 460}, "start": {"character": 0, "line": 460}}}
{"example_id": "0566", "variation": "positive_semantic", "code": "fromSymbolsResult result = case result of\n  L.InL infos -> map fromSymbolInfo infos\n  L.InR wsOrNull -> case wsOrNull of\n    L.InL wsSymbols -> map fromWorkspaceSymbol wsSymbols\n    L.InR L.Null -> []\n\n", "criteria": "CRITERIA_0566", "selected": "SELECTED_0566", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolsResult", "range": {"end": {"character": 17, "line": 460}, "start": {"character": 0, "line": 460}}}
{"example_id": "0567", "variation": "negative_1", "code": "fromSymbolsResult result = case result of\n  L.InL infos -> map fromSymbolInfo infos\n  L.InR wsOrNull -> case wsOrNull of\n    L.InL wsSymbols -> map fromWorkspaceSymbol wsSymbols\n    L.InR L.Null -> []\n\n", "criteria": "CRITERIA_0567", "selected": "SELECTED_0567", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolsResult", "range": {"end": {"character": 17, "line": 460}, "start": {"character": 0, "line": 460}}}
{"example_id": "0568", "variation": "negative_2", "code": "fromSymbolsResult result = case result of\n  L.InL infos -> map fromSymbolInfo infos\n  L.InR wsOrNull -> case wsOrNull of\n    L.InL wsSymbols -> map fromWorkspaceSymbol wsSymbols\n    L.InR L.Null -> []\n\n", "criteria": "CRITERIA_0568", "selected": "SELECTED_0568", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolsResult", "range": {"end": {"character": 17, "line": 460}, "start": {"character": 0, "line": 460}}}
{"example_id": "0569", "variation": "positive_structure", "code": "fromSymbolInfo si = SymbolInformation\n  { siName = si._name\n  , siKind = fromSymbolKind si._kind\n  , siLocation = fromLocation si._location\n  , siContainer = si._containerName\n  }\n\n", "criteria": "CRITERIA_0569", "selected": "SELECTED_0569", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolInfo", "range": {"end": {"character": 14, "line": 467}, "start": {"character": 0, "line": 467}}}
{"example_id": "0570", "variation": "positive_semantic", "code": "fromSymbolInfo si = SymbolInformation\n  { siName = si._name\n  , siKind = fromSymbolKind si._kind\n  , siLocation = fromLocation si._location\n  , siContainer = si._containerName\n  }\n\n", "criteria": "CRITERIA_0570", "selected": "SELECTED_0570", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolInfo", "range": {"end": {"character": 14, "line": 467}, "start": {"character": 0, "line": 467}}}
{"example_id": "0571", "variation": "negative_1", "code": "fromSymbolInfo si = SymbolInformation\n  { siName = si._name\n  , siKind = fromSymbolKind si._kind\n  , siLocation = fromLocation si._location\n  , siContainer = si._containerName\n  }\n\n", "criteria": "CRITERIA_0571", "selected": "SELECTED_0571", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolInfo", "range": {"end": {"character": 14, "line": 467}, "start": {"character": 0, "line": 467}}}
{"example_id": "0572", "variation": "negative_2", "code": "fromSymbolInfo si = SymbolInformation\n  { siName = si._name\n  , siKind = fromSymbolKind si._kind\n  , siLocation = fromLocation si._location\n  , siContainer = si._containerName\n  }\n\n", "criteria": "CRITERIA_0572", "selected": "SELECTED_0572", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolInfo", "range": {"end": {"character": 14, "line": 467}, "start": {"character": 0, "line": 467}}}
{"example_id": "0573", "variation": "positive_structure", "code": "fromWorkspaceSymbol ws = SymbolInformation\n  { siName = ws._name\n  , siKind = fromSymbolKind ws._kind\n  , siLocation = extractLocationFromWS ws._location\n  , siContainer = ws._containerName\n  }\n\n", "criteria": "CRITERIA_0573", "selected": "SELECTED_0573", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceSymbol", "range": {"end": {"character": 19, "line": 475}, "start": {"character": 0, "line": 475}}}
{"example_id": "0574", "variation": "positive_semantic", "code": "fromWorkspaceSymbol ws = SymbolInformation\n  { siName = ws._name\n  , siKind = fromSymbolKind ws._kind\n  , siLocation = extractLocationFromWS ws._location\n  , siContainer = ws._containerName\n  }\n\n", "criteria": "CRITERIA_0574", "selected": "SELECTED_0574", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceSymbol", "range": {"end": {"character": 19, "line": 475}, "start": {"character": 0, "line": 475}}}
{"example_id": "0575", "variation": "negative_1", "code": "fromWorkspaceSymbol ws = SymbolInformation\n  { siName = ws._name\n  , siKind = fromSymbolKind ws._kind\n  , siLocation = extractLocationFromWS ws._location\n  , siContainer = ws._containerName\n  }\n\n", "criteria": "CRITERIA_0575", "selected": "SELECTED_0575", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceSymbol", "range": {"end": {"character": 19, "line": 475}, "start": {"character": 0, "line": 475}}}
{"example_id": "0576", "variation": "negative_2", "code": "fromWorkspaceSymbol ws = SymbolInformation\n  { siName = ws._name\n  , siKind = fromSymbolKind ws._kind\n  , siLocation = extractLocationFromWS ws._location\n  , siContainer = ws._containerName\n  }\n\n", "criteria": "CRITERIA_0576", "selected": "SELECTED_0576", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromWorkspaceSymbol", "range": {"end": {"character": 19, "line": 475}, "start": {"character": 0, "line": 475}}}
{"example_id": "0577", "variation": "positive_structure", "code": "fromSymbolKind k = case k of\n  L.SymbolKind_File -> SKFile\n  L.SymbolKind_Module -> SKModule\n  L.SymbolKind_Namespace -> SKNamespace\n  L.SymbolKind_Package -> SKPackage\n  L.SymbolKind_Class -> SKClass\n  L.SymbolKind_Method -> SKMethod\n  L.SymbolKind_Property -> SKProperty\n  L.SymbolKind_Field -> SKField\n  L.SymbolKind_Constructor -> SKConstructor\n  L.SymbolKind_Enum -> SKEnum\n  L.SymbolKind_Interface -> SKInterface\n  L.SymbolKind_Function -> SKFunction\n  L.SymbolKind_Variable -> SKVariable\n  L.SymbolKind_Constant -> SKConstant\n  L.SymbolKind_String -> SKString\n  L.SymbolKind_Number -> SKNumber\n  L.SymbolKind_Boolean -> SKBoolean\n  L.SymbolKind_Array -> SKArray\n  L.SymbolKind_Object -> SKObject\n  L.SymbolKind_Key -> SKKey\n  L.SymbolKind_Null -> SKNull\n  L.SymbolKind_EnumMember -> SKEnumMember\n  L.SymbolKind_Struct -> SKStruct\n  L.SymbolKind_Event -> SKEvent\n  L.SymbolKind_Operator -> SKOperator\n  L.SymbolKind_TypeParameter -> SKTypeParameter\n\n-- Result type is [SymbolInformation] |? ([DocumentSymbol] |? Null)\n", "criteria": "CRITERIA_0577", "selected": "SELECTED_0577", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolKind", "range": {"end": {"character": 14, "line": 491}, "start": {"character": 0, "line": 491}}}
{"example_id": "0578", "variation": "positive_semantic", "code": "fromSymbolKind k = case k of\n  L.SymbolKind_File -> SKFile\n  L.SymbolKind_Module -> SKModule\n  L.SymbolKind_Namespace -> SKNamespace\n  L.SymbolKind_Package -> SKPackage\n  L.SymbolKind_Class -> SKClass\n  L.SymbolKind_Method -> SKMethod\n  L.SymbolKind_Property -> SKProperty\n  L.SymbolKind_Field -> SKField\n  L.SymbolKind_Constructor -> SKConstructor\n  L.SymbolKind_Enum -> SKEnum\n  L.SymbolKind_Interface -> SKInterface\n  L.SymbolKind_Function -> SKFunction\n  L.SymbolKind_Variable -> SKVariable\n  L.SymbolKind_Constant -> SKConstant\n  L.SymbolKind_String -> SKString\n  L.SymbolKind_Number -> SKNumber\n  L.SymbolKind_Boolean -> SKBoolean\n  L.SymbolKind_Array -> SKArray\n  L.SymbolKind_Object -> SKObject\n  L.SymbolKind_Key -> SKKey\n  L.SymbolKind_Null -> SKNull\n  L.SymbolKind_EnumMember -> SKEnumMember\n  L.SymbolKind_Struct -> SKStruct\n  L.SymbolKind_Event -> SKEvent\n  L.SymbolKind_Operator -> SKOperator\n  L.SymbolKind_TypeParameter -> SKTypeParameter\n\n-- Result type is [SymbolInformation] |? ([DocumentSymbol] |? Null)\n", "criteria": "CRITERIA_0578", "selected": "SELECTED_0578", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolKind", "range": {"end": {"character": 14, "line": 491}, "start": {"character": 0, "line": 491}}}
{"example_id": "0579", "variation": "negative_1", "code": "fromSymbolKind k = case k of\n  L.SymbolKind_File -> SKFile\n  L.SymbolKind_Module -> SKModule\n  L.SymbolKind_Namespace -> SKNamespace\n  L.SymbolKind_Package -> SKPackage\n  L.SymbolKind_Class -> SKClass\n  L.SymbolKind_Method -> SKMethod\n  L.SymbolKind_Property -> SKProperty\n  L.SymbolKind_Field -> SKField\n  L.SymbolKind_Constructor -> SKConstructor\n  L.SymbolKind_Enum -> SKEnum\n  L.SymbolKind_Interface -> SKInterface\n  L.SymbolKind_Function -> SKFunction\n  L.SymbolKind_Variable -> SKVariable\n  L.SymbolKind_Constant -> SKConstant\n  L.SymbolKind_String -> SKString\n  L.SymbolKind_Number -> SKNumber\n  L.SymbolKind_Boolean -> SKBoolean\n  L.SymbolKind_Array -> SKArray\n  L.SymbolKind_Object -> SKObject\n  L.SymbolKind_Key -> SKKey\n  L.SymbolKind_Null -> SKNull\n  L.SymbolKind_EnumMember -> SKEnumMember\n  L.SymbolKind_Struct -> SKStruct\n  L.SymbolKind_Event -> SKEvent\n  L.SymbolKind_Operator -> SKOperator\n  L.SymbolKind_TypeParameter -> SKTypeParameter\n\n-- Result type is [SymbolInformation] |? ([DocumentSymbol] |? Null)\n", "criteria": "CRITERIA_0579", "selected": "SELECTED_0579", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolKind", "range": {"end": {"character": 14, "line": 491}, "start": {"character": 0, "line": 491}}}
{"example_id": "0580", "variation": "negative_2", "code": "fromSymbolKind k = case k of\n  L.SymbolKind_File -> SKFile\n  L.SymbolKind_Module -> SKModule\n  L.SymbolKind_Namespace -> SKNamespace\n  L.SymbolKind_Package -> SKPackage\n  L.SymbolKind_Class -> SKClass\n  L.SymbolKind_Method -> SKMethod\n  L.SymbolKind_Property -> SKProperty\n  L.SymbolKind_Field -> SKField\n  L.SymbolKind_Constructor -> SKConstructor\n  L.SymbolKind_Enum -> SKEnum\n  L.SymbolKind_Interface -> SKInterface\n  L.SymbolKind_Function -> SKFunction\n  L.SymbolKind_Variable -> SKVariable\n  L.SymbolKind_Constant -> SKConstant\n  L.SymbolKind_String -> SKString\n  L.SymbolKind_Number -> SKNumber\n  L.SymbolKind_Boolean -> SKBoolean\n  L.SymbolKind_Array -> SKArray\n  L.SymbolKind_Object -> SKObject\n  L.SymbolKind_Key -> SKKey\n  L.SymbolKind_Null -> SKNull\n  L.SymbolKind_EnumMember -> SKEnumMember\n  L.SymbolKind_Struct -> SKStruct\n  L.SymbolKind_Event -> SKEvent\n  L.SymbolKind_Operator -> SKOperator\n  L.SymbolKind_TypeParameter -> SKTypeParameter\n\n-- Result type is [SymbolInformation] |? ([DocumentSymbol] |? Null)\n", "criteria": "CRITERIA_0580", "selected": "SELECTED_0580", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "fromSymbolKind", "range": {"end": {"character": 14, "line": 491}, "start": {"character": 0, "line": 491}}}
{"example_id": "0581", "variation": "positive_structure", "code": "getMem = Freer.send GetMem\n\n-- | Update the memory state.\n", "criteria": "CRITERIA_0581", "selected": "SELECTED_0581", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "getMem", "range": {"end": {"character": 6, "line": 233}, "start": {"character": 0, "line": 233}}}
{"example_id": "0582", "variation": "positive_semantic", "code": "getMem = Freer.send GetMem\n\n-- | Update the memory state.\n", "criteria": "CRITERIA_0582", "selected": "SELECTED_0582", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "getMem", "range": {"end": {"character": 6, "line": 233}, "start": {"character": 0, "line": 233}}}
{"example_id": "0583", "variation": "negative_1", "code": "getMem = Freer.send GetMem\n\n-- | Update the memory state.\n", "criteria": "CRITERIA_0583", "selected": "SELECTED_0583", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "getMem", "range": {"end": {"character": 6, "line": 233}, "start": {"character": 0, "line": 233}}}
{"example_id": "0584", "variation": "negative_2", "code": "getMem = Freer.send GetMem\n\n-- | Update the memory state.\n", "criteria": "CRITERIA_0584", "selected": "SELECTED_0584", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "getMem", "range": {"end": {"character": 6, "line": 233}, "start": {"character": 0, "line": 233}}}
{"example_id": "0585", "variation": "positive_structure", "code": "getMem = send GetMem\n\n-- | Update memory by applying a function to the current state.\n--\n-- Uses a function rather than a setter to prevent update conflicts:\n--\n-- @\n-- -- Good: sees current state\n-- updateMem \\@Counter (+ 1)\n--\n-- -- Risky pattern (if we had set):\n-- -- x <- getMem\n-- -- setMem (x + 1)  -- Could clobber concurrent updates!\n-- @\n", "criteria": "CRITERIA_0585", "selected": "SELECTED_0585", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "getMem", "range": {"end": {"character": 6, "line": 134}, "start": {"character": 0, "line": 134}}}
{"example_id": "0586", "variation": "positive_semantic", "code": "getMem = send GetMem\n\n-- | Update memory by applying a function to the current state.\n--\n-- Uses a function rather than a setter to prevent update conflicts:\n--\n-- @\n-- -- Good: sees current state\n-- updateMem \\@Counter (+ 1)\n--\n-- -- Risky pattern (if we had set):\n-- -- x <- getMem\n-- -- setMem (x + 1)  -- Could clobber concurrent updates!\n-- @\n", "criteria": "CRITERIA_0586", "selected": "SELECTED_0586", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "getMem", "range": {"end": {"character": 6, "line": 134}, "start": {"character": 0, "line": 134}}}
{"example_id": "0587", "variation": "negative_1", "code": "getMem = send GetMem\n\n-- | Update memory by applying a function to the current state.\n--\n-- Uses a function rather than a setter to prevent update conflicts:\n--\n-- @\n-- -- Good: sees current state\n-- updateMem \\@Counter (+ 1)\n--\n-- -- Risky pattern (if we had set):\n-- -- x <- getMem\n-- -- setMem (x + 1)  -- Could clobber concurrent updates!\n-- @\n", "criteria": "CRITERIA_0587", "selected": "SELECTED_0587", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "getMem", "range": {"end": {"character": 6, "line": 134}, "start": {"character": 0, "line": 134}}}
{"example_id": "0588", "variation": "negative_2", "code": "getMem = send GetMem\n\n-- | Update memory by applying a function to the current state.\n--\n-- Uses a function rather than a setter to prevent update conflicts:\n--\n-- @\n-- -- Good: sees current state\n-- updateMem \\@Counter (+ 1)\n--\n-- -- Risky pattern (if we had set):\n-- -- x <- getMem\n-- -- setMem (x + 1)  -- Could clobber concurrent updates!\n-- @\n", "criteria": "CRITERIA_0588", "selected": "SELECTED_0588", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "getMem", "range": {"end": {"character": 6, "line": 134}, "start": {"character": 0, "line": 134}}}
{"example_id": "0589", "variation": "positive_structure", "code": "getApiKey (ApiKey t) = t\n\n-- | Type-safe wrapper for API base URLs.\n--\n-- Prevents accidental confusion between URLs and other credentials.\n", "criteria": "CRITERIA_0589", "selected": "SELECTED_0589", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "getApiKey", "range": {"end": {"character": 9, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0590", "variation": "positive_semantic", "code": "getApiKey (ApiKey t) = t\n\n-- | Type-safe wrapper for API base URLs.\n--\n-- Prevents accidental confusion between URLs and other credentials.\n", "criteria": "CRITERIA_0590", "selected": "SELECTED_0590", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "getApiKey", "range": {"end": {"character": 9, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0591", "variation": "negative_1", "code": "getApiKey (ApiKey t) = t\n\n-- | Type-safe wrapper for API base URLs.\n--\n-- Prevents accidental confusion between URLs and other credentials.\n", "criteria": "CRITERIA_0591", "selected": "SELECTED_0591", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "getApiKey", "range": {"end": {"character": 9, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0592", "variation": "negative_2", "code": "getApiKey (ApiKey t) = t\n\n-- | Type-safe wrapper for API base URLs.\n--\n-- Prevents accidental confusion between URLs and other credentials.\n", "criteria": "CRITERIA_0592", "selected": "SELECTED_0592", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "getApiKey", "range": {"end": {"character": 9, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0593", "variation": "positive_structure", "code": "getBaseUrl (BaseUrl t) = t\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONFIGURATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | LLM API configuration with secrets for both providers.\n", "criteria": "CRITERIA_0593", "selected": "SELECTED_0593", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "getBaseUrl", "range": {"end": {"character": 10, "line": 95}, "start": {"character": 0, "line": 95}}}
{"example_id": "0594", "variation": "positive_semantic", "code": "getBaseUrl (BaseUrl t) = t\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONFIGURATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | LLM API configuration with secrets for both providers.\n", "criteria": "CRITERIA_0594", "selected": "SELECTED_0594", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "getBaseUrl", "range": {"end": {"character": 10, "line": 95}, "start": {"character": 0, "line": 95}}}
{"example_id": "0595", "variation": "negative_1", "code": "getBaseUrl (BaseUrl t) = t\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONFIGURATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | LLM API configuration with secrets for both providers.\n", "criteria": "CRITERIA_0595", "selected": "SELECTED_0595", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "getBaseUrl", "range": {"end": {"character": 10, "line": 95}, "start": {"character": 0, "line": 95}}}
{"example_id": "0596", "variation": "negative_2", "code": "getBaseUrl (BaseUrl t) = t\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONFIGURATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | LLM API configuration with secrets for both providers.\n", "criteria": "CRITERIA_0596", "selected": "SELECTED_0596", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/llm-interpreter/src/Tidepool/LLM/Types.hs", "name": "getBaseUrl", "range": {"end": {"character": 10, "line": 95}, "start": {"character": 0, "line": 95}}}
{"example_id": "0597", "variation": "positive_structure", "code": "getCompletedResults acc key = do\n  partials <- readTVarIO (acc.maPartials)\n  case HM.lookup key partials of\n    Nothing -> pure Nothing\n    Just partial -> do\n      let slots = extractSlots (partial.pmSlots)\n      pure $ Just $ extractMergeResults @sources slots\n  where\n    extractSlots :: HashMap Text MergeSlot -> HashMap Text Value\n    extractSlots = HM.mapMaybe $ \\case\n      SlotEmpty -> Nothing\n      SlotFilled v -> Just v\n", "criteria": "CRITERIA_0597", "selected": "SELECTED_0597", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Merge.hs", "name": "getCompletedResults", "range": {"end": {"character": 19, "line": 245}, "start": {"character": 0, "line": 245}}}
{"example_id": "0598", "variation": "positive_semantic", "code": "getCompletedResults acc key = do\n  partials <- readTVarIO (acc.maPartials)\n  case HM.lookup key partials of\n    Nothing -> pure Nothing\n    Just partial -> do\n      let slots = extractSlots (partial.pmSlots)\n      pure $ Just $ extractMergeResults @sources slots\n  where\n    extractSlots :: HashMap Text MergeSlot -> HashMap Text Value\n    extractSlots = HM.mapMaybe $ \\case\n      SlotEmpty -> Nothing\n      SlotFilled v -> Just v\n", "criteria": "CRITERIA_0598", "selected": "SELECTED_0598", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Merge.hs", "name": "getCompletedResults", "range": {"end": {"character": 19, "line": 245}, "start": {"character": 0, "line": 245}}}
{"example_id": "0599", "variation": "negative_1", "code": "getCompletedResults acc key = do\n  partials <- readTVarIO (acc.maPartials)\n  case HM.lookup key partials of\n    Nothing -> pure Nothing\n    Just partial -> do\n      let slots = extractSlots (partial.pmSlots)\n      pure $ Just $ extractMergeResults @sources slots\n  where\n    extractSlots :: HashMap Text MergeSlot -> HashMap Text Value\n    extractSlots = HM.mapMaybe $ \\case\n      SlotEmpty -> Nothing\n      SlotFilled v -> Just v\n", "criteria": "CRITERIA_0599", "selected": "SELECTED_0599", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Merge.hs", "name": "getCompletedResults", "range": {"end": {"character": 19, "line": 245}, "start": {"character": 0, "line": 245}}}
{"example_id": "0600", "variation": "negative_2", "code": "getCompletedResults acc key = do\n  partials <- readTVarIO (acc.maPartials)\n  case HM.lookup key partials of\n    Nothing -> pure Nothing\n    Just partial -> do\n      let slots = extractSlots (partial.pmSlots)\n      pure $ Just $ extractMergeResults @sources slots\n  where\n    extractSlots :: HashMap Text MergeSlot -> HashMap Text Value\n    extractSlots = HM.mapMaybe $ \\case\n      SlotEmpty -> Nothing\n      SlotFilled v -> Just v\n", "criteria": "CRITERIA_0600", "selected": "SELECTED_0600", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Merge.hs", "name": "getCompletedResults", "range": {"end": {"character": 19, "line": 245}, "start": {"character": 0, "line": 245}}}
{"example_id": "0601", "variation": "positive_structure", "code": "getCurrentBranch = send GetCurrentBranch\n", "criteria": "CRITERIA_0601", "selected": "SELECTED_0601", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getCurrentBranch", "range": {"end": {"character": 16, "line": 113}, "start": {"character": 0, "line": 113}}}
{"example_id": "0602", "variation": "positive_semantic", "code": "getCurrentBranch = send GetCurrentBranch\n", "criteria": "CRITERIA_0602", "selected": "SELECTED_0602", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getCurrentBranch", "range": {"end": {"character": 16, "line": 113}, "start": {"character": 0, "line": 113}}}
{"example_id": "0603", "variation": "negative_1", "code": "getCurrentBranch = send GetCurrentBranch\n", "criteria": "CRITERIA_0603", "selected": "SELECTED_0603", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getCurrentBranch", "range": {"end": {"character": 16, "line": 113}, "start": {"character": 0, "line": 113}}}
{"example_id": "0604", "variation": "negative_2", "code": "getCurrentBranch = send GetCurrentBranch\n", "criteria": "CRITERIA_0604", "selected": "SELECTED_0604", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getCurrentBranch", "range": {"end": {"character": 16, "line": 113}, "start": {"character": 0, "line": 113}}}
{"example_id": "0605", "variation": "positive_structure", "code": "getDirtyFiles = send GetDirtyFiles\n\n-- | Get recent commit subjects.\n", "criteria": "CRITERIA_0605", "selected": "SELECTED_0605", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getDirtyFiles", "range": {"end": {"character": 13, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0606", "variation": "positive_semantic", "code": "getDirtyFiles = send GetDirtyFiles\n\n-- | Get recent commit subjects.\n", "criteria": "CRITERIA_0606", "selected": "SELECTED_0606", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getDirtyFiles", "range": {"end": {"character": 13, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0607", "variation": "negative_1", "code": "getDirtyFiles = send GetDirtyFiles\n\n-- | Get recent commit subjects.\n", "criteria": "CRITERIA_0607", "selected": "SELECTED_0607", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getDirtyFiles", "range": {"end": {"character": 13, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0608", "variation": "negative_2", "code": "getDirtyFiles = send GetDirtyFiles\n\n-- | Get recent commit subjects.\n", "criteria": "CRITERIA_0608", "selected": "SELECTED_0608", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getDirtyFiles", "range": {"end": {"character": 13, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0609", "variation": "positive_structure", "code": "getRecentCommits = send . GetRecentCommits\n\n-- | Get current branch name.\n", "criteria": "CRITERIA_0609", "selected": "SELECTED_0609", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getRecentCommits", "range": {"end": {"character": 16, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0610", "variation": "positive_semantic", "code": "getRecentCommits = send . GetRecentCommits\n\n-- | Get current branch name.\n", "criteria": "CRITERIA_0610", "selected": "SELECTED_0610", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getRecentCommits", "range": {"end": {"character": 16, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0611", "variation": "negative_1", "code": "getRecentCommits = send . GetRecentCommits\n\n-- | Get current branch name.\n", "criteria": "CRITERIA_0611", "selected": "SELECTED_0611", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getRecentCommits", "range": {"end": {"character": 16, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0612", "variation": "negative_2", "code": "getRecentCommits = send . GetRecentCommits\n\n-- | Get current branch name.\n", "criteria": "CRITERIA_0612", "selected": "SELECTED_0612", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getRecentCommits", "range": {"end": {"character": 16, "line": 109}, "start": {"character": 0, "line": 109}}}
{"example_id": "0613", "variation": "positive_structure", "code": "getWorktreeInfo = send GetWorktreeInfo\n\n-- | Get list of dirty files.\n", "criteria": "CRITERIA_0613", "selected": "SELECTED_0613", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getWorktreeInfo", "range": {"end": {"character": 15, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0614", "variation": "positive_semantic", "code": "getWorktreeInfo = send GetWorktreeInfo\n\n-- | Get list of dirty files.\n", "criteria": "CRITERIA_0614", "selected": "SELECTED_0614", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getWorktreeInfo", "range": {"end": {"character": 15, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0615", "variation": "negative_1", "code": "getWorktreeInfo = send GetWorktreeInfo\n\n-- | Get list of dirty files.\n", "criteria": "CRITERIA_0615", "selected": "SELECTED_0615", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getWorktreeInfo", "range": {"end": {"character": 15, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0616", "variation": "negative_2", "code": "getWorktreeInfo = send GetWorktreeInfo\n\n-- | Get list of dirty files.\n", "criteria": "CRITERIA_0616", "selected": "SELECTED_0616", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Git.hs", "name": "getWorktreeInfo", "range": {"end": {"character": 15, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0617", "variation": "positive_structure", "code": "getBead = send . GetBead\n\n-- | Get dependencies (beads this one depends on).\n", "criteria": "CRITERIA_0617", "selected": "SELECTED_0617", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getBead", "range": {"end": {"character": 7, "line": 373}, "start": {"character": 0, "line": 373}}}
{"example_id": "0618", "variation": "positive_semantic", "code": "getBead = send . GetBead\n\n-- | Get dependencies (beads this one depends on).\n", "criteria": "CRITERIA_0618", "selected": "SELECTED_0618", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getBead", "range": {"end": {"character": 7, "line": 373}, "start": {"character": 0, "line": 373}}}
{"example_id": "0619", "variation": "negative_1", "code": "getBead = send . GetBead\n\n-- | Get dependencies (beads this one depends on).\n", "criteria": "CRITERIA_0619", "selected": "SELECTED_0619", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getBead", "range": {"end": {"character": 7, "line": 373}, "start": {"character": 0, "line": 373}}}
{"example_id": "0620", "variation": "negative_2", "code": "getBead = send . GetBead\n\n-- | Get dependencies (beads this one depends on).\n", "criteria": "CRITERIA_0620", "selected": "SELECTED_0620", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getBead", "range": {"end": {"character": 7, "line": 373}, "start": {"character": 0, "line": 373}}}
{"example_id": "0621", "variation": "positive_structure", "code": "getBlocking = send . GetBlocking\n\n-- | Get labels for a bead.\n", "criteria": "CRITERIA_0621", "selected": "SELECTED_0621", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getBlocking", "range": {"end": {"character": 11, "line": 381}, "start": {"character": 0, "line": 381}}}
{"example_id": "0622", "variation": "positive_semantic", "code": "getBlocking = send . GetBlocking\n\n-- | Get labels for a bead.\n", "criteria": "CRITERIA_0622", "selected": "SELECTED_0622", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getBlocking", "range": {"end": {"character": 11, "line": 381}, "start": {"character": 0, "line": 381}}}
{"example_id": "0623", "variation": "negative_1", "code": "getBlocking = send . GetBlocking\n\n-- | Get labels for a bead.\n", "criteria": "CRITERIA_0623", "selected": "SELECTED_0623", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getBlocking", "range": {"end": {"character": 11, "line": 381}, "start": {"character": 0, "line": 381}}}
{"example_id": "0624", "variation": "negative_2", "code": "getBlocking = send . GetBlocking\n\n-- | Get labels for a bead.\n", "criteria": "CRITERIA_0624", "selected": "SELECTED_0624", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getBlocking", "range": {"end": {"character": 11, "line": 381}, "start": {"character": 0, "line": 381}}}
{"example_id": "0625", "variation": "positive_structure", "code": "getChildren = send . GetChildren\n\n-- | List beads by status.\n", "criteria": "CRITERIA_0625", "selected": "SELECTED_0625", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getChildren", "range": {"end": {"character": 11, "line": 389}, "start": {"character": 0, "line": 389}}}
{"example_id": "0626", "variation": "positive_semantic", "code": "getChildren = send . GetChildren\n\n-- | List beads by status.\n", "criteria": "CRITERIA_0626", "selected": "SELECTED_0626", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getChildren", "range": {"end": {"character": 11, "line": 389}, "start": {"character": 0, "line": 389}}}
{"example_id": "0627", "variation": "negative_1", "code": "getChildren = send . GetChildren\n\n-- | List beads by status.\n", "criteria": "CRITERIA_0627", "selected": "SELECTED_0627", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getChildren", "range": {"end": {"character": 11, "line": 389}, "start": {"character": 0, "line": 389}}}
{"example_id": "0628", "variation": "negative_2", "code": "getChildren = send . GetChildren\n\n-- | List beads by status.\n", "criteria": "CRITERIA_0628", "selected": "SELECTED_0628", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getChildren", "range": {"end": {"character": 11, "line": 389}, "start": {"character": 0, "line": 389}}}
{"example_id": "0629", "variation": "positive_structure", "code": "getDeps = send . GetDeps\n\n-- | Get blocking beads (beads this one is blocking).\n", "criteria": "CRITERIA_0629", "selected": "SELECTED_0629", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getDeps", "range": {"end": {"character": 7, "line": 377}, "start": {"character": 0, "line": 377}}}
{"example_id": "0630", "variation": "positive_semantic", "code": "getDeps = send . GetDeps\n\n-- | Get blocking beads (beads this one is blocking).\n", "criteria": "CRITERIA_0630", "selected": "SELECTED_0630", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getDeps", "range": {"end": {"character": 7, "line": 377}, "start": {"character": 0, "line": 377}}}
{"example_id": "0631", "variation": "negative_1", "code": "getDeps = send . GetDeps\n\n-- | Get blocking beads (beads this one is blocking).\n", "criteria": "CRITERIA_0631", "selected": "SELECTED_0631", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getDeps", "range": {"end": {"character": 7, "line": 377}, "start": {"character": 0, "line": 377}}}
{"example_id": "0632", "variation": "negative_2", "code": "getDeps = send . GetDeps\n\n-- | Get blocking beads (beads this one is blocking).\n", "criteria": "CRITERIA_0632", "selected": "SELECTED_0632", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getDeps", "range": {"end": {"character": 7, "line": 377}, "start": {"character": 0, "line": 377}}}
{"example_id": "0633", "variation": "positive_structure", "code": "getLabels = send . GetLabels\n\n-- | Get child beads (beads with this as parent).\n", "criteria": "CRITERIA_0633", "selected": "SELECTED_0633", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getLabels", "range": {"end": {"character": 9, "line": 385}, "start": {"character": 0, "line": 385}}}
{"example_id": "0634", "variation": "positive_semantic", "code": "getLabels = send . GetLabels\n\n-- | Get child beads (beads with this as parent).\n", "criteria": "CRITERIA_0634", "selected": "SELECTED_0634", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getLabels", "range": {"end": {"character": 9, "line": 385}, "start": {"character": 0, "line": 385}}}
{"example_id": "0635", "variation": "negative_1", "code": "getLabels = send . GetLabels\n\n-- | Get child beads (beads with this as parent).\n", "criteria": "CRITERIA_0635", "selected": "SELECTED_0635", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getLabels", "range": {"end": {"character": 9, "line": 385}, "start": {"character": 0, "line": 385}}}
{"example_id": "0636", "variation": "negative_2", "code": "getLabels = send . GetLabels\n\n-- | Get child beads (beads with this as parent).\n", "criteria": "CRITERIA_0636", "selected": "SELECTED_0636", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "getLabels", "range": {"end": {"character": 9, "line": 385}, "start": {"character": 0, "line": 385}}}
{"example_id": "0637", "variation": "positive_structure", "code": "getEntry = send (GetEntry :: GraphContext entry entry)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- NODE INPUT EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Effect for reading the current node's input value.\n--\n-- Type parameters:\n--   * @input@ - the input type for this node (e.g., ImplInput)\n--\n-- This enables after-handlers to access the node's input without\n-- storing it in Memory. The input is injected by the dispatcher\n-- when calling the handler.\n--\n-- Key differences from GraphContext:\n--   * GraphContext: same value for entire graph lifetime\n--   * NodeInput: changes per node invocation (each node has different input type)\n--\n-- The type parameter varies per call site - when dispatching to \"impl\",\n-- the interpreter uses @runNodeInput \\@ImplInput implInput@.\n", "criteria": "CRITERIA_0637", "selected": "SELECTED_0637", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "getEntry", "range": {"end": {"character": 8, "line": 104}, "start": {"character": 0, "line": 104}}}
{"example_id": "0638", "variation": "positive_semantic", "code": "getEntry = send (GetEntry :: GraphContext entry entry)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- NODE INPUT EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Effect for reading the current node's input value.\n--\n-- Type parameters:\n--   * @input@ - the input type for this node (e.g., ImplInput)\n--\n-- This enables after-handlers to access the node's input without\n-- storing it in Memory. The input is injected by the dispatcher\n-- when calling the handler.\n--\n-- Key differences from GraphContext:\n--   * GraphContext: same value for entire graph lifetime\n--   * NodeInput: changes per node invocation (each node has different input type)\n--\n-- The type parameter varies per call site - when dispatching to \"impl\",\n-- the interpreter uses @runNodeInput \\@ImplInput implInput@.\n", "criteria": "CRITERIA_0638", "selected": "SELECTED_0638", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "getEntry", "range": {"end": {"character": 8, "line": 104}, "start": {"character": 0, "line": 104}}}
{"example_id": "0639", "variation": "negative_1", "code": "getEntry = send (GetEntry :: GraphContext entry entry)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- NODE INPUT EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Effect for reading the current node's input value.\n--\n-- Type parameters:\n--   * @input@ - the input type for this node (e.g., ImplInput)\n--\n-- This enables after-handlers to access the node's input without\n-- storing it in Memory. The input is injected by the dispatcher\n-- when calling the handler.\n--\n-- Key differences from GraphContext:\n--   * GraphContext: same value for entire graph lifetime\n--   * NodeInput: changes per node invocation (each node has different input type)\n--\n-- The type parameter varies per call site - when dispatching to \"impl\",\n-- the interpreter uses @runNodeInput \\@ImplInput implInput@.\n", "criteria": "CRITERIA_0639", "selected": "SELECTED_0639", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "getEntry", "range": {"end": {"character": 8, "line": 104}, "start": {"character": 0, "line": 104}}}
{"example_id": "0640", "variation": "negative_2", "code": "getEntry = send (GetEntry :: GraphContext entry entry)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- NODE INPUT EFFECT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Effect for reading the current node's input value.\n--\n-- Type parameters:\n--   * @input@ - the input type for this node (e.g., ImplInput)\n--\n-- This enables after-handlers to access the node's input without\n-- storing it in Memory. The input is injected by the dispatcher\n-- when calling the handler.\n--\n-- Key differences from GraphContext:\n--   * GraphContext: same value for entire graph lifetime\n--   * NodeInput: changes per node invocation (each node has different input type)\n--\n-- The type parameter varies per call site - when dispatching to \"impl\",\n-- the interpreter uses @runNodeInput \\@ImplInput implInput@.\n", "criteria": "CRITERIA_0640", "selected": "SELECTED_0640", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "getEntry", "range": {"end": {"character": 8, "line": 104}, "start": {"character": 0, "line": 104}}}
{"example_id": "0641", "variation": "positive_structure", "code": "getNodeInput = send (GetNodeInput :: NodeInput input input)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- INTERPRETERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run GraphContext effect with a fixed entry value.\n--\n-- Typically provided by the graph runner when spawning a graph.\n-- For recursive execution, each child graph gets its own entry.\n--\n-- @\n-- -- In graph runner\n-- runGraphContext scaffoldInput $ do\n--   ... -- all handlers can now call getEntry\n-- @\n", "criteria": "CRITERIA_0641", "selected": "SELECTED_0641", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "getNodeInput", "range": {"end": {"character": 12, "line": 164}, "start": {"character": 0, "line": 164}}}
{"example_id": "0642", "variation": "positive_semantic", "code": "getNodeInput = send (GetNodeInput :: NodeInput input input)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- INTERPRETERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run GraphContext effect with a fixed entry value.\n--\n-- Typically provided by the graph runner when spawning a graph.\n-- For recursive execution, each child graph gets its own entry.\n--\n-- @\n-- -- In graph runner\n-- runGraphContext scaffoldInput $ do\n--   ... -- all handlers can now call getEntry\n-- @\n", "criteria": "CRITERIA_0642", "selected": "SELECTED_0642", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "getNodeInput", "range": {"end": {"character": 12, "line": 164}, "start": {"character": 0, "line": 164}}}
{"example_id": "0643", "variation": "negative_1", "code": "getNodeInput = send (GetNodeInput :: NodeInput input input)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- INTERPRETERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run GraphContext effect with a fixed entry value.\n--\n-- Typically provided by the graph runner when spawning a graph.\n-- For recursive execution, each child graph gets its own entry.\n--\n-- @\n-- -- In graph runner\n-- runGraphContext scaffoldInput $ do\n--   ... -- all handlers can now call getEntry\n-- @\n", "criteria": "CRITERIA_0643", "selected": "SELECTED_0643", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "getNodeInput", "range": {"end": {"character": 12, "line": 164}, "start": {"character": 0, "line": 164}}}
{"example_id": "0644", "variation": "negative_2", "code": "getNodeInput = send (GetNodeInput :: NodeInput input input)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- INTERPRETERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run GraphContext effect with a fixed entry value.\n--\n-- Typically provided by the graph runner when spawning a graph.\n-- For recursive execution, each child graph gets its own entry.\n--\n-- @\n-- -- In graph runner\n-- runGraphContext scaffoldInput $ do\n--   ... -- all handlers can now call getEntry\n-- @\n", "criteria": "CRITERIA_0644", "selected": "SELECTED_0644", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GraphContext.hs", "name": "getNodeInput", "range": {"end": {"character": 12, "line": 164}, "start": {"character": 0, "line": 164}}}
{"example_id": "0645", "variation": "positive_structure", "code": "getPending = send (GetPending :: Subgraph entry result [ChildHandle])\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HANDLE TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Opaque handle to a spawned child graph instance.\n--\n-- Used to track and correlate child results. The internal ID\n-- is a UUID for uniqueness across the tree.\n", "criteria": "CRITERIA_0645", "selected": "SELECTED_0645", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Subgraph.hs", "name": "getPending", "range": {"end": {"character": 10, "line": 142}, "start": {"character": 0, "line": 142}}}
{"example_id": "0646", "variation": "positive_semantic", "code": "getPending = send (GetPending :: Subgraph entry result [ChildHandle])\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HANDLE TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Opaque handle to a spawned child graph instance.\n--\n-- Used to track and correlate child results. The internal ID\n-- is a UUID for uniqueness across the tree.\n", "criteria": "CRITERIA_0646", "selected": "SELECTED_0646", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Subgraph.hs", "name": "getPending", "range": {"end": {"character": 10, "line": 142}, "start": {"character": 0, "line": 142}}}
{"example_id": "0647", "variation": "negative_1", "code": "getPending = send (GetPending :: Subgraph entry result [ChildHandle])\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HANDLE TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Opaque handle to a spawned child graph instance.\n--\n-- Used to track and correlate child results. The internal ID\n-- is a UUID for uniqueness across the tree.\n", "criteria": "CRITERIA_0647", "selected": "SELECTED_0647", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Subgraph.hs", "name": "getPending", "range": {"end": {"character": 10, "line": 142}, "start": {"character": 0, "line": 142}}}
{"example_id": "0648", "variation": "negative_2", "code": "getPending = send (GetPending :: Subgraph entry result [ChildHandle])\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HANDLE TYPES\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Opaque handle to a spawned child graph instance.\n--\n-- Used to track and correlate child results. The internal ID\n-- is a UUID for uniqueness across the tree.\n", "criteria": "CRITERIA_0648", "selected": "SELECTED_0648", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Subgraph.hs", "name": "getPending", "range": {"end": {"character": 10, "line": 142}, "start": {"character": 0, "line": 142}}}
{"example_id": "0649", "variation": "positive_structure", "code": "getScope scopeName (MemoryStore scopes) =\n  case Map.lookup scopeName scopes of\n    Nothing -> Right Nothing\n    Just jsonVal -> case Aeson.fromJSON jsonVal of\n      Aeson.Error err -> Left $\n        \"Failed to deserialize scope '\" <> scopeName <> \"': \" <> pack err\n      Aeson.Success val -> Right (Just val)\n\n-- | Set a scope in the store, serializing the value.\n--\n-- The value is immediately serialized to JSON. Type information is not\n-- stored - type checking happens at access time via 'getScope'.\n", "criteria": "CRITERIA_0649", "selected": "SELECTED_0649", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "getScope", "range": {"end": {"character": 8, "line": 398}, "start": {"character": 0, "line": 398}}}
{"example_id": "0650", "variation": "positive_semantic", "code": "getScope scopeName (MemoryStore scopes) =\n  case Map.lookup scopeName scopes of\n    Nothing -> Right Nothing\n    Just jsonVal -> case Aeson.fromJSON jsonVal of\n      Aeson.Error err -> Left $\n        \"Failed to deserialize scope '\" <> scopeName <> \"': \" <> pack err\n      Aeson.Success val -> Right (Just val)\n\n-- | Set a scope in the store, serializing the value.\n--\n-- The value is immediately serialized to JSON. Type information is not\n-- stored - type checking happens at access time via 'getScope'.\n", "criteria": "CRITERIA_0650", "selected": "SELECTED_0650", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "getScope", "range": {"end": {"character": 8, "line": 398}, "start": {"character": 0, "line": 398}}}
{"example_id": "0651", "variation": "negative_1", "code": "getScope scopeName (MemoryStore scopes) =\n  case Map.lookup scopeName scopes of\n    Nothing -> Right Nothing\n    Just jsonVal -> case Aeson.fromJSON jsonVal of\n      Aeson.Error err -> Left $\n        \"Failed to deserialize scope '\" <> scopeName <> \"': \" <> pack err\n      Aeson.Success val -> Right (Just val)\n\n-- | Set a scope in the store, serializing the value.\n--\n-- The value is immediately serialized to JSON. Type information is not\n-- stored - type checking happens at access time via 'getScope'.\n", "criteria": "CRITERIA_0651", "selected": "SELECTED_0651", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "getScope", "range": {"end": {"character": 8, "line": 398}, "start": {"character": 0, "line": 398}}}
{"example_id": "0652", "variation": "negative_2", "code": "getScope scopeName (MemoryStore scopes) =\n  case Map.lookup scopeName scopes of\n    Nothing -> Right Nothing\n    Just jsonVal -> case Aeson.fromJSON jsonVal of\n      Aeson.Error err -> Left $\n        \"Failed to deserialize scope '\" <> scopeName <> \"': \" <> pack err\n      Aeson.Success val -> Right (Just val)\n\n-- | Set a scope in the store, serializing the value.\n--\n-- The value is immediately serialized to JSON. Type information is not\n-- stored - type checking happens at access time via 'getScope'.\n", "criteria": "CRITERIA_0652", "selected": "SELECTED_0652", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "getScope", "range": {"end": {"character": 8, "line": 398}, "start": {"character": 0, "line": 398}}}
{"example_id": "0653", "variation": "positive_structure", "code": "get = send Get\n\n", "criteria": "CRITERIA_0653", "selected": "SELECTED_0653", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "get", "range": {"end": {"character": 3, "line": 155}, "start": {"character": 0, "line": 155}}}
{"example_id": "0654", "variation": "positive_semantic", "code": "get = send Get\n\n", "criteria": "CRITERIA_0654", "selected": "SELECTED_0654", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "get", "range": {"end": {"character": 3, "line": 155}, "start": {"character": 0, "line": 155}}}
{"example_id": "0655", "variation": "negative_1", "code": "get = send Get\n\n", "criteria": "CRITERIA_0655", "selected": "SELECTED_0655", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "get", "range": {"end": {"character": 3, "line": 155}, "start": {"character": 0, "line": 155}}}
{"example_id": "0656", "variation": "negative_2", "code": "get = send Get\n\n", "criteria": "CRITERIA_0656", "selected": "SELECTED_0656", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "get", "range": {"end": {"character": 3, "line": 155}, "start": {"character": 0, "line": 155}}}
{"example_id": "0657", "variation": "positive_structure", "code": "getCurrentTime = send GetCurrentTime\n\n", "criteria": "CRITERIA_0657", "selected": "SELECTED_0657", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "getCurrentTime", "range": {"end": {"character": 14, "line": 198}, "start": {"character": 0, "line": 198}}}
{"example_id": "0658", "variation": "positive_semantic", "code": "getCurrentTime = send GetCurrentTime\n\n", "criteria": "CRITERIA_0658", "selected": "SELECTED_0658", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "getCurrentTime", "range": {"end": {"character": 14, "line": 198}, "start": {"character": 0, "line": 198}}}
{"example_id": "0659", "variation": "negative_1", "code": "getCurrentTime = send GetCurrentTime\n\n", "criteria": "CRITERIA_0659", "selected": "SELECTED_0659", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "getCurrentTime", "range": {"end": {"character": 14, "line": 198}, "start": {"character": 0, "line": 198}}}
{"example_id": "0660", "variation": "negative_2", "code": "getCurrentTime = send GetCurrentTime\n\n", "criteria": "CRITERIA_0660", "selected": "SELECTED_0660", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "getCurrentTime", "range": {"end": {"character": 14, "line": 198}, "start": {"character": 0, "line": 198}}}
{"example_id": "0661", "variation": "positive_structure", "code": "getHistory = send GetHistory\n\n", "criteria": "CRITERIA_0661", "selected": "SELECTED_0661", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "getHistory", "range": {"end": {"character": 10, "line": 516}, "start": {"character": 0, "line": 516}}}
{"example_id": "0662", "variation": "positive_semantic", "code": "getHistory = send GetHistory\n\n", "criteria": "CRITERIA_0662", "selected": "SELECTED_0662", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "getHistory", "range": {"end": {"character": 10, "line": 516}, "start": {"character": 0, "line": 516}}}
{"example_id": "0663", "variation": "negative_1", "code": "getHistory = send GetHistory\n\n", "criteria": "CRITERIA_0663", "selected": "SELECTED_0663", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "getHistory", "range": {"end": {"character": 10, "line": 516}, "start": {"character": 0, "line": 516}}}
{"example_id": "0664", "variation": "negative_2", "code": "getHistory = send GetHistory\n\n", "criteria": "CRITERIA_0664", "selected": "SELECTED_0664", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "getHistory", "range": {"end": {"character": 10, "line": 516}, "start": {"character": 0, "line": 516}}}
{"example_id": "0665", "variation": "positive_structure", "code": "gets f = f <$> get\n\n", "criteria": "CRITERIA_0665", "selected": "SELECTED_0665", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "gets", "range": {"end": {"character": 4, "line": 158}, "start": {"character": 0, "line": 158}}}
{"example_id": "0666", "variation": "positive_semantic", "code": "gets f = f <$> get\n\n", "criteria": "CRITERIA_0666", "selected": "SELECTED_0666", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "gets", "range": {"end": {"character": 4, "line": 158}, "start": {"character": 0, "line": 158}}}
{"example_id": "0667", "variation": "negative_1", "code": "gets f = f <$> get\n\n", "criteria": "CRITERIA_0667", "selected": "SELECTED_0667", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "gets", "range": {"end": {"character": 4, "line": 158}, "start": {"character": 0, "line": 158}}}
{"example_id": "0668", "variation": "negative_2", "code": "gets f = f <$> get\n\n", "criteria": "CRITERIA_0668", "selected": "SELECTED_0668", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "gets", "range": {"end": {"character": 4, "line": 158}, "start": {"character": 0, "line": 158}}}
{"example_id": "0669", "variation": "positive_structure", "code": "getTasks tt = send (GetTasks tt)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRY VARIANTS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0669", "selected": "SELECTED_0669", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getTasks", "range": {"end": {"character": 8, "line": 102}, "start": {"character": 0, "line": 102}}}
{"example_id": "0670", "variation": "positive_semantic", "code": "getTasks tt = send (GetTasks tt)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRY VARIANTS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0670", "selected": "SELECTED_0670", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getTasks", "range": {"end": {"character": 8, "line": 102}, "start": {"character": 0, "line": 102}}}
{"example_id": "0671", "variation": "negative_1", "code": "getTasks tt = send (GetTasks tt)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRY VARIANTS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0671", "selected": "SELECTED_0671", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getTasks", "range": {"end": {"character": 8, "line": 102}, "start": {"character": 0, "line": 102}}}
{"example_id": "0672", "variation": "negative_2", "code": "getTasks tt = send (GetTasks tt)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRY VARIANTS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0672", "selected": "SELECTED_0672", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getTasks", "range": {"end": {"character": 8, "line": 102}, "start": {"character": 0, "line": 102}}}
{"example_id": "0673", "variation": "positive_structure", "code": "getTasksTry tt = send (GetTasksTry tt)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- STUB RUNNER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0673", "selected": "SELECTED_0673", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getTasksTry", "range": {"end": {"character": 11, "line": 125}, "start": {"character": 0, "line": 125}}}
{"example_id": "0674", "variation": "positive_semantic", "code": "getTasksTry tt = send (GetTasksTry tt)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- STUB RUNNER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0674", "selected": "SELECTED_0674", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getTasksTry", "range": {"end": {"character": 11, "line": 125}, "start": {"character": 0, "line": 125}}}
{"example_id": "0675", "variation": "negative_1", "code": "getTasksTry tt = send (GetTasksTry tt)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- STUB RUNNER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0675", "selected": "SELECTED_0675", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getTasksTry", "range": {"end": {"character": 11, "line": 125}, "start": {"character": 0, "line": 125}}}
{"example_id": "0676", "variation": "negative_2", "code": "getTasksTry tt = send (GetTasksTry tt)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- STUB RUNNER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n", "criteria": "CRITERIA_0676", "selected": "SELECTED_0676", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getTasksTry", "range": {"end": {"character": 11, "line": 125}, "start": {"character": 0, "line": 125}}}
{"example_id": "0677", "variation": "positive_structure", "code": "getUser = send GetUser\n\n", "criteria": "CRITERIA_0677", "selected": "SELECTED_0677", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getUser", "range": {"end": {"character": 7, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0678", "variation": "positive_semantic", "code": "getUser = send GetUser\n\n", "criteria": "CRITERIA_0678", "selected": "SELECTED_0678", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getUser", "range": {"end": {"character": 7, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0679", "variation": "negative_1", "code": "getUser = send GetUser\n\n", "criteria": "CRITERIA_0679", "selected": "SELECTED_0679", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getUser", "range": {"end": {"character": 7, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0680", "variation": "negative_2", "code": "getUser = send GetUser\n\n", "criteria": "CRITERIA_0680", "selected": "SELECTED_0680", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getUser", "range": {"end": {"character": 7, "line": 96}, "start": {"character": 0, "line": 96}}}
{"example_id": "0681", "variation": "positive_structure", "code": "getUserTry = send GetUserTry\n\n", "criteria": "CRITERIA_0681", "selected": "SELECTED_0681", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getUserTry", "range": {"end": {"character": 10, "line": 119}, "start": {"character": 0, "line": 119}}}
{"example_id": "0682", "variation": "positive_semantic", "code": "getUserTry = send GetUserTry\n\n", "criteria": "CRITERIA_0682", "selected": "SELECTED_0682", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getUserTry", "range": {"end": {"character": 10, "line": 119}, "start": {"character": 0, "line": 119}}}
{"example_id": "0683", "variation": "negative_1", "code": "getUserTry = send GetUserTry\n\n", "criteria": "CRITERIA_0683", "selected": "SELECTED_0683", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getUserTry", "range": {"end": {"character": 10, "line": 119}, "start": {"character": 0, "line": 119}}}
{"example_id": "0684", "variation": "negative_2", "code": "getUserTry = send GetUserTry\n\n", "criteria": "CRITERIA_0684", "selected": "SELECTED_0684", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "getUserTry", "range": {"end": {"character": 10, "line": 119}, "start": {"character": 0, "line": 119}}}
{"example_id": "0685", "variation": "positive_structure", "code": "getIssue repo number includeComments = send (GetIssue repo number includeComments)\n\n", "criteria": "CRITERIA_0685", "selected": "SELECTED_0685", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "getIssue", "range": {"end": {"character": 8, "line": 321}, "start": {"character": 0, "line": 321}}}
{"example_id": "0686", "variation": "positive_semantic", "code": "getIssue repo number includeComments = send (GetIssue repo number includeComments)\n\n", "criteria": "CRITERIA_0686", "selected": "SELECTED_0686", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "getIssue", "range": {"end": {"character": 8, "line": 321}, "start": {"character": 0, "line": 321}}}
{"example_id": "0687", "variation": "negative_1", "code": "getIssue repo number includeComments = send (GetIssue repo number includeComments)\n\n", "criteria": "CRITERIA_0687", "selected": "SELECTED_0687", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "getIssue", "range": {"end": {"character": 8, "line": 321}, "start": {"character": 0, "line": 321}}}
{"example_id": "0688", "variation": "negative_2", "code": "getIssue repo number includeComments = send (GetIssue repo number includeComments)\n\n", "criteria": "CRITERIA_0688", "selected": "SELECTED_0688", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "getIssue", "range": {"end": {"character": 8, "line": 321}, "start": {"character": 0, "line": 321}}}
{"example_id": "0689", "variation": "positive_structure", "code": "getPullRequest repo number includeDetails = send (GetPullRequest repo number includeDetails)\n\n", "criteria": "CRITERIA_0689", "selected": "SELECTED_0689", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "getPullRequest", "range": {"end": {"character": 14, "line": 327}, "start": {"character": 0, "line": 327}}}
{"example_id": "0690", "variation": "positive_semantic", "code": "getPullRequest repo number includeDetails = send (GetPullRequest repo number includeDetails)\n\n", "criteria": "CRITERIA_0690", "selected": "SELECTED_0690", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "getPullRequest", "range": {"end": {"character": 14, "line": 327}, "start": {"character": 0, "line": 327}}}
{"example_id": "0691", "variation": "negative_1", "code": "getPullRequest repo number includeDetails = send (GetPullRequest repo number includeDetails)\n\n", "criteria": "CRITERIA_0691", "selected": "SELECTED_0691", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "getPullRequest", "range": {"end": {"character": 14, "line": 327}, "start": {"character": 0, "line": 327}}}
{"example_id": "0692", "variation": "negative_2", "code": "getPullRequest repo number includeDetails = send (GetPullRequest repo number includeDetails)\n\n", "criteria": "CRITERIA_0692", "selected": "SELECTED_0692", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "getPullRequest", "range": {"end": {"character": 14, "line": 327}, "start": {"character": 0, "line": 327}}}
{"example_id": "0693", "variation": "positive_structure", "code": "getMessageCount conn gid = do\n  [Only count] <- query conn\n    \"SELECT COUNT(*) FROM messages WHERE game_id = ?\"\n    (Only gid)\n  return count\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- COMPRESSION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Update compression cursor and summary\n", "criteria": "CRITERIA_0693", "selected": "SELECTED_0693", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "getMessageCount", "range": {"end": {"character": 15, "line": 216}, "start": {"character": 0, "line": 216}}}
{"example_id": "0694", "variation": "positive_semantic", "code": "getMessageCount conn gid = do\n  [Only count] <- query conn\n    \"SELECT COUNT(*) FROM messages WHERE game_id = ?\"\n    (Only gid)\n  return count\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- COMPRESSION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Update compression cursor and summary\n", "criteria": "CRITERIA_0694", "selected": "SELECTED_0694", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "getMessageCount", "range": {"end": {"character": 15, "line": 216}, "start": {"character": 0, "line": 216}}}
{"example_id": "0695", "variation": "negative_1", "code": "getMessageCount conn gid = do\n  [Only count] <- query conn\n    \"SELECT COUNT(*) FROM messages WHERE game_id = ?\"\n    (Only gid)\n  return count\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- COMPRESSION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Update compression cursor and summary\n", "criteria": "CRITERIA_0695", "selected": "SELECTED_0695", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "getMessageCount", "range": {"end": {"character": 15, "line": 216}, "start": {"character": 0, "line": 216}}}
{"example_id": "0696", "variation": "negative_2", "code": "getMessageCount conn gid = do\n  [Only count] <- query conn\n    \"SELECT COUNT(*) FROM messages WHERE game_id = ?\"\n    (Only gid)\n  return count\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- COMPRESSION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Update compression cursor and summary\n", "criteria": "CRITERIA_0696", "selected": "SELECTED_0696", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "getMessageCount", "range": {"end": {"character": 15, "line": 216}, "start": {"character": 0, "line": 216}}}
{"example_id": "0697", "variation": "positive_structure", "code": "setThinking = send . SetThinking\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONVENIENCE HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Confirmation dialog (Yes/No).\n--\n-- @\n-- confirmed <- confirm \"Delete this item?\"\n-- when confirmed $ deleteItem item\n-- @\n", "criteria": "CRITERIA_0697", "selected": "SELECTED_0697", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/UI.hs", "name": "setThinking", "range": {"end": {"character": 11, "line": 202}, "start": {"character": 0, "line": 202}}}
{"example_id": "0698", "variation": "positive_semantic", "code": "setThinking = send . SetThinking\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONVENIENCE HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Confirmation dialog (Yes/No).\n--\n-- @\n-- confirmed <- confirm \"Delete this item?\"\n-- when confirmed $ deleteItem item\n-- @\n", "criteria": "CRITERIA_0698", "selected": "SELECTED_0698", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/UI.hs", "name": "setThinking", "range": {"end": {"character": 11, "line": 202}, "start": {"character": 0, "line": 202}}}
{"example_id": "0699", "variation": "negative_1", "code": "setThinking = send . SetThinking\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONVENIENCE HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Confirmation dialog (Yes/No).\n--\n-- @\n-- confirmed <- confirm \"Delete this item?\"\n-- when confirmed $ deleteItem item\n-- @\n", "criteria": "CRITERIA_0699", "selected": "SELECTED_0699", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/UI.hs", "name": "setThinking", "range": {"end": {"character": 11, "line": 202}, "start": {"character": 0, "line": 202}}}
{"example_id": "0700", "variation": "negative_2", "code": "setThinking = send . SetThinking\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CONVENIENCE HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Confirmation dialog (Yes/No).\n--\n-- @\n-- confirmed <- confirm \"Delete this item?\"\n-- when confirmed $ deleteItem item\n-- @\n", "criteria": "CRITERIA_0700", "selected": "SELECTED_0700", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/UI.hs", "name": "setThinking", "range": {"end": {"character": 11, "line": 202}, "start": {"character": 0, "line": 202}}}
{"example_id": "0701", "variation": "positive_structure", "code": "setScope scopeName val (MemoryStore scopes) = MemoryStore $\n  Map.insert scopeName (toJSON val) scopes\n\n-- | Run memory effect with scoped persistence.\n--\n-- This interpreter:\n-- 1. Loads initial state from the store (or uses default if scope missing)\n-- 2. Runs the action\n-- 3. Saves final state back to the store\n--\n-- If deserialization fails (e.g., schema mismatch after code changes), the\n-- default value is used. Use 'getScope' directly if you need to detect errors.\n--\n-- @\n-- (result, finalStore) <- runMemoryScoped \"explore\" defaultState store $ do\n--   updateMem @ExploreMem $ \\\\m -> m { visited = newUrl : m.visited }\n--   getMem @ExploreMem\n-- @\n", "criteria": "CRITERIA_0701", "selected": "SELECTED_0701", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "setScope", "range": {"end": {"character": 8, "line": 416}, "start": {"character": 0, "line": 416}}}
{"example_id": "0702", "variation": "positive_semantic", "code": "setScope scopeName val (MemoryStore scopes) = MemoryStore $\n  Map.insert scopeName (toJSON val) scopes\n\n-- | Run memory effect with scoped persistence.\n--\n-- This interpreter:\n-- 1. Loads initial state from the store (or uses default if scope missing)\n-- 2. Runs the action\n-- 3. Saves final state back to the store\n--\n-- If deserialization fails (e.g., schema mismatch after code changes), the\n-- default value is used. Use 'getScope' directly if you need to detect errors.\n--\n-- @\n-- (result, finalStore) <- runMemoryScoped \"explore\" defaultState store $ do\n--   updateMem @ExploreMem $ \\\\m -> m { visited = newUrl : m.visited }\n--   getMem @ExploreMem\n-- @\n", "criteria": "CRITERIA_0702", "selected": "SELECTED_0702", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "setScope", "range": {"end": {"character": 8, "line": 416}, "start": {"character": 0, "line": 416}}}
{"example_id": "0703", "variation": "negative_1", "code": "setScope scopeName val (MemoryStore scopes) = MemoryStore $\n  Map.insert scopeName (toJSON val) scopes\n\n-- | Run memory effect with scoped persistence.\n--\n-- This interpreter:\n-- 1. Loads initial state from the store (or uses default if scope missing)\n-- 2. Runs the action\n-- 3. Saves final state back to the store\n--\n-- If deserialization fails (e.g., schema mismatch after code changes), the\n-- default value is used. Use 'getScope' directly if you need to detect errors.\n--\n-- @\n-- (result, finalStore) <- runMemoryScoped \"explore\" defaultState store $ do\n--   updateMem @ExploreMem $ \\\\m -> m { visited = newUrl : m.visited }\n--   getMem @ExploreMem\n-- @\n", "criteria": "CRITERIA_0703", "selected": "SELECTED_0703", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "setScope", "range": {"end": {"character": 8, "line": 416}, "start": {"character": 0, "line": 416}}}
{"example_id": "0704", "variation": "negative_2", "code": "setScope scopeName val (MemoryStore scopes) = MemoryStore $\n  Map.insert scopeName (toJSON val) scopes\n\n-- | Run memory effect with scoped persistence.\n--\n-- This interpreter:\n-- 1. Loads initial state from the store (or uses default if scope missing)\n-- 2. Runs the action\n-- 3. Saves final state back to the store\n--\n-- If deserialization fails (e.g., schema mismatch after code changes), the\n-- default value is used. Use 'getScope' directly if you need to detect errors.\n--\n-- @\n-- (result, finalStore) <- runMemoryScoped \"explore\" defaultState store $ do\n--   updateMem @ExploreMem $ \\\\m -> m { visited = newUrl : m.visited }\n--   getMem @ExploreMem\n-- @\n", "criteria": "CRITERIA_0704", "selected": "SELECTED_0704", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "setScope", "range": {"end": {"character": 8, "line": 416}, "start": {"character": 0, "line": 416}}}
{"example_id": "0705", "variation": "positive_structure", "code": "setupSocket socketPath = do\n  sock <- socket AF_UNIX Stream 0\n  bind sock (SockAddrUnix socketPath)\n  listen sock 10\n  pure sock\n\n-- | Close socket and clean up socket file.\n", "criteria": "CRITERIA_0705", "selected": "SELECTED_0705", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "setupSocket", "range": {"end": {"character": 11, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0706", "variation": "positive_semantic", "code": "setupSocket socketPath = do\n  sock <- socket AF_UNIX Stream 0\n  bind sock (SockAddrUnix socketPath)\n  listen sock 10\n  pure sock\n\n-- | Close socket and clean up socket file.\n", "criteria": "CRITERIA_0706", "selected": "SELECTED_0706", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "setupSocket", "range": {"end": {"character": 11, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0707", "variation": "negative_1", "code": "setupSocket socketPath = do\n  sock <- socket AF_UNIX Stream 0\n  bind sock (SockAddrUnix socketPath)\n  listen sock 10\n  pure sock\n\n-- | Close socket and clean up socket file.\n", "criteria": "CRITERIA_0707", "selected": "SELECTED_0707", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "setupSocket", "range": {"end": {"character": 11, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0708", "variation": "negative_2", "code": "setupSocket socketPath = do\n  sock <- socket AF_UNIX Stream 0\n  bind sock (SockAddrUnix socketPath)\n  listen sock 10\n  pure sock\n\n-- | Close socket and clean up socket file.\n", "criteria": "CRITERIA_0708", "selected": "SELECTED_0708", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Server.hs", "name": "setupSocket", "range": {"end": {"character": 11, "line": 85}, "start": {"character": 0, "line": 85}}}
{"example_id": "0709", "variation": "positive_structure", "code": "withRecursiveGraph maybeConcurrencyLimit callback =\n  -- Create ki scope for structured concurrency\n  Ki.scoped $ \\scope -> do\n    (state, wire) <- newSubgraphStateDeferred scope maybeConcurrencyLimit\n    callback state wire\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- INTERPRETER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Interpret the Subgraph effect using SubgraphState.\n--\n-- This is the core interpreter that translates effect operations to IO:\n--\n-- * SpawnSelf: spawn async child, track in ssChildren, notify on complete\n-- * AwaitAny: block on ssCompleted queue\n-- * GetPending: read ssChildren TVar\n--\n-- Note: Children remove themselves from ssChildren and add to ssCompleted\n-- when they finish. This enables AwaitAny to work correctly.\n--\n-- == Deferred Runner Lookup\n--\n-- The interpreter calls @ssGetRunner@ to obtain the runner function.\n-- This indirection enables deferred binding:\n--\n-- * With @newSubgraphState@: @ssGetRunner = pure runner@ (immediate)\n-- * With @newSubgraphStateDeferred@: @ssGetRunner = readIORef ref@ (deferred)\n--\n-- The deferred case allows the runner to be wired up after the interpreter\n", "criteria": "CRITERIA_0709", "selected": "SELECTED_0709", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Subgraph.hs", "name": "withRecursiveGraph", "range": {"end": {"character": 18, "line": 270}, "start": {"character": 0, "line": 270}}}
{"example_id": "0710", "variation": "positive_semantic", "code": "withRecursiveGraph maybeConcurrencyLimit callback =\n  -- Create ki scope for structured concurrency\n  Ki.scoped $ \\scope -> do\n    (state, wire) <- newSubgraphStateDeferred scope maybeConcurrencyLimit\n    callback state wire\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- INTERPRETER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Interpret the Subgraph effect using SubgraphState.\n--\n-- This is the core interpreter that translates effect operations to IO:\n--\n-- * SpawnSelf: spawn async child, track in ssChildren, notify on complete\n-- * AwaitAny: block on ssCompleted queue\n-- * GetPending: read ssChildren TVar\n--\n-- Note: Children remove themselves from ssChildren and add to ssCompleted\n-- when they finish. This enables AwaitAny to work correctly.\n--\n-- == Deferred Runner Lookup\n--\n-- The interpreter calls @ssGetRunner@ to obtain the runner function.\n-- This indirection enables deferred binding:\n--\n-- * With @newSubgraphState@: @ssGetRunner = pure runner@ (immediate)\n-- * With @newSubgraphStateDeferred@: @ssGetRunner = readIORef ref@ (deferred)\n--\n-- The deferred case allows the runner to be wired up after the interpreter\n", "criteria": "CRITERIA_0710", "selected": "SELECTED_0710", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Subgraph.hs", "name": "withRecursiveGraph", "range": {"end": {"character": 18, "line": 270}, "start": {"character": 0, "line": 270}}}
{"example_id": "0711", "variation": "negative_1", "code": "withRecursiveGraph maybeConcurrencyLimit callback =\n  -- Create ki scope for structured concurrency\n  Ki.scoped $ \\scope -> do\n    (state, wire) <- newSubgraphStateDeferred scope maybeConcurrencyLimit\n    callback state wire\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- INTERPRETER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Interpret the Subgraph effect using SubgraphState.\n--\n-- This is the core interpreter that translates effect operations to IO:\n--\n-- * SpawnSelf: spawn async child, track in ssChildren, notify on complete\n-- * AwaitAny: block on ssCompleted queue\n-- * GetPending: read ssChildren TVar\n--\n-- Note: Children remove themselves from ssChildren and add to ssCompleted\n-- when they finish. This enables AwaitAny to work correctly.\n--\n-- == Deferred Runner Lookup\n--\n-- The interpreter calls @ssGetRunner@ to obtain the runner function.\n-- This indirection enables deferred binding:\n--\n-- * With @newSubgraphState@: @ssGetRunner = pure runner@ (immediate)\n-- * With @newSubgraphStateDeferred@: @ssGetRunner = readIORef ref@ (deferred)\n--\n-- The deferred case allows the runner to be wired up after the interpreter\n", "criteria": "CRITERIA_0711", "selected": "SELECTED_0711", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Subgraph.hs", "name": "withRecursiveGraph", "range": {"end": {"character": 18, "line": 270}, "start": {"character": 0, "line": 270}}}
{"example_id": "0712", "variation": "negative_2", "code": "withRecursiveGraph maybeConcurrencyLimit callback =\n  -- Create ki scope for structured concurrency\n  Ki.scoped $ \\scope -> do\n    (state, wire) <- newSubgraphStateDeferred scope maybeConcurrencyLimit\n    callback state wire\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- INTERPRETER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Interpret the Subgraph effect using SubgraphState.\n--\n-- This is the core interpreter that translates effect operations to IO:\n--\n-- * SpawnSelf: spawn async child, track in ssChildren, notify on complete\n-- * AwaitAny: block on ssCompleted queue\n-- * GetPending: read ssChildren TVar\n--\n-- Note: Children remove themselves from ssChildren and add to ssCompleted\n-- when they finish. This enables AwaitAny to work correctly.\n--\n-- == Deferred Runner Lookup\n--\n-- The interpreter calls @ssGetRunner@ to obtain the runner function.\n-- This indirection enables deferred binding:\n--\n-- * With @newSubgraphState@: @ssGetRunner = pure runner@ (immediate)\n-- * With @newSubgraphStateDeferred@: @ssGetRunner = readIORef ref@ (deferred)\n--\n-- The deferred case allows the runner to be wired up after the interpreter\n", "criteria": "CRITERIA_0712", "selected": "SELECTED_0712", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Subgraph.hs", "name": "withRecursiveGraph", "range": {"end": {"character": 18, "line": 270}, "start": {"character": 0, "line": 270}}}
{"example_id": "0713", "variation": "positive_structure", "code": "withActorSystem entryPayload setup = do\n  exitChan <- newEmptyMVar\n  routerRef <- newIORef uninitializedRouter\n\n  Ki.scoped $ \\scope -> do\n    -- Pass a router that reads from the ref\n    let router target payload = do\n          r <- readIORef routerRef\n          r target payload\n\n    -- User spawns actors\n    actors <- setup scope router\n\n    -- Install the real router\n    writeIORef routerRef (realRouter actors exitChan)\n\n    -- Kick off the system\n    router \"entry\" entryPayload\n\n    -- Wait for exit signal\n    takeMVar exitChan\n\n  where\n    uninitializedRouter :: Router\n    uninitializedRouter _ _ = error \"Router not initialized (message sent during setup before actors registered)\"\n\n    realRouter :: Map ActorId Actor -> MVar result -> Router\n    realRouter actors exitChan target payload\n      | target == \"exit\" = case fromJSON @result payload of\n          Success r -> putMVar exitChan r\n          Error e   -> error $ \"Exit actor failed to parse result: \" <> e\n", "criteria": "CRITERIA_0713", "selected": "SELECTED_0713", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Runtime.hs", "name": "withActorSystem", "range": {"end": {"character": 15, "line": 56}, "start": {"character": 0, "line": 56}}}
{"example_id": "0714", "variation": "positive_semantic", "code": "withActorSystem entryPayload setup = do\n  exitChan <- newEmptyMVar\n  routerRef <- newIORef uninitializedRouter\n\n  Ki.scoped $ \\scope -> do\n    -- Pass a router that reads from the ref\n    let router target payload = do\n          r <- readIORef routerRef\n          r target payload\n\n    -- User spawns actors\n    actors <- setup scope router\n\n    -- Install the real router\n    writeIORef routerRef (realRouter actors exitChan)\n\n    -- Kick off the system\n    router \"entry\" entryPayload\n\n    -- Wait for exit signal\n    takeMVar exitChan\n\n  where\n    uninitializedRouter :: Router\n    uninitializedRouter _ _ = error \"Router not initialized (message sent during setup before actors registered)\"\n\n    realRouter :: Map ActorId Actor -> MVar result -> Router\n    realRouter actors exitChan target payload\n      | target == \"exit\" = case fromJSON @result payload of\n          Success r -> putMVar exitChan r\n          Error e   -> error $ \"Exit actor failed to parse result: \" <> e\n", "criteria": "CRITERIA_0714", "selected": "SELECTED_0714", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Runtime.hs", "name": "withActorSystem", "range": {"end": {"character": 15, "line": 56}, "start": {"character": 0, "line": 56}}}
{"example_id": "0715", "variation": "negative_1", "code": "withActorSystem entryPayload setup = do\n  exitChan <- newEmptyMVar\n  routerRef <- newIORef uninitializedRouter\n\n  Ki.scoped $ \\scope -> do\n    -- Pass a router that reads from the ref\n    let router target payload = do\n          r <- readIORef routerRef\n          r target payload\n\n    -- User spawns actors\n    actors <- setup scope router\n\n    -- Install the real router\n    writeIORef routerRef (realRouter actors exitChan)\n\n    -- Kick off the system\n    router \"entry\" entryPayload\n\n    -- Wait for exit signal\n    takeMVar exitChan\n\n  where\n    uninitializedRouter :: Router\n    uninitializedRouter _ _ = error \"Router not initialized (message sent during setup before actors registered)\"\n\n    realRouter :: Map ActorId Actor -> MVar result -> Router\n    realRouter actors exitChan target payload\n      | target == \"exit\" = case fromJSON @result payload of\n          Success r -> putMVar exitChan r\n          Error e   -> error $ \"Exit actor failed to parse result: \" <> e\n", "criteria": "CRITERIA_0715", "selected": "SELECTED_0715", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Runtime.hs", "name": "withActorSystem", "range": {"end": {"character": 15, "line": 56}, "start": {"character": 0, "line": 56}}}
{"example_id": "0716", "variation": "negative_2", "code": "withActorSystem entryPayload setup = do\n  exitChan <- newEmptyMVar\n  routerRef <- newIORef uninitializedRouter\n\n  Ki.scoped $ \\scope -> do\n    -- Pass a router that reads from the ref\n    let router target payload = do\n          r <- readIORef routerRef\n          r target payload\n\n    -- User spawns actors\n    actors <- setup scope router\n\n    -- Install the real router\n    writeIORef routerRef (realRouter actors exitChan)\n\n    -- Kick off the system\n    router \"entry\" entryPayload\n\n    -- Wait for exit signal\n    takeMVar exitChan\n\n  where\n    uninitializedRouter :: Router\n    uninitializedRouter _ _ = error \"Router not initialized (message sent during setup before actors registered)\"\n\n    realRouter :: Map ActorId Actor -> MVar result -> Router\n    realRouter actors exitChan target payload\n      | target == \"exit\" = case fromJSON @result payload of\n          Success r -> putMVar exitChan r\n          Error e   -> error $ \"Exit actor failed to parse result: \" <> e\n", "criteria": "CRITERIA_0716", "selected": "SELECTED_0716", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Runtime.hs", "name": "withActorSystem", "range": {"end": {"character": 15, "line": 56}, "start": {"character": 0, "line": 56}}}
{"example_id": "0717", "variation": "positive_structure", "code": "withRetry config action = go 1 (config.rcInitialDelayMicros) []\n  where\n    go attempt delay errors\n      | attempt > config.rcMaxAttempts =\n          pure $ RetryFailure (reverse errors)\n      | otherwise = do\n          result <- try action\n          case result of\n            Right a -> pure $ RetrySuccess a attempt\n            Left (err :: SomeException) -> do\n              let errMsg = T.pack $ displayException err\n                  errors' = (attempt, errMsg) : errors\n\n              if attempt >= config.rcMaxAttempts\n                then pure $ RetryFailure (reverse errors')\n                else do\n                  -- Wait before retry\n                  threadDelay delay\n                  -- Calculate next delay with exponential backoff\n                  let nextDelay = min\n                        (round $ fromIntegral delay * config.rcBackoffMultiplier)\n                        (config.rcMaxDelayMicros)\n                  go (attempt + 1) nextDelay errors'\n", "criteria": "CRITERIA_0717", "selected": "SELECTED_0717", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Retry.hs", "name": "withRetry", "range": {"end": {"character": 9, "line": 84}, "start": {"character": 0, "line": 84}}}
{"example_id": "0718", "variation": "positive_semantic", "code": "withRetry config action = go 1 (config.rcInitialDelayMicros) []\n  where\n    go attempt delay errors\n      | attempt > config.rcMaxAttempts =\n          pure $ RetryFailure (reverse errors)\n      | otherwise = do\n          result <- try action\n          case result of\n            Right a -> pure $ RetrySuccess a attempt\n            Left (err :: SomeException) -> do\n              let errMsg = T.pack $ displayException err\n                  errors' = (attempt, errMsg) : errors\n\n              if attempt >= config.rcMaxAttempts\n                then pure $ RetryFailure (reverse errors')\n                else do\n                  -- Wait before retry\n                  threadDelay delay\n                  -- Calculate next delay with exponential backoff\n                  let nextDelay = min\n                        (round $ fromIntegral delay * config.rcBackoffMultiplier)\n                        (config.rcMaxDelayMicros)\n                  go (attempt + 1) nextDelay errors'\n", "criteria": "CRITERIA_0718", "selected": "SELECTED_0718", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Retry.hs", "name": "withRetry", "range": {"end": {"character": 9, "line": 84}, "start": {"character": 0, "line": 84}}}
{"example_id": "0719", "variation": "negative_1", "code": "withRetry config action = go 1 (config.rcInitialDelayMicros) []\n  where\n    go attempt delay errors\n      | attempt > config.rcMaxAttempts =\n          pure $ RetryFailure (reverse errors)\n      | otherwise = do\n          result <- try action\n          case result of\n            Right a -> pure $ RetrySuccess a attempt\n            Left (err :: SomeException) -> do\n              let errMsg = T.pack $ displayException err\n                  errors' = (attempt, errMsg) : errors\n\n              if attempt >= config.rcMaxAttempts\n                then pure $ RetryFailure (reverse errors')\n                else do\n                  -- Wait before retry\n                  threadDelay delay\n                  -- Calculate next delay with exponential backoff\n                  let nextDelay = min\n                        (round $ fromIntegral delay * config.rcBackoffMultiplier)\n                        (config.rcMaxDelayMicros)\n                  go (attempt + 1) nextDelay errors'\n", "criteria": "CRITERIA_0719", "selected": "SELECTED_0719", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Retry.hs", "name": "withRetry", "range": {"end": {"character": 9, "line": 84}, "start": {"character": 0, "line": 84}}}
{"example_id": "0720", "variation": "negative_2", "code": "withRetry config action = go 1 (config.rcInitialDelayMicros) []\n  where\n    go attempt delay errors\n      | attempt > config.rcMaxAttempts =\n          pure $ RetryFailure (reverse errors)\n      | otherwise = do\n          result <- try action\n          case result of\n            Right a -> pure $ RetrySuccess a attempt\n            Left (err :: SomeException) -> do\n              let errMsg = T.pack $ displayException err\n                  errors' = (attempt, errMsg) : errors\n\n              if attempt >= config.rcMaxAttempts\n                then pure $ RetryFailure (reverse errors')\n                else do\n                  -- Wait before retry\n                  threadDelay delay\n                  -- Calculate next delay with exponential backoff\n                  let nextDelay = min\n                        (round $ fromIntegral delay * config.rcBackoffMultiplier)\n                        (config.rcMaxDelayMicros)\n                  go (attempt + 1) nextDelay errors'\n", "criteria": "CRITERIA_0720", "selected": "SELECTED_0720", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Retry.hs", "name": "withRetry", "range": {"end": {"character": 9, "line": 84}, "start": {"character": 0, "line": 84}}}
{"example_id": "0721", "variation": "positive_structure", "code": "withSpan name kind attrs action = do\n  _ <- startSpan name kind attrs\n  result <- action\n  endSpan False []\n  pure result\n\n-- | Add an attribute to the current span.\n--\n-- No-op if no span is active.\n", "criteria": "CRITERIA_0721", "selected": "SELECTED_0721", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Observability.hs", "name": "withSpan", "range": {"end": {"character": 8, "line": 225}, "start": {"character": 0, "line": 225}}}
{"example_id": "0722", "variation": "positive_semantic", "code": "withSpan name kind attrs action = do\n  _ <- startSpan name kind attrs\n  result <- action\n  endSpan False []\n  pure result\n\n-- | Add an attribute to the current span.\n--\n-- No-op if no span is active.\n", "criteria": "CRITERIA_0722", "selected": "SELECTED_0722", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Observability.hs", "name": "withSpan", "range": {"end": {"character": 8, "line": 225}, "start": {"character": 0, "line": 225}}}
{"example_id": "0723", "variation": "negative_1", "code": "withSpan name kind attrs action = do\n  _ <- startSpan name kind attrs\n  result <- action\n  endSpan False []\n  pure result\n\n-- | Add an attribute to the current span.\n--\n-- No-op if no span is active.\n", "criteria": "CRITERIA_0723", "selected": "SELECTED_0723", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Observability.hs", "name": "withSpan", "range": {"end": {"character": 8, "line": 225}, "start": {"character": 0, "line": 225}}}
{"example_id": "0724", "variation": "negative_2", "code": "withSpan name kind attrs action = do\n  _ <- startSpan name kind attrs\n  result <- action\n  endSpan False []\n  pure result\n\n-- | Add an attribute to the current span.\n--\n-- No-op if no span is active.\n", "criteria": "CRITERIA_0724", "selected": "SELECTED_0724", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Observability.hs", "name": "withSpan", "range": {"end": {"character": 8, "line": 225}, "start": {"character": 0, "line": 225}}}
{"example_id": "0725", "variation": "positive_structure", "code": "withWorktree spec action = do\n  createResult <- createWorktree spec\n  case createResult of\n    Left err -> pure $ Left err\n    Right wtPath -> do\n      -- Run the action\n      result <- action wtPath\n      -- Always cleanup (best effort - ignore delete errors)\n      _ <- deleteWorktree wtPath\n      pure $ Right result\n", "criteria": "CRITERIA_0725", "selected": "SELECTED_0725", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Worktree.hs", "name": "withWorktree", "range": {"end": {"character": 12, "line": 306}, "start": {"character": 0, "line": 306}}}
{"example_id": "0726", "variation": "positive_semantic", "code": "withWorktree spec action = do\n  createResult <- createWorktree spec\n  case createResult of\n    Left err -> pure $ Left err\n    Right wtPath -> do\n      -- Run the action\n      result <- action wtPath\n      -- Always cleanup (best effort - ignore delete errors)\n      _ <- deleteWorktree wtPath\n      pure $ Right result\n", "criteria": "CRITERIA_0726", "selected": "SELECTED_0726", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Worktree.hs", "name": "withWorktree", "range": {"end": {"character": 12, "line": 306}, "start": {"character": 0, "line": 306}}}
{"example_id": "0727", "variation": "negative_1", "code": "withWorktree spec action = do\n  createResult <- createWorktree spec\n  case createResult of\n    Left err -> pure $ Left err\n    Right wtPath -> do\n      -- Run the action\n      result <- action wtPath\n      -- Always cleanup (best effort - ignore delete errors)\n      _ <- deleteWorktree wtPath\n      pure $ Right result\n", "criteria": "CRITERIA_0727", "selected": "SELECTED_0727", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Worktree.hs", "name": "withWorktree", "range": {"end": {"character": 12, "line": 306}, "start": {"character": 0, "line": 306}}}
{"example_id": "0728", "variation": "negative_2", "code": "withWorktree spec action = do\n  createResult <- createWorktree spec\n  case createResult of\n    Left err -> pure $ Left err\n    Right wtPath -> do\n      -- Run the action\n      result <- action wtPath\n      -- Always cleanup (best effort - ignore delete errors)\n      _ <- deleteWorktree wtPath\n      pure $ Right result\n", "criteria": "CRITERIA_0728", "selected": "SELECTED_0728", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Worktree.hs", "name": "withWorktree", "range": {"end": {"character": 12, "line": 306}, "start": {"character": 0, "line": 306}}}
{"example_id": "0729", "variation": "positive_structure", "code": "withImages text images = TextBlock text : map ImageBlock images\n\n", "criteria": "CRITERIA_0729", "selected": "SELECTED_0729", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "withImages", "range": {"end": {"character": 10, "line": 380}, "start": {"character": 0, "line": 380}}}
{"example_id": "0730", "variation": "positive_semantic", "code": "withImages text images = TextBlock text : map ImageBlock images\n\n", "criteria": "CRITERIA_0730", "selected": "SELECTED_0730", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "withImages", "range": {"end": {"character": 10, "line": 380}, "start": {"character": 0, "line": 380}}}
{"example_id": "0731", "variation": "negative_1", "code": "withImages text images = TextBlock text : map ImageBlock images\n\n", "criteria": "CRITERIA_0731", "selected": "SELECTED_0731", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "withImages", "range": {"end": {"character": 10, "line": 380}, "start": {"character": 0, "line": 380}}}
{"example_id": "0732", "variation": "negative_2", "code": "withImages text images = TextBlock text : map ImageBlock images\n\n", "criteria": "CRITERIA_0732", "selected": "SELECTED_0732", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/Types.hs", "name": "withImages", "range": {"end": {"character": 10, "line": 380}, "start": {"character": 0, "line": 380}}}
{"example_id": "0733", "variation": "positive_structure", "code": "withGraphSpan name action = do\n  _ <- startSpan name SpanServer []\n  result <- action\n  endSpan False []\n  pure result\n", "criteria": "CRITERIA_0733", "selected": "SELECTED_0733", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "withGraphSpan", "range": {"end": {"character": 13, "line": 248}, "start": {"character": 0, "line": 248}}}
{"example_id": "0734", "variation": "positive_semantic", "code": "withGraphSpan name action = do\n  _ <- startSpan name SpanServer []\n  result <- action\n  endSpan False []\n  pure result\n", "criteria": "CRITERIA_0734", "selected": "SELECTED_0734", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "withGraphSpan", "range": {"end": {"character": 13, "line": 248}, "start": {"character": 0, "line": 248}}}
{"example_id": "0735", "variation": "negative_1", "code": "withGraphSpan name action = do\n  _ <- startSpan name SpanServer []\n  result <- action\n  endSpan False []\n  pure result\n", "criteria": "CRITERIA_0735", "selected": "SELECTED_0735", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "withGraphSpan", "range": {"end": {"character": 13, "line": 248}, "start": {"character": 0, "line": 248}}}
{"example_id": "0736", "variation": "negative_2", "code": "withGraphSpan name action = do\n  _ <- startSpan name SpanServer []\n  result <- action\n  endSpan False []\n  pure result\n", "criteria": "CRITERIA_0736", "selected": "SELECTED_0736", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "withGraphSpan", "range": {"end": {"character": 13, "line": 248}, "start": {"character": 0, "line": 248}}}
{"example_id": "0737", "variation": "positive_structure", "code": "withNodeSpan handlerName action = do\n  _ <- startSpan (\"node:\" <> handlerName) SpanInternal\n    [AttrText \"node.name\" handlerName]\n  result <- action\n  endSpan False []\n  pure result\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRACED GRAPH EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run a graph with automatic span emission for each node transition.\n--\n-- Creates a root span for the graph and child spans for each handler invocation.\n--\n-- @\n-- result <- runGraphWithSpans @MyGraph handlers inputValue\n-- @\n", "criteria": "CRITERIA_0737", "selected": "SELECTED_0737", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "withNodeSpan", "range": {"end": {"character": 12, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0738", "variation": "positive_semantic", "code": "withNodeSpan handlerName action = do\n  _ <- startSpan (\"node:\" <> handlerName) SpanInternal\n    [AttrText \"node.name\" handlerName]\n  result <- action\n  endSpan False []\n  pure result\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRACED GRAPH EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run a graph with automatic span emission for each node transition.\n--\n-- Creates a root span for the graph and child spans for each handler invocation.\n--\n-- @\n-- result <- runGraphWithSpans @MyGraph handlers inputValue\n-- @\n", "criteria": "CRITERIA_0738", "selected": "SELECTED_0738", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "withNodeSpan", "range": {"end": {"character": 12, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0739", "variation": "negative_1", "code": "withNodeSpan handlerName action = do\n  _ <- startSpan (\"node:\" <> handlerName) SpanInternal\n    [AttrText \"node.name\" handlerName]\n  result <- action\n  endSpan False []\n  pure result\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRACED GRAPH EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run a graph with automatic span emission for each node transition.\n--\n-- Creates a root span for the graph and child spans for each handler invocation.\n--\n-- @\n-- result <- runGraphWithSpans @MyGraph handlers inputValue\n-- @\n", "criteria": "CRITERIA_0739", "selected": "SELECTED_0739", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "withNodeSpan", "range": {"end": {"character": 12, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0740", "variation": "negative_2", "code": "withNodeSpan handlerName action = do\n  _ <- startSpan (\"node:\" <> handlerName) SpanInternal\n    [AttrText \"node.name\" handlerName]\n  result <- action\n  endSpan False []\n  pure result\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TRACED GRAPH EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run a graph with automatic span emission for each node transition.\n--\n-- Creates a root span for the graph and child spans for each handler invocation.\n--\n-- @\n-- result <- runGraphWithSpans @MyGraph handlers inputValue\n-- @\n", "criteria": "CRITERIA_0740", "selected": "SELECTED_0740", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret/Instrumented.hs", "name": "withNodeSpan", "range": {"end": {"character": 12, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0741", "variation": "positive_structure", "code": "withLSPSession rootDir action = do\n  -- Create request channel for communication with worker\n  requestChan <- newChan\n  resultMVar <- newEmptyMVar\n  doneMVar <- newEmptyMVar  -- Signal when user action completes\n\n  -- lsp-test's runSessionWithConfig spawns HLS and handles handshake\n  -- The session runs until we're done or HLS crashes\n  --\n  -- Note: lsp-test doesn't pass --lsp flag by default, so we use a wrapper script\n  -- Create wrapper if not exists (idempotent)\n  let wrapperPath = \"/tmp/tidepool-hls-wrapper\"\n  liftIO $ writeFile wrapperPath \"#!/bin/bash\\nexec haskell-language-server-wrapper --lsp \\\"$@\\\"\\n\"\n  liftIO $ System.Process.callCommand $ \"chmod +x \" ++ wrapperPath\n\n  runSessionWithConfig productionConfig wrapperPath fullLatestClientCaps rootDir $ do\n    liftIO $ hPutStrLn stderr \"[LSP] Session started, HLS initialized\"\n\n    -- Provide session handle to caller\n    let session = LSPSession requestChan\n\n    -- Fork user action in a separate thread so we can process requests\n    liftIO $ do\n      _ <- forkIO $ do\n        result <- try @SomeException (action session)\n        putMVar resultMVar result\n        putMVar doneMVar ()  -- Signal completion\n      pure ()\n\n    -- Process requests until user action completes\n    -- This loop runs inside the Session monad\n", "criteria": "CRITERIA_0741", "selected": "SELECTED_0741", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "withLSPSession", "range": {"end": {"character": 14, "line": 88}, "start": {"character": 0, "line": 88}}}
{"example_id": "0742", "variation": "positive_semantic", "code": "withLSPSession rootDir action = do\n  -- Create request channel for communication with worker\n  requestChan <- newChan\n  resultMVar <- newEmptyMVar\n  doneMVar <- newEmptyMVar  -- Signal when user action completes\n\n  -- lsp-test's runSessionWithConfig spawns HLS and handles handshake\n  -- The session runs until we're done or HLS crashes\n  --\n  -- Note: lsp-test doesn't pass --lsp flag by default, so we use a wrapper script\n  -- Create wrapper if not exists (idempotent)\n  let wrapperPath = \"/tmp/tidepool-hls-wrapper\"\n  liftIO $ writeFile wrapperPath \"#!/bin/bash\\nexec haskell-language-server-wrapper --lsp \\\"$@\\\"\\n\"\n  liftIO $ System.Process.callCommand $ \"chmod +x \" ++ wrapperPath\n\n  runSessionWithConfig productionConfig wrapperPath fullLatestClientCaps rootDir $ do\n    liftIO $ hPutStrLn stderr \"[LSP] Session started, HLS initialized\"\n\n    -- Provide session handle to caller\n    let session = LSPSession requestChan\n\n    -- Fork user action in a separate thread so we can process requests\n    liftIO $ do\n      _ <- forkIO $ do\n        result <- try @SomeException (action session)\n        putMVar resultMVar result\n        putMVar doneMVar ()  -- Signal completion\n      pure ()\n\n    -- Process requests until user action completes\n    -- This loop runs inside the Session monad\n", "criteria": "CRITERIA_0742", "selected": "SELECTED_0742", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "withLSPSession", "range": {"end": {"character": 14, "line": 88}, "start": {"character": 0, "line": 88}}}
{"example_id": "0743", "variation": "negative_1", "code": "withLSPSession rootDir action = do\n  -- Create request channel for communication with worker\n  requestChan <- newChan\n  resultMVar <- newEmptyMVar\n  doneMVar <- newEmptyMVar  -- Signal when user action completes\n\n  -- lsp-test's runSessionWithConfig spawns HLS and handles handshake\n  -- The session runs until we're done or HLS crashes\n  --\n  -- Note: lsp-test doesn't pass --lsp flag by default, so we use a wrapper script\n  -- Create wrapper if not exists (idempotent)\n  let wrapperPath = \"/tmp/tidepool-hls-wrapper\"\n  liftIO $ writeFile wrapperPath \"#!/bin/bash\\nexec haskell-language-server-wrapper --lsp \\\"$@\\\"\\n\"\n  liftIO $ System.Process.callCommand $ \"chmod +x \" ++ wrapperPath\n\n  runSessionWithConfig productionConfig wrapperPath fullLatestClientCaps rootDir $ do\n    liftIO $ hPutStrLn stderr \"[LSP] Session started, HLS initialized\"\n\n    -- Provide session handle to caller\n    let session = LSPSession requestChan\n\n    -- Fork user action in a separate thread so we can process requests\n    liftIO $ do\n      _ <- forkIO $ do\n        result <- try @SomeException (action session)\n        putMVar resultMVar result\n        putMVar doneMVar ()  -- Signal completion\n      pure ()\n\n    -- Process requests until user action completes\n    -- This loop runs inside the Session monad\n", "criteria": "CRITERIA_0743", "selected": "SELECTED_0743", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "withLSPSession", "range": {"end": {"character": 14, "line": 88}, "start": {"character": 0, "line": 88}}}
{"example_id": "0744", "variation": "negative_2", "code": "withLSPSession rootDir action = do\n  -- Create request channel for communication with worker\n  requestChan <- newChan\n  resultMVar <- newEmptyMVar\n  doneMVar <- newEmptyMVar  -- Signal when user action completes\n\n  -- lsp-test's runSessionWithConfig spawns HLS and handles handshake\n  -- The session runs until we're done or HLS crashes\n  --\n  -- Note: lsp-test doesn't pass --lsp flag by default, so we use a wrapper script\n  -- Create wrapper if not exists (idempotent)\n  let wrapperPath = \"/tmp/tidepool-hls-wrapper\"\n  liftIO $ writeFile wrapperPath \"#!/bin/bash\\nexec haskell-language-server-wrapper --lsp \\\"$@\\\"\\n\"\n  liftIO $ System.Process.callCommand $ \"chmod +x \" ++ wrapperPath\n\n  runSessionWithConfig productionConfig wrapperPath fullLatestClientCaps rootDir $ do\n    liftIO $ hPutStrLn stderr \"[LSP] Session started, HLS initialized\"\n\n    -- Provide session handle to caller\n    let session = LSPSession requestChan\n\n    -- Fork user action in a separate thread so we can process requests\n    liftIO $ do\n      _ <- forkIO $ do\n        result <- try @SomeException (action session)\n        putMVar resultMVar result\n        putMVar doneMVar ()  -- Signal completion\n      pure ()\n\n    -- Process requests until user action completes\n    -- This loop runs inside the Session monad\n", "criteria": "CRITERIA_0744", "selected": "SELECTED_0744", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "withLSPSession", "range": {"end": {"character": 14, "line": 88}, "start": {"character": 0, "line": 88}}}
{"example_id": "0745", "variation": "positive_structure", "code": "withGameDB path action = bracket (open path) close $ \\conn -> do\n  initDB conn\n  action conn\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GAME OPERATIONS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Create a new game with initial world state\n", "criteria": "CRITERIA_0745", "selected": "SELECTED_0745", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "withGameDB", "range": {"end": {"character": 10, "line": 117}, "start": {"character": 0, "line": 117}}}
{"example_id": "0746", "variation": "positive_semantic", "code": "withGameDB path action = bracket (open path) close $ \\conn -> do\n  initDB conn\n  action conn\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GAME OPERATIONS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Create a new game with initial world state\n", "criteria": "CRITERIA_0746", "selected": "SELECTED_0746", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "withGameDB", "range": {"end": {"character": 10, "line": 117}, "start": {"character": 0, "line": 117}}}
{"example_id": "0747", "variation": "negative_1", "code": "withGameDB path action = bracket (open path) close $ \\conn -> do\n  initDB conn\n  action conn\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GAME OPERATIONS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Create a new game with initial world state\n", "criteria": "CRITERIA_0747", "selected": "SELECTED_0747", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "withGameDB", "range": {"end": {"character": 10, "line": 117}, "start": {"character": 0, "line": 117}}}
{"example_id": "0748", "variation": "negative_2", "code": "withGameDB path action = bracket (open path) close $ \\conn -> do\n  initDB conn\n  action conn\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- GAME OPERATIONS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Create a new game with initial world state\n", "criteria": "CRITERIA_0748", "selected": "SELECTED_0748", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "withGameDB", "range": {"end": {"character": 10, "line": 117}, "start": {"character": 0, "line": 117}}}
{"example_id": "0749", "variation": "positive_structure", "code": "parseArriveMessage = parseEither $ Aeson.withObject \"ArriveMessage\" $ \\o -> do\n  barrier <- o .: \"barrier\"\n  -- Try to get source, default to barrier name if missing\n  source <- o Aeson..:? \"source\" Aeson..!= barrier\n  payload <- o .: \"payload\"\n  pure (barrier, source, payload)\n", "criteria": "CRITERIA_0749", "selected": "SELECTED_0749", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "parseArriveMessage", "range": {"end": {"character": 18, "line": 558}, "start": {"character": 0, "line": 558}}}
{"example_id": "0750", "variation": "positive_semantic", "code": "parseArriveMessage = parseEither $ Aeson.withObject \"ArriveMessage\" $ \\o -> do\n  barrier <- o .: \"barrier\"\n  -- Try to get source, default to barrier name if missing\n  source <- o Aeson..:? \"source\" Aeson..!= barrier\n  payload <- o .: \"payload\"\n  pure (barrier, source, payload)\n", "criteria": "CRITERIA_0750", "selected": "SELECTED_0750", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "parseArriveMessage", "range": {"end": {"character": 18, "line": 558}, "start": {"character": 0, "line": 558}}}
{"example_id": "0751", "variation": "negative_1", "code": "parseArriveMessage = parseEither $ Aeson.withObject \"ArriveMessage\" $ \\o -> do\n  barrier <- o .: \"barrier\"\n  -- Try to get source, default to barrier name if missing\n  source <- o Aeson..:? \"source\" Aeson..!= barrier\n  payload <- o .: \"payload\"\n  pure (barrier, source, payload)\n", "criteria": "CRITERIA_0751", "selected": "SELECTED_0751", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "parseArriveMessage", "range": {"end": {"character": 18, "line": 558}, "start": {"character": 0, "line": 558}}}
{"example_id": "0752", "variation": "negative_2", "code": "parseArriveMessage = parseEither $ Aeson.withObject \"ArriveMessage\" $ \\o -> do\n  barrier <- o .: \"barrier\"\n  -- Try to get source, default to barrier name if missing\n  source <- o Aeson..:? \"source\" Aeson..!= barrier\n  payload <- o .: \"payload\"\n  pure (barrier, source, payload)\n", "criteria": "CRITERIA_0752", "selected": "SELECTED_0752", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "parseArriveMessage", "range": {"end": {"character": 18, "line": 558}, "start": {"character": 0, "line": 558}}}
{"example_id": "0753", "variation": "positive_structure", "code": "parseBaseUrl url =\n  let -- Strip trailing slash if present\n      cleanUrl = case T.stripSuffix \"/\" url of\n        Just t  -> t\n        Nothing -> url\n      -- Check for scheme\n      (scheme, rest) = case T.stripPrefix \"https://\" cleanUrl of\n        Just r -> (Https, T.unpack r)\n        Nothing -> case T.stripPrefix \"http://\" cleanUrl of\n          Just r -> (Http, T.unpack r)\n          Nothing -> (Https, T.unpack cleanUrl)\n      -- Default port based on scheme\n      defaultPort = if scheme == Https then 443 else 80\n      -- Split host and path\n      (hostPort, path) = break (== '/') rest\n      -- Split host and port (safely)\n      (host, port) = case break (== ':') hostPort of\n        (h, ':':p) -> case safeReadPort p of\n          Just port' -> (h, port')\n          Nothing    -> (h, defaultPort)\n        (h, _) -> (h, defaultPort)\n      -- Safe port parsing\n      safeReadPort :: String -> Maybe Int\n      safeReadPort s = case reads s of\n        [(n, \"\")] -> Just n\n        _         -> Nothing\n  in BaseUrl scheme host port path\n\n-- | Convert servant-client errors to LLMError.\n--\n-- Note: Error messages are sanitized to avoid leaking credentials.\n", "criteria": "CRITERIA_0753", "selected": "SELECTED_0753", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "parseBaseUrl", "range": {"end": {"character": 12, "line": 185}, "start": {"character": 0, "line": 185}}}
{"example_id": "0754", "variation": "positive_semantic", "code": "parseBaseUrl url =\n  let -- Strip trailing slash if present\n      cleanUrl = case T.stripSuffix \"/\" url of\n        Just t  -> t\n        Nothing -> url\n      -- Check for scheme\n      (scheme, rest) = case T.stripPrefix \"https://\" cleanUrl of\n        Just r -> (Https, T.unpack r)\n        Nothing -> case T.stripPrefix \"http://\" cleanUrl of\n          Just r -> (Http, T.unpack r)\n          Nothing -> (Https, T.unpack cleanUrl)\n      -- Default port based on scheme\n      defaultPort = if scheme == Https then 443 else 80\n      -- Split host and path\n      (hostPort, path) = break (== '/') rest\n      -- Split host and port (safely)\n      (host, port) = case break (== ':') hostPort of\n        (h, ':':p) -> case safeReadPort p of\n          Just port' -> (h, port')\n          Nothing    -> (h, defaultPort)\n        (h, _) -> (h, defaultPort)\n      -- Safe port parsing\n      safeReadPort :: String -> Maybe Int\n      safeReadPort s = case reads s of\n        [(n, \"\")] -> Just n\n        _         -> Nothing\n  in BaseUrl scheme host port path\n\n-- | Convert servant-client errors to LLMError.\n--\n-- Note: Error messages are sanitized to avoid leaking credentials.\n", "criteria": "CRITERIA_0754", "selected": "SELECTED_0754", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "parseBaseUrl", "range": {"end": {"character": 12, "line": 185}, "start": {"character": 0, "line": 185}}}
{"example_id": "0755", "variation": "negative_1", "code": "parseBaseUrl url =\n  let -- Strip trailing slash if present\n      cleanUrl = case T.stripSuffix \"/\" url of\n        Just t  -> t\n        Nothing -> url\n      -- Check for scheme\n      (scheme, rest) = case T.stripPrefix \"https://\" cleanUrl of\n        Just r -> (Https, T.unpack r)\n        Nothing -> case T.stripPrefix \"http://\" cleanUrl of\n          Just r -> (Http, T.unpack r)\n          Nothing -> (Https, T.unpack cleanUrl)\n      -- Default port based on scheme\n      defaultPort = if scheme == Https then 443 else 80\n      -- Split host and path\n      (hostPort, path) = break (== '/') rest\n      -- Split host and port (safely)\n      (host, port) = case break (== ':') hostPort of\n        (h, ':':p) -> case safeReadPort p of\n          Just port' -> (h, port')\n          Nothing    -> (h, defaultPort)\n        (h, _) -> (h, defaultPort)\n      -- Safe port parsing\n      safeReadPort :: String -> Maybe Int\n      safeReadPort s = case reads s of\n        [(n, \"\")] -> Just n\n        _         -> Nothing\n  in BaseUrl scheme host port path\n\n-- | Convert servant-client errors to LLMError.\n--\n-- Note: Error messages are sanitized to avoid leaking credentials.\n", "criteria": "CRITERIA_0755", "selected": "SELECTED_0755", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "parseBaseUrl", "range": {"end": {"character": 12, "line": 185}, "start": {"character": 0, "line": 185}}}
{"example_id": "0756", "variation": "negative_2", "code": "parseBaseUrl url =\n  let -- Strip trailing slash if present\n      cleanUrl = case T.stripSuffix \"/\" url of\n        Just t  -> t\n        Nothing -> url\n      -- Check for scheme\n      (scheme, rest) = case T.stripPrefix \"https://\" cleanUrl of\n        Just r -> (Https, T.unpack r)\n        Nothing -> case T.stripPrefix \"http://\" cleanUrl of\n          Just r -> (Http, T.unpack r)\n          Nothing -> (Https, T.unpack cleanUrl)\n      -- Default port based on scheme\n      defaultPort = if scheme == Https then 443 else 80\n      -- Split host and path\n      (hostPort, path) = break (== '/') rest\n      -- Split host and port (safely)\n      (host, port) = case break (== ':') hostPort of\n        (h, ':':p) -> case safeReadPort p of\n          Just port' -> (h, port')\n          Nothing    -> (h, defaultPort)\n        (h, _) -> (h, defaultPort)\n      -- Safe port parsing\n      safeReadPort :: String -> Maybe Int\n      safeReadPort s = case reads s of\n        [(n, \"\")] -> Just n\n        _         -> Nothing\n  in BaseUrl scheme host port path\n\n-- | Convert servant-client errors to LLMError.\n--\n-- Note: Error messages are sanitized to avoid leaking credentials.\n", "criteria": "CRITERIA_0756", "selected": "SELECTED_0756", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "parseBaseUrl", "range": {"end": {"character": 12, "line": 185}, "start": {"character": 0, "line": 185}}}
{"example_id": "0757", "variation": "positive_structure", "code": "parseArriveWithSource = parseEither $ Aeson.withObject \"ArriveWithSource\" $ \\o -> do\n  source <- o .: \"source\"\n  payload <- o .: \"payload\"\n  pure (source, payload)\n", "criteria": "CRITERIA_0757", "selected": "SELECTED_0757", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Barrier.hs", "name": "parseArriveWithSource", "range": {"end": {"character": 21, "line": 198}, "start": {"character": 0, "line": 198}}}
{"example_id": "0758", "variation": "positive_semantic", "code": "parseArriveWithSource = parseEither $ Aeson.withObject \"ArriveWithSource\" $ \\o -> do\n  source <- o .: \"source\"\n  payload <- o .: \"payload\"\n  pure (source, payload)\n", "criteria": "CRITERIA_0758", "selected": "SELECTED_0758", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Barrier.hs", "name": "parseArriveWithSource", "range": {"end": {"character": 21, "line": 198}, "start": {"character": 0, "line": 198}}}
{"example_id": "0759", "variation": "negative_1", "code": "parseArriveWithSource = parseEither $ Aeson.withObject \"ArriveWithSource\" $ \\o -> do\n  source <- o .: \"source\"\n  payload <- o .: \"payload\"\n  pure (source, payload)\n", "criteria": "CRITERIA_0759", "selected": "SELECTED_0759", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Barrier.hs", "name": "parseArriveWithSource", "range": {"end": {"character": 21, "line": 198}, "start": {"character": 0, "line": 198}}}
{"example_id": "0760", "variation": "negative_2", "code": "parseArriveWithSource = parseEither $ Aeson.withObject \"ArriveWithSource\" $ \\o -> do\n  source <- o .: \"source\"\n  payload <- o .: \"payload\"\n  pure (source, payload)\n", "criteria": "CRITERIA_0760", "selected": "SELECTED_0760", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Barrier.hs", "name": "parseArriveWithSource", "range": {"end": {"character": 21, "line": 198}, "start": {"character": 0, "line": 198}}}
{"example_id": "0761", "variation": "positive_structure", "code": "parseAllDependencies content =\n  (parseTemplateIncludes content, parseTemplateExtends content)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- PARSEC PARSERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Parser for all {% include \"...\" %} directives in a template.\n", "criteria": "CRITERIA_0761", "selected": "SELECTED_0761", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseAllDependencies", "range": {"end": {"character": 20, "line": 227}, "start": {"character": 0, "line": 227}}}
{"example_id": "0762", "variation": "positive_semantic", "code": "parseAllDependencies content =\n  (parseTemplateIncludes content, parseTemplateExtends content)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- PARSEC PARSERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Parser for all {% include \"...\" %} directives in a template.\n", "criteria": "CRITERIA_0762", "selected": "SELECTED_0762", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseAllDependencies", "range": {"end": {"character": 20, "line": 227}, "start": {"character": 0, "line": 227}}}
{"example_id": "0763", "variation": "negative_1", "code": "parseAllDependencies content =\n  (parseTemplateIncludes content, parseTemplateExtends content)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- PARSEC PARSERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Parser for all {% include \"...\" %} directives in a template.\n", "criteria": "CRITERIA_0763", "selected": "SELECTED_0763", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseAllDependencies", "range": {"end": {"character": 20, "line": 227}, "start": {"character": 0, "line": 227}}}
{"example_id": "0764", "variation": "negative_2", "code": "parseAllDependencies content =\n  (parseTemplateIncludes content, parseTemplateExtends content)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- PARSEC PARSERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Parser for all {% include \"...\" %} directives in a template.\n", "criteria": "CRITERIA_0764", "selected": "SELECTED_0764", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseAllDependencies", "range": {"end": {"character": 20, "line": 227}, "start": {"character": 0, "line": 227}}}
{"example_id": "0765", "variation": "positive_structure", "code": "parseTemplateExtends content =\n  case parse extendsParser \"\" content of\n    Left _ -> []\n    Right paths -> paths\n\n-- | Parse a template for all dependency directives.\n--\n-- Returns (includes, extends) tuple.\n", "criteria": "CRITERIA_0765", "selected": "SELECTED_0765", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseTemplateExtends", "range": {"end": {"character": 20, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0766", "variation": "positive_semantic", "code": "parseTemplateExtends content =\n  case parse extendsParser \"\" content of\n    Left _ -> []\n    Right paths -> paths\n\n-- | Parse a template for all dependency directives.\n--\n-- Returns (includes, extends) tuple.\n", "criteria": "CRITERIA_0766", "selected": "SELECTED_0766", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseTemplateExtends", "range": {"end": {"character": 20, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0767", "variation": "negative_1", "code": "parseTemplateExtends content =\n  case parse extendsParser \"\" content of\n    Left _ -> []\n    Right paths -> paths\n\n-- | Parse a template for all dependency directives.\n--\n-- Returns (includes, extends) tuple.\n", "criteria": "CRITERIA_0767", "selected": "SELECTED_0767", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseTemplateExtends", "range": {"end": {"character": 20, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0768", "variation": "negative_2", "code": "parseTemplateExtends content =\n  case parse extendsParser \"\" content of\n    Left _ -> []\n    Right paths -> paths\n\n-- | Parse a template for all dependency directives.\n--\n-- Returns (includes, extends) tuple.\n", "criteria": "CRITERIA_0768", "selected": "SELECTED_0768", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseTemplateExtends", "range": {"end": {"character": 20, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0769", "variation": "positive_structure", "code": "parseTemplateIncludes content =\n  case parse includesParser \"\" content of\n    Left _ -> []\n    Right paths -> paths\n\n-- | Parse a template for {% extends \"...\" %} directives.\n--\n-- Returns a list of extended template paths.\n", "criteria": "CRITERIA_0769", "selected": "SELECTED_0769", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseTemplateIncludes", "range": {"end": {"character": 21, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0770", "variation": "positive_semantic", "code": "parseTemplateIncludes content =\n  case parse includesParser \"\" content of\n    Left _ -> []\n    Right paths -> paths\n\n-- | Parse a template for {% extends \"...\" %} directives.\n--\n-- Returns a list of extended template paths.\n", "criteria": "CRITERIA_0770", "selected": "SELECTED_0770", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseTemplateIncludes", "range": {"end": {"character": 21, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0771", "variation": "negative_1", "code": "parseTemplateIncludes content =\n  case parse includesParser \"\" content of\n    Left _ -> []\n    Right paths -> paths\n\n-- | Parse a template for {% extends \"...\" %} directives.\n--\n-- Returns a list of extended template paths.\n", "criteria": "CRITERIA_0771", "selected": "SELECTED_0771", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseTemplateIncludes", "range": {"end": {"character": 21, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0772", "variation": "negative_2", "code": "parseTemplateIncludes content =\n  case parse includesParser \"\" content of\n    Left _ -> []\n    Right paths -> paths\n\n-- | Parse a template for {% extends \"...\" %} directives.\n--\n-- Returns a list of extended template paths.\n", "criteria": "CRITERIA_0772", "selected": "SELECTED_0772", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "parseTemplateIncludes", "range": {"end": {"character": 21, "line": 209}, "start": {"character": 0, "line": 209}}}
{"example_id": "0773", "variation": "positive_structure", "code": "parseSelectionResponse body = do\n  json <- case Aeson.decode body of\n    Nothing -> Left \"Failed to parse JSON response\"\n    Just v  -> Right (v :: Value)\n\n  -- Extract message.tool_calls[0].function.arguments.selected (array)\n  extractSelectedFromToolCall json\n\n\n-- | Extract selected symbols array from Ollama tool call response.\n--\n-- Response format:\n-- {\n--   \"message\": {\n--     \"tool_calls\": [{\n--       \"function\": {\n--         \"arguments\": { \"selected\": [\"ScoreConfig\", \"EdgeContext\"] }\n--       }\n--     }]\n--   }\n-- }\n", "criteria": "CRITERIA_0773", "selected": "SELECTED_0773", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "parseSelectionResponse", "range": {"end": {"character": 22, "line": 287}, "start": {"character": 0, "line": 287}}}
{"example_id": "0774", "variation": "positive_semantic", "code": "parseSelectionResponse body = do\n  json <- case Aeson.decode body of\n    Nothing -> Left \"Failed to parse JSON response\"\n    Just v  -> Right (v :: Value)\n\n  -- Extract message.tool_calls[0].function.arguments.selected (array)\n  extractSelectedFromToolCall json\n\n\n-- | Extract selected symbols array from Ollama tool call response.\n--\n-- Response format:\n-- {\n--   \"message\": {\n--     \"tool_calls\": [{\n--       \"function\": {\n--         \"arguments\": { \"selected\": [\"ScoreConfig\", \"EdgeContext\"] }\n--       }\n--     }]\n--   }\n-- }\n", "criteria": "CRITERIA_0774", "selected": "SELECTED_0774", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "parseSelectionResponse", "range": {"end": {"character": 22, "line": 287}, "start": {"character": 0, "line": 287}}}
{"example_id": "0775", "variation": "negative_1", "code": "parseSelectionResponse body = do\n  json <- case Aeson.decode body of\n    Nothing -> Left \"Failed to parse JSON response\"\n    Just v  -> Right (v :: Value)\n\n  -- Extract message.tool_calls[0].function.arguments.selected (array)\n  extractSelectedFromToolCall json\n\n\n-- | Extract selected symbols array from Ollama tool call response.\n--\n-- Response format:\n-- {\n--   \"message\": {\n--     \"tool_calls\": [{\n--       \"function\": {\n--         \"arguments\": { \"selected\": [\"ScoreConfig\", \"EdgeContext\"] }\n--       }\n--     }]\n--   }\n-- }\n", "criteria": "CRITERIA_0775", "selected": "SELECTED_0775", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "parseSelectionResponse", "range": {"end": {"character": 22, "line": 287}, "start": {"character": 0, "line": 287}}}
{"example_id": "0776", "variation": "negative_2", "code": "parseSelectionResponse body = do\n  json <- case Aeson.decode body of\n    Nothing -> Left \"Failed to parse JSON response\"\n    Just v  -> Right (v :: Value)\n\n  -- Extract message.tool_calls[0].function.arguments.selected (array)\n  extractSelectedFromToolCall json\n\n\n-- | Extract selected symbols array from Ollama tool call response.\n--\n-- Response format:\n-- {\n--   \"message\": {\n--     \"tool_calls\": [{\n--       \"function\": {\n--         \"arguments\": { \"selected\": [\"ScoreConfig\", \"EdgeContext\"] }\n--       }\n--     }]\n--   }\n-- }\n", "criteria": "CRITERIA_0776", "selected": "SELECTED_0776", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "parseSelectionResponse", "range": {"end": {"character": 22, "line": 287}, "start": {"character": 0, "line": 287}}}
{"example_id": "0777", "variation": "positive_structure", "code": "parseSymbolTokens raw =\n  filter isValidSymbol\n  $ map T.strip\n  $ concatMap (T.splitOn \",\")\n  $ T.words raw\n  where\n    -- Valid symbols start with uppercase letter\n    isValidSymbol t = case T.uncons t of\n      Just (c, _) -> c >= 'A' && c <= 'Z' && not (T.null t)\n      Nothing -> False\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- MOCK INTERPRETER (Testing)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Mock interpreter for testing.\n--\n-- Simply returns all candidates (no filtering). Useful for testing the\n-- exploration loop without Gemma dependency.\n", "criteria": "CRITERIA_0777", "selected": "SELECTED_0777", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "parseSymbolTokens", "range": {"end": {"character": 17, "line": 350}, "start": {"character": 0, "line": 350}}}
{"example_id": "0778", "variation": "positive_semantic", "code": "parseSymbolTokens raw =\n  filter isValidSymbol\n  $ map T.strip\n  $ concatMap (T.splitOn \",\")\n  $ T.words raw\n  where\n    -- Valid symbols start with uppercase letter\n    isValidSymbol t = case T.uncons t of\n      Just (c, _) -> c >= 'A' && c <= 'Z' && not (T.null t)\n      Nothing -> False\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- MOCK INTERPRETER (Testing)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Mock interpreter for testing.\n--\n-- Simply returns all candidates (no filtering). Useful for testing the\n-- exploration loop without Gemma dependency.\n", "criteria": "CRITERIA_0778", "selected": "SELECTED_0778", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "parseSymbolTokens", "range": {"end": {"character": 17, "line": 350}, "start": {"character": 0, "line": 350}}}
{"example_id": "0779", "variation": "negative_1", "code": "parseSymbolTokens raw =\n  filter isValidSymbol\n  $ map T.strip\n  $ concatMap (T.splitOn \",\")\n  $ T.words raw\n  where\n    -- Valid symbols start with uppercase letter\n    isValidSymbol t = case T.uncons t of\n      Just (c, _) -> c >= 'A' && c <= 'Z' && not (T.null t)\n      Nothing -> False\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- MOCK INTERPRETER (Testing)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Mock interpreter for testing.\n--\n-- Simply returns all candidates (no filtering). Useful for testing the\n-- exploration loop without Gemma dependency.\n", "criteria": "CRITERIA_0779", "selected": "SELECTED_0779", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "parseSymbolTokens", "range": {"end": {"character": 17, "line": 350}, "start": {"character": 0, "line": 350}}}
{"example_id": "0780", "variation": "negative_2", "code": "parseSymbolTokens raw =\n  filter isValidSymbol\n  $ map T.strip\n  $ concatMap (T.splitOn \",\")\n  $ T.words raw\n  where\n    -- Valid symbols start with uppercase letter\n    isValidSymbol t = case T.uncons t of\n      Just (c, _) -> c >= 'A' && c <= 'Z' && not (T.null t)\n      Nothing -> False\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- MOCK INTERPRETER (Testing)\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Mock interpreter for testing.\n--\n-- Simply returns all candidates (no filtering). Useful for testing the\n-- exploration loop without Gemma dependency.\n", "criteria": "CRITERIA_0780", "selected": "SELECTED_0780", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "parseSymbolTokens", "range": {"end": {"character": 17, "line": 350}, "start": {"character": 0, "line": 350}}}
{"example_id": "0781", "variation": "positive_structure", "code": "parseHoverContent content =\n  let lns = T.lines content\n      -- Find code block\n      (codeLines, docLines) = span (/= \"```\") (drop 1 $ dropWhile (/= \"```haskell\") lns)\n      sig = T.strip $ T.unlines codeLines\n      doc = case dropWhile (== \"```\") docLines of\n        [] -> Nothing\n        ds -> let d = T.strip $ T.unlines ds\n              in if T.null d then Nothing else Just d\n  in if T.null sig\n     then (content, Nothing)  -- Fall back to raw content\n     else (sig, doc)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- DOCUMENT BUILDING\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Build a teaching document from the exploration graph.\n--\n-- Groups by BFS depth:\n--   - Depth 0: Core (seed symbols)\n--   - Depth 1-2: Prerequisites\n--   - Depth 3+: Support\n", "criteria": "CRITERIA_0781", "selected": "SELECTED_0781", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach.hs", "name": "parseHoverContent", "range": {"end": {"character": 17, "line": 341}, "start": {"character": 0, "line": 341}}}
{"example_id": "0782", "variation": "positive_semantic", "code": "parseHoverContent content =\n  let lns = T.lines content\n      -- Find code block\n      (codeLines, docLines) = span (/= \"```\") (drop 1 $ dropWhile (/= \"```haskell\") lns)\n      sig = T.strip $ T.unlines codeLines\n      doc = case dropWhile (== \"```\") docLines of\n        [] -> Nothing\n        ds -> let d = T.strip $ T.unlines ds\n              in if T.null d then Nothing else Just d\n  in if T.null sig\n     then (content, Nothing)  -- Fall back to raw content\n     else (sig, doc)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- DOCUMENT BUILDING\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Build a teaching document from the exploration graph.\n--\n-- Groups by BFS depth:\n--   - Depth 0: Core (seed symbols)\n--   - Depth 1-2: Prerequisites\n--   - Depth 3+: Support\n", "criteria": "CRITERIA_0782", "selected": "SELECTED_0782", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach.hs", "name": "parseHoverContent", "range": {"end": {"character": 17, "line": 341}, "start": {"character": 0, "line": 341}}}
{"example_id": "0783", "variation": "negative_1", "code": "parseHoverContent content =\n  let lns = T.lines content\n      -- Find code block\n      (codeLines, docLines) = span (/= \"```\") (drop 1 $ dropWhile (/= \"```haskell\") lns)\n      sig = T.strip $ T.unlines codeLines\n      doc = case dropWhile (== \"```\") docLines of\n        [] -> Nothing\n        ds -> let d = T.strip $ T.unlines ds\n              in if T.null d then Nothing else Just d\n  in if T.null sig\n     then (content, Nothing)  -- Fall back to raw content\n     else (sig, doc)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- DOCUMENT BUILDING\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Build a teaching document from the exploration graph.\n--\n-- Groups by BFS depth:\n--   - Depth 0: Core (seed symbols)\n--   - Depth 1-2: Prerequisites\n--   - Depth 3+: Support\n", "criteria": "CRITERIA_0783", "selected": "SELECTED_0783", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach.hs", "name": "parseHoverContent", "range": {"end": {"character": 17, "line": 341}, "start": {"character": 0, "line": 341}}}
{"example_id": "0784", "variation": "negative_2", "code": "parseHoverContent content =\n  let lns = T.lines content\n      -- Find code block\n      (codeLines, docLines) = span (/= \"```\") (drop 1 $ dropWhile (/= \"```haskell\") lns)\n      sig = T.strip $ T.unlines codeLines\n      doc = case dropWhile (== \"```\") docLines of\n        [] -> Nothing\n        ds -> let d = T.strip $ T.unlines ds\n              in if T.null d then Nothing else Just d\n  in if T.null sig\n     then (content, Nothing)  -- Fall back to raw content\n     else (sig, doc)\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- DOCUMENT BUILDING\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Build a teaching document from the exploration graph.\n--\n-- Groups by BFS depth:\n--   - Depth 0: Core (seed symbols)\n--   - Depth 1-2: Prerequisites\n--   - Depth 3+: Support\n", "criteria": "CRITERIA_0784", "selected": "SELECTED_0784", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach.hs", "name": "parseHoverContent", "range": {"end": {"character": 17, "line": 341}, "start": {"character": 0, "line": 341}}}
{"example_id": "0785", "variation": "positive_structure", "code": "parseSignatureTypes sig =\n  let -- Strip constraints (everything before =>)\n      afterConstraints = case T.breakOn \"=>\" sig of\n        (_, rest) | not (T.null rest) -> T.drop 2 rest  -- Skip \"=>\"\n        _ -> sig\n\n      -- Split by top-level arrows (not inside parens/brackets)\n      parts = splitByArrow $ T.strip afterConstraints\n\n      -- Last part is the output, rest are inputs\n      (inputs, output) = case reverse parts of\n        [] -> ([], [])\n        [single] -> ([], extractTypes single)  -- No arrows = just output\n        (out : rest) -> (concatMap extractTypes (reverse rest), extractTypes out)\n\n  in (inputs, output)\n  where\n    -- Split by \"->\" at top level (not inside parens)\n    splitByArrow :: Text -> [Text]\n    splitByArrow t = go 0 \"\" (T.unpack t)\n      where\n        go :: Int -> String -> String -> [Text]\n        go _ acc [] = [T.strip $ T.pack $ reverse acc]\n        go depth acc ('-':'>':rest)\n          | depth == 0 = T.strip (T.pack $ reverse acc) : go 0 \"\" rest\n        go depth acc ('(':rest) = go (depth + 1) ('(':acc) rest\n        go depth acc ('[':rest) = go (depth + 1) ('[':acc) rest\n        go depth acc (')':rest) = go (max 0 (depth - 1)) (')':acc) rest\n        go depth acc (']':rest) = go (max 0 (depth - 1)) (']':acc) rest\n        go depth acc (c:rest) = go depth (c:acc) rest\n\n", "criteria": "CRITERIA_0785", "selected": "SELECTED_0785", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "parseSignatureTypes", "range": {"end": {"character": 19, "line": 236}, "start": {"character": 0, "line": 236}}}
{"example_id": "0786", "variation": "positive_semantic", "code": "parseSignatureTypes sig =\n  let -- Strip constraints (everything before =>)\n      afterConstraints = case T.breakOn \"=>\" sig of\n        (_, rest) | not (T.null rest) -> T.drop 2 rest  -- Skip \"=>\"\n        _ -> sig\n\n      -- Split by top-level arrows (not inside parens/brackets)\n      parts = splitByArrow $ T.strip afterConstraints\n\n      -- Last part is the output, rest are inputs\n      (inputs, output) = case reverse parts of\n        [] -> ([], [])\n        [single] -> ([], extractTypes single)  -- No arrows = just output\n        (out : rest) -> (concatMap extractTypes (reverse rest), extractTypes out)\n\n  in (inputs, output)\n  where\n    -- Split by \"->\" at top level (not inside parens)\n    splitByArrow :: Text -> [Text]\n    splitByArrow t = go 0 \"\" (T.unpack t)\n      where\n        go :: Int -> String -> String -> [Text]\n        go _ acc [] = [T.strip $ T.pack $ reverse acc]\n        go depth acc ('-':'>':rest)\n          | depth == 0 = T.strip (T.pack $ reverse acc) : go 0 \"\" rest\n        go depth acc ('(':rest) = go (depth + 1) ('(':acc) rest\n        go depth acc ('[':rest) = go (depth + 1) ('[':acc) rest\n        go depth acc (')':rest) = go (max 0 (depth - 1)) (')':acc) rest\n        go depth acc (']':rest) = go (max 0 (depth - 1)) (']':acc) rest\n        go depth acc (c:rest) = go depth (c:acc) rest\n\n", "criteria": "CRITERIA_0786", "selected": "SELECTED_0786", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "parseSignatureTypes", "range": {"end": {"character": 19, "line": 236}, "start": {"character": 0, "line": 236}}}
{"example_id": "0787", "variation": "negative_1", "code": "parseSignatureTypes sig =\n  let -- Strip constraints (everything before =>)\n      afterConstraints = case T.breakOn \"=>\" sig of\n        (_, rest) | not (T.null rest) -> T.drop 2 rest  -- Skip \"=>\"\n        _ -> sig\n\n      -- Split by top-level arrows (not inside parens/brackets)\n      parts = splitByArrow $ T.strip afterConstraints\n\n      -- Last part is the output, rest are inputs\n      (inputs, output) = case reverse parts of\n        [] -> ([], [])\n        [single] -> ([], extractTypes single)  -- No arrows = just output\n        (out : rest) -> (concatMap extractTypes (reverse rest), extractTypes out)\n\n  in (inputs, output)\n  where\n    -- Split by \"->\" at top level (not inside parens)\n    splitByArrow :: Text -> [Text]\n    splitByArrow t = go 0 \"\" (T.unpack t)\n      where\n        go :: Int -> String -> String -> [Text]\n        go _ acc [] = [T.strip $ T.pack $ reverse acc]\n        go depth acc ('-':'>':rest)\n          | depth == 0 = T.strip (T.pack $ reverse acc) : go 0 \"\" rest\n        go depth acc ('(':rest) = go (depth + 1) ('(':acc) rest\n        go depth acc ('[':rest) = go (depth + 1) ('[':acc) rest\n        go depth acc (')':rest) = go (max 0 (depth - 1)) (')':acc) rest\n        go depth acc (']':rest) = go (max 0 (depth - 1)) (']':acc) rest\n        go depth acc (c:rest) = go depth (c:acc) rest\n\n", "criteria": "CRITERIA_0787", "selected": "SELECTED_0787", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "parseSignatureTypes", "range": {"end": {"character": 19, "line": 236}, "start": {"character": 0, "line": 236}}}
{"example_id": "0788", "variation": "negative_2", "code": "parseSignatureTypes sig =\n  let -- Strip constraints (everything before =>)\n      afterConstraints = case T.breakOn \"=>\" sig of\n        (_, rest) | not (T.null rest) -> T.drop 2 rest  -- Skip \"=>\"\n        _ -> sig\n\n      -- Split by top-level arrows (not inside parens/brackets)\n      parts = splitByArrow $ T.strip afterConstraints\n\n      -- Last part is the output, rest are inputs\n      (inputs, output) = case reverse parts of\n        [] -> ([], [])\n        [single] -> ([], extractTypes single)  -- No arrows = just output\n        (out : rest) -> (concatMap extractTypes (reverse rest), extractTypes out)\n\n  in (inputs, output)\n  where\n    -- Split by \"->\" at top level (not inside parens)\n    splitByArrow :: Text -> [Text]\n    splitByArrow t = go 0 \"\" (T.unpack t)\n      where\n        go :: Int -> String -> String -> [Text]\n        go _ acc [] = [T.strip $ T.pack $ reverse acc]\n        go depth acc ('-':'>':rest)\n          | depth == 0 = T.strip (T.pack $ reverse acc) : go 0 \"\" rest\n        go depth acc ('(':rest) = go (depth + 1) ('(':acc) rest\n        go depth acc ('[':rest) = go (depth + 1) ('[':acc) rest\n        go depth acc (')':rest) = go (max 0 (depth - 1)) (')':acc) rest\n        go depth acc (']':rest) = go (max 0 (depth - 1)) (']':acc) rest\n        go depth acc (c:rest) = go depth (c:acc) rest\n\n", "criteria": "CRITERIA_0788", "selected": "SELECTED_0788", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "parseSignatureTypes", "range": {"end": {"character": 19, "line": 236}, "start": {"character": 0, "line": 236}}}
{"example_id": "0789", "variation": "positive_structure", "code": "renderDependencyTree config tree = T.unlines $\n  [ \"flowchart \" <> config.ttcDirection\n  , \"\"\n  , \"    %% Template Dependencies\"\n  ]\n  ++ includeEdges\n  ++ extendsEdges\n  where\n    includeEdges =\n      [ \"    \" <> escapeName (displayPath config from)\n        <> \" \" <> config.ttcIncludeStyle <> \" \"\n        <> escapeName (displayPath config to)\n      | (from, tos) <- Map.toList (tree.dtIncludes)\n      , to <- tos\n      ]\n\n    extendsEdges =\n      [ \"    \" <> escapeName (displayPath config from)\n        <> \" \" <> config.ttcExtendsStyle <> \"|extends| \"\n        <> escapeName (displayPath config to)\n      | (from, tos) <- Map.toList (tree.dtExtends)\n      , to <- tos\n      ]\n\n-- | Display path according to config.\n", "criteria": "CRITERIA_0789", "selected": "SELECTED_0789", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "renderDependencyTree", "range": {"end": {"character": 20, "line": 106}, "start": {"character": 0, "line": 106}}}
{"example_id": "0790", "variation": "positive_semantic", "code": "renderDependencyTree config tree = T.unlines $\n  [ \"flowchart \" <> config.ttcDirection\n  , \"\"\n  , \"    %% Template Dependencies\"\n  ]\n  ++ includeEdges\n  ++ extendsEdges\n  where\n    includeEdges =\n      [ \"    \" <> escapeName (displayPath config from)\n        <> \" \" <> config.ttcIncludeStyle <> \" \"\n        <> escapeName (displayPath config to)\n      | (from, tos) <- Map.toList (tree.dtIncludes)\n      , to <- tos\n      ]\n\n    extendsEdges =\n      [ \"    \" <> escapeName (displayPath config from)\n        <> \" \" <> config.ttcExtendsStyle <> \"|extends| \"\n        <> escapeName (displayPath config to)\n      | (from, tos) <- Map.toList (tree.dtExtends)\n      , to <- tos\n      ]\n\n-- | Display path according to config.\n", "criteria": "CRITERIA_0790", "selected": "SELECTED_0790", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "renderDependencyTree", "range": {"end": {"character": 20, "line": 106}, "start": {"character": 0, "line": 106}}}
{"example_id": "0791", "variation": "negative_1", "code": "renderDependencyTree config tree = T.unlines $\n  [ \"flowchart \" <> config.ttcDirection\n  , \"\"\n  , \"    %% Template Dependencies\"\n  ]\n  ++ includeEdges\n  ++ extendsEdges\n  where\n    includeEdges =\n      [ \"    \" <> escapeName (displayPath config from)\n        <> \" \" <> config.ttcIncludeStyle <> \" \"\n        <> escapeName (displayPath config to)\n      | (from, tos) <- Map.toList (tree.dtIncludes)\n      , to <- tos\n      ]\n\n    extendsEdges =\n      [ \"    \" <> escapeName (displayPath config from)\n        <> \" \" <> config.ttcExtendsStyle <> \"|extends| \"\n        <> escapeName (displayPath config to)\n      | (from, tos) <- Map.toList (tree.dtExtends)\n      , to <- tos\n      ]\n\n-- | Display path according to config.\n", "criteria": "CRITERIA_0791", "selected": "SELECTED_0791", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "renderDependencyTree", "range": {"end": {"character": 20, "line": 106}, "start": {"character": 0, "line": 106}}}
{"example_id": "0792", "variation": "negative_2", "code": "renderDependencyTree config tree = T.unlines $\n  [ \"flowchart \" <> config.ttcDirection\n  , \"\"\n  , \"    %% Template Dependencies\"\n  ]\n  ++ includeEdges\n  ++ extendsEdges\n  where\n    includeEdges =\n      [ \"    \" <> escapeName (displayPath config from)\n        <> \" \" <> config.ttcIncludeStyle <> \" \"\n        <> escapeName (displayPath config to)\n      | (from, tos) <- Map.toList (tree.dtIncludes)\n      , to <- tos\n      ]\n\n    extendsEdges =\n      [ \"    \" <> escapeName (displayPath config from)\n        <> \" \" <> config.ttcExtendsStyle <> \"|extends| \"\n        <> escapeName (displayPath config to)\n      | (from, tos) <- Map.toList (tree.dtExtends)\n      , to <- tos\n      ]\n\n-- | Display path according to config.\n", "criteria": "CRITERIA_0792", "selected": "SELECTED_0792", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "renderDependencyTree", "range": {"end": {"character": 20, "line": 106}, "start": {"character": 0, "line": 106}}}
{"example_id": "0793", "variation": "positive_structure", "code": "renderTemplate = do\n  ctx <- buildContext @t\n  pure $ runTypedTemplate ctx (templateCompiled @t)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE HASKELL HELPER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate a compiled template binding.\n--\n-- This is a convenience helper that generates the top-level binding\n-- for the compiled template:\n--\n-- @\n-- $(makeTemplateCompiled ''MyContext \"templates/my.jinja\")\n-- @\n--\n-- Generates:\n--\n-- @\n-- myContext_compiled :: TypedTemplate MyContext SourcePos\n-- myContext_compiled = $(typedTemplateFile ''MyContext \"templates/my.jinja\")\n-- @\n--\n-- The binding name is derived from the context type name by appending\n-- @_compiled@ and lowercasing the first letter.\n", "criteria": "CRITERIA_0793", "selected": "SELECTED_0793", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Template.hs", "name": "renderTemplate", "range": {"end": {"character": 14, "line": 259}, "start": {"character": 0, "line": 259}}}
{"example_id": "0794", "variation": "positive_semantic", "code": "renderTemplate = do\n  ctx <- buildContext @t\n  pure $ runTypedTemplate ctx (templateCompiled @t)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE HASKELL HELPER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate a compiled template binding.\n--\n-- This is a convenience helper that generates the top-level binding\n-- for the compiled template:\n--\n-- @\n-- $(makeTemplateCompiled ''MyContext \"templates/my.jinja\")\n-- @\n--\n-- Generates:\n--\n-- @\n-- myContext_compiled :: TypedTemplate MyContext SourcePos\n-- myContext_compiled = $(typedTemplateFile ''MyContext \"templates/my.jinja\")\n-- @\n--\n-- The binding name is derived from the context type name by appending\n-- @_compiled@ and lowercasing the first letter.\n", "criteria": "CRITERIA_0794", "selected": "SELECTED_0794", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Template.hs", "name": "renderTemplate", "range": {"end": {"character": 14, "line": 259}, "start": {"character": 0, "line": 259}}}
{"example_id": "0795", "variation": "negative_1", "code": "renderTemplate = do\n  ctx <- buildContext @t\n  pure $ runTypedTemplate ctx (templateCompiled @t)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE HASKELL HELPER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate a compiled template binding.\n--\n-- This is a convenience helper that generates the top-level binding\n-- for the compiled template:\n--\n-- @\n-- $(makeTemplateCompiled ''MyContext \"templates/my.jinja\")\n-- @\n--\n-- Generates:\n--\n-- @\n-- myContext_compiled :: TypedTemplate MyContext SourcePos\n-- myContext_compiled = $(typedTemplateFile ''MyContext \"templates/my.jinja\")\n-- @\n--\n-- The binding name is derived from the context type name by appending\n-- @_compiled@ and lowercasing the first letter.\n", "criteria": "CRITERIA_0795", "selected": "SELECTED_0795", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Template.hs", "name": "renderTemplate", "range": {"end": {"character": 14, "line": 259}, "start": {"character": 0, "line": 259}}}
{"example_id": "0796", "variation": "negative_2", "code": "renderTemplate = do\n  ctx <- buildContext @t\n  pure $ runTypedTemplate ctx (templateCompiled @t)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE HASKELL HELPER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate a compiled template binding.\n--\n-- This is a convenience helper that generates the top-level binding\n-- for the compiled template:\n--\n-- @\n-- $(makeTemplateCompiled ''MyContext \"templates/my.jinja\")\n-- @\n--\n-- Generates:\n--\n-- @\n-- myContext_compiled :: TypedTemplate MyContext SourcePos\n-- myContext_compiled = $(typedTemplateFile ''MyContext \"templates/my.jinja\")\n-- @\n--\n-- The binding name is derived from the context type name by appending\n-- @_compiled@ and lowercasing the first letter.\n", "criteria": "CRITERIA_0796", "selected": "SELECTED_0796", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Template.hs", "name": "renderTemplate", "range": {"end": {"character": 14, "line": 259}, "start": {"character": 0, "line": 259}}}
{"example_id": "0797", "variation": "positive_structure", "code": "renderDepTree = T.unlines . renderLines \"\"\n  where\n    renderLines :: Text -> TemplateDependency -> [Text]\n    renderLines prefix dep =\n      (prefix <> T.pack dep.depRelativePath <> relationSuffix dep)\n      : concatMap (renderChild prefix) (withPosition $ sortedChildren dep)\n\n    renderChild :: Text -> (TemplateDependency, Bool) -> [Text]\n    renderChild prefix (child, isLast) =\n      let connector = if isLast then \"\u2514\u2500 \" else \"\u251c\u2500 \"\n          extension = if isLast then \"   \" else \"\u2502  \"\n          childPrefix = prefix <> \"   \"  -- Indent for children\n      in case child.depChildren of\n        [] -> [childPrefix <> connector <> T.pack child.depRelativePath <> relationSuffix child]\n        _  -> (childPrefix <> connector <> T.pack child.depRelativePath <> relationSuffix child)\n              : concatMap (renderChild (childPrefix <> extension)) (withPosition $ sortedChildren child)\n\n    relationSuffix :: TemplateDependency -> Text\n    relationSuffix dep = case dep.depRelation of\n      Just DepExtended -> \" (extends)\"\n      _ -> \"\"\n\n    -- Sort children by relative path for consistent output\n    sortedChildren :: TemplateDependency -> [TemplateDependency]\n    sortedChildren dep = sortOn (.depRelativePath) dep.depChildren\n\n    -- Tag each element with whether it's the last in the list\n    withPosition :: [a] -> [(a, Bool)]\n    withPosition [] = []\n    withPosition xs = zip xs (replicate (length xs - 1) False ++ [True])\n\n", "criteria": "CRITERIA_0797", "selected": "SELECTED_0797", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Docs.hs", "name": "renderDepTree", "range": {"end": {"character": 13, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0798", "variation": "positive_semantic", "code": "renderDepTree = T.unlines . renderLines \"\"\n  where\n    renderLines :: Text -> TemplateDependency -> [Text]\n    renderLines prefix dep =\n      (prefix <> T.pack dep.depRelativePath <> relationSuffix dep)\n      : concatMap (renderChild prefix) (withPosition $ sortedChildren dep)\n\n    renderChild :: Text -> (TemplateDependency, Bool) -> [Text]\n    renderChild prefix (child, isLast) =\n      let connector = if isLast then \"\u2514\u2500 \" else \"\u251c\u2500 \"\n          extension = if isLast then \"   \" else \"\u2502  \"\n          childPrefix = prefix <> \"   \"  -- Indent for children\n      in case child.depChildren of\n        [] -> [childPrefix <> connector <> T.pack child.depRelativePath <> relationSuffix child]\n        _  -> (childPrefix <> connector <> T.pack child.depRelativePath <> relationSuffix child)\n              : concatMap (renderChild (childPrefix <> extension)) (withPosition $ sortedChildren child)\n\n    relationSuffix :: TemplateDependency -> Text\n    relationSuffix dep = case dep.depRelation of\n      Just DepExtended -> \" (extends)\"\n      _ -> \"\"\n\n    -- Sort children by relative path for consistent output\n    sortedChildren :: TemplateDependency -> [TemplateDependency]\n    sortedChildren dep = sortOn (.depRelativePath) dep.depChildren\n\n    -- Tag each element with whether it's the last in the list\n    withPosition :: [a] -> [(a, Bool)]\n    withPosition [] = []\n    withPosition xs = zip xs (replicate (length xs - 1) False ++ [True])\n\n", "criteria": "CRITERIA_0798", "selected": "SELECTED_0798", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Docs.hs", "name": "renderDepTree", "range": {"end": {"character": 13, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0799", "variation": "negative_1", "code": "renderDepTree = T.unlines . renderLines \"\"\n  where\n    renderLines :: Text -> TemplateDependency -> [Text]\n    renderLines prefix dep =\n      (prefix <> T.pack dep.depRelativePath <> relationSuffix dep)\n      : concatMap (renderChild prefix) (withPosition $ sortedChildren dep)\n\n    renderChild :: Text -> (TemplateDependency, Bool) -> [Text]\n    renderChild prefix (child, isLast) =\n      let connector = if isLast then \"\u2514\u2500 \" else \"\u251c\u2500 \"\n          extension = if isLast then \"   \" else \"\u2502  \"\n          childPrefix = prefix <> \"   \"  -- Indent for children\n      in case child.depChildren of\n        [] -> [childPrefix <> connector <> T.pack child.depRelativePath <> relationSuffix child]\n        _  -> (childPrefix <> connector <> T.pack child.depRelativePath <> relationSuffix child)\n              : concatMap (renderChild (childPrefix <> extension)) (withPosition $ sortedChildren child)\n\n    relationSuffix :: TemplateDependency -> Text\n    relationSuffix dep = case dep.depRelation of\n      Just DepExtended -> \" (extends)\"\n      _ -> \"\"\n\n    -- Sort children by relative path for consistent output\n    sortedChildren :: TemplateDependency -> [TemplateDependency]\n    sortedChildren dep = sortOn (.depRelativePath) dep.depChildren\n\n    -- Tag each element with whether it's the last in the list\n    withPosition :: [a] -> [(a, Bool)]\n    withPosition [] = []\n    withPosition xs = zip xs (replicate (length xs - 1) False ++ [True])\n\n", "criteria": "CRITERIA_0799", "selected": "SELECTED_0799", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Docs.hs", "name": "renderDepTree", "range": {"end": {"character": 13, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0800", "variation": "negative_2", "code": "renderDepTree = T.unlines . renderLines \"\"\n  where\n    renderLines :: Text -> TemplateDependency -> [Text]\n    renderLines prefix dep =\n      (prefix <> T.pack dep.depRelativePath <> relationSuffix dep)\n      : concatMap (renderChild prefix) (withPosition $ sortedChildren dep)\n\n    renderChild :: Text -> (TemplateDependency, Bool) -> [Text]\n    renderChild prefix (child, isLast) =\n      let connector = if isLast then \"\u2514\u2500 \" else \"\u251c\u2500 \"\n          extension = if isLast then \"   \" else \"\u2502  \"\n          childPrefix = prefix <> \"   \"  -- Indent for children\n      in case child.depChildren of\n        [] -> [childPrefix <> connector <> T.pack child.depRelativePath <> relationSuffix child]\n        _  -> (childPrefix <> connector <> T.pack child.depRelativePath <> relationSuffix child)\n              : concatMap (renderChild (childPrefix <> extension)) (withPosition $ sortedChildren child)\n\n    relationSuffix :: TemplateDependency -> Text\n    relationSuffix dep = case dep.depRelation of\n      Just DepExtended -> \" (extends)\"\n      _ -> \"\"\n\n    -- Sort children by relative path for consistent output\n    sortedChildren :: TemplateDependency -> [TemplateDependency]\n    sortedChildren dep = sortOn (.depRelativePath) dep.depChildren\n\n    -- Tag each element with whether it's the last in the list\n    withPosition :: [a] -> [(a, Bool)]\n    withPosition [] = []\n    withPosition xs = zip xs (replicate (length xs - 1) False ++ [True])\n\n", "criteria": "CRITERIA_0800", "selected": "SELECTED_0800", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Docs.hs", "name": "renderDepTree", "range": {"end": {"character": 13, "line": 70}, "start": {"character": 0, "line": 70}}}
{"example_id": "0801", "variation": "positive_structure", "code": "renderDepTreeCompact dep = T.pack dep.depRelativePath <> renderChildren dep.depChildren\n  where\n    renderChildren [] = \"\"\n    renderChildren cs = \" -> \" <> T.intercalate \", \" (map (T.pack . (.depRelativePath)) cs)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE DOCUMENTATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate a documentation block for a 'TemplateDef'.\n--\n-- Includes:\n--\n-- * Template name and description\n-- * Context type (fully qualified)\n-- * Dependency tree\n-- * Accessed fields\n--\n-- Output example:\n--\n-- @\n-- ### classify\n-- Classify user intent into categories\n--\n-- **Context**: MyModule.ClassifyContext\n--\n-- **Template**:\n-- templates/classify.jinja\n--    \u2514\u2500 partials/system.jinja\n--\n-- **Fields**: topic, categories\n", "criteria": "CRITERIA_0801", "selected": "SELECTED_0801", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Docs.hs", "name": "renderDepTreeCompact", "range": {"end": {"character": 20, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0802", "variation": "positive_semantic", "code": "renderDepTreeCompact dep = T.pack dep.depRelativePath <> renderChildren dep.depChildren\n  where\n    renderChildren [] = \"\"\n    renderChildren cs = \" -> \" <> T.intercalate \", \" (map (T.pack . (.depRelativePath)) cs)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE DOCUMENTATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate a documentation block for a 'TemplateDef'.\n--\n-- Includes:\n--\n-- * Template name and description\n-- * Context type (fully qualified)\n-- * Dependency tree\n-- * Accessed fields\n--\n-- Output example:\n--\n-- @\n-- ### classify\n-- Classify user intent into categories\n--\n-- **Context**: MyModule.ClassifyContext\n--\n-- **Template**:\n-- templates/classify.jinja\n--    \u2514\u2500 partials/system.jinja\n--\n-- **Fields**: topic, categories\n", "criteria": "CRITERIA_0802", "selected": "SELECTED_0802", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Docs.hs", "name": "renderDepTreeCompact", "range": {"end": {"character": 20, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0803", "variation": "negative_1", "code": "renderDepTreeCompact dep = T.pack dep.depRelativePath <> renderChildren dep.depChildren\n  where\n    renderChildren [] = \"\"\n    renderChildren cs = \" -> \" <> T.intercalate \", \" (map (T.pack . (.depRelativePath)) cs)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE DOCUMENTATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate a documentation block for a 'TemplateDef'.\n--\n-- Includes:\n--\n-- * Template name and description\n-- * Context type (fully qualified)\n-- * Dependency tree\n-- * Accessed fields\n--\n-- Output example:\n--\n-- @\n-- ### classify\n-- Classify user intent into categories\n--\n-- **Context**: MyModule.ClassifyContext\n--\n-- **Template**:\n-- templates/classify.jinja\n--    \u2514\u2500 partials/system.jinja\n--\n-- **Fields**: topic, categories\n", "criteria": "CRITERIA_0803", "selected": "SELECTED_0803", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Docs.hs", "name": "renderDepTreeCompact", "range": {"end": {"character": 20, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0804", "variation": "negative_2", "code": "renderDepTreeCompact dep = T.pack dep.depRelativePath <> renderChildren dep.depChildren\n  where\n    renderChildren [] = \"\"\n    renderChildren cs = \" -> \" <> T.intercalate \", \" (map (T.pack . (.depRelativePath)) cs)\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE DOCUMENTATION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Generate a documentation block for a 'TemplateDef'.\n--\n-- Includes:\n--\n-- * Template name and description\n-- * Context type (fully qualified)\n-- * Dependency tree\n-- * Accessed fields\n--\n-- Output example:\n--\n-- @\n-- ### classify\n-- Classify user intent into categories\n--\n-- **Context**: MyModule.ClassifyContext\n--\n-- **Template**:\n-- templates/classify.jinja\n--    \u2514\u2500 partials/system.jinja\n--\n-- **Fields**: topic, categories\n", "criteria": "CRITERIA_0804", "selected": "SELECTED_0804", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Docs.hs", "name": "renderDepTreeCompact", "range": {"end": {"character": 20, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0805", "variation": "positive_structure", "code": "renderClaudeCodeComment Nothing = \"\"\n", "criteria": "CRITERIA_0805", "selected": "SELECTED_0805", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderClaudeCodeComment", "range": {"end": {"character": 23, "line": 223}, "start": {"character": 0, "line": 223}}}
{"example_id": "0806", "variation": "positive_semantic", "code": "renderClaudeCodeComment Nothing = \"\"\n", "criteria": "CRITERIA_0806", "selected": "SELECTED_0806", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderClaudeCodeComment", "range": {"end": {"character": 23, "line": 223}, "start": {"character": 0, "line": 223}}}
{"example_id": "0807", "variation": "negative_1", "code": "renderClaudeCodeComment Nothing = \"\"\n", "criteria": "CRITERIA_0807", "selected": "SELECTED_0807", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderClaudeCodeComment", "range": {"end": {"character": 23, "line": 223}, "start": {"character": 0, "line": 223}}}
{"example_id": "0808", "variation": "negative_2", "code": "renderClaudeCodeComment Nothing = \"\"\n", "criteria": "CRITERIA_0808", "selected": "SELECTED_0808", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderClaudeCodeComment", "range": {"end": {"character": 23, "line": 223}, "start": {"character": 0, "line": 223}}}
{"example_id": "0809", "variation": "positive_structure", "code": "renderGroup (name, members) =\n  [ \"    subgraph \" <> escapeName name\n  ] ++ map (\\m -> \"        \" <> escapeName m) members ++\n  [ \"    end\"\n  ]\n\n-- | Generate edge declarations.\n", "criteria": "CRITERIA_0809", "selected": "SELECTED_0809", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderGroup", "range": {"end": {"character": 11, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "0810", "variation": "positive_semantic", "code": "renderGroup (name, members) =\n  [ \"    subgraph \" <> escapeName name\n  ] ++ map (\\m -> \"        \" <> escapeName m) members ++\n  [ \"    end\"\n  ]\n\n-- | Generate edge declarations.\n", "criteria": "CRITERIA_0810", "selected": "SELECTED_0810", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderGroup", "range": {"end": {"character": 11, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "0811", "variation": "negative_1", "code": "renderGroup (name, members) =\n  [ \"    subgraph \" <> escapeName name\n  ] ++ map (\\m -> \"        \" <> escapeName m) members ++\n  [ \"    end\"\n  ]\n\n-- | Generate edge declarations.\n", "criteria": "CRITERIA_0811", "selected": "SELECTED_0811", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderGroup", "range": {"end": {"character": 11, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "0812", "variation": "negative_2", "code": "renderGroup (name, members) =\n  [ \"    subgraph \" <> escapeName name\n  ] ++ map (\\m -> \"        \" <> escapeName m) members ++\n  [ \"    end\"\n  ]\n\n-- | Generate edge declarations.\n", "criteria": "CRITERIA_0812", "selected": "SELECTED_0812", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderGroup", "range": {"end": {"character": 11, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "0813", "variation": "positive_structure", "code": "renderMemoryComment Nothing = \"\"\n", "criteria": "CRITERIA_0813", "selected": "SELECTED_0813", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderMemoryComment", "range": {"end": {"character": 19, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0814", "variation": "positive_semantic", "code": "renderMemoryComment Nothing = \"\"\n", "criteria": "CRITERIA_0814", "selected": "SELECTED_0814", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderMemoryComment", "range": {"end": {"character": 19, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0815", "variation": "negative_1", "code": "renderMemoryComment Nothing = \"\"\n", "criteria": "CRITERIA_0815", "selected": "SELECTED_0815", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderMemoryComment", "range": {"end": {"character": 19, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0816", "variation": "negative_2", "code": "renderMemoryComment Nothing = \"\"\n", "criteria": "CRITERIA_0816", "selected": "SELECTED_0816", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderMemoryComment", "range": {"end": {"character": 19, "line": 218}, "start": {"character": 0, "line": 218}}}
{"example_id": "0817", "variation": "positive_structure", "code": "renderNode config node =\n  \"    \" <> escapeName node.niName <> shape\n  where\n    label = if config.mcShowNodeKind\n            then node.niName <> \"<br/>\" <> kindLabel node\n            else node.niName\n    shape = case node.niKind of\n      RuntimeLLM        -> \"[[\\\"\" <> label <> \"\\\"]]\"\n      RuntimeClaudeCode -> \"[[\\\"\" <> label <> \"\\\"]]\"  -- Same shape as LLM\n      RuntimeLogic      -> \"{{\\\"\" <> label <> \"\\\"}}\"\n      RuntimeFork       -> \"{\\\"\" <> label <> \"\\\"}\"     -- Diamond for fork\n      RuntimeBarrier    -> \"[/\\\"\" <> label <> \"\\\"/]\"   -- Trapezoid for barrier\n\n    -- For ClaudeCode nodes, include the model name in the label\n    kindLabel n = case n.niKind of\n      RuntimeLLM -> \"LLM\"\n      RuntimeClaudeCode -> case n.niClaudeCode of\n        Just cci -> \"CC \" <> cci.cciModel  -- e.g., \"CC Sonnet\"\n        Nothing  -> \"ClaudeCode\"\n      RuntimeLogic -> \"Logic\"\n      RuntimeFork -> \"Fork\"\n      RuntimeBarrier -> \"Barrier\"\n\n-- | Generate group (subgraph) declarations.\n", "criteria": "CRITERIA_0817", "selected": "SELECTED_0817", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNode", "range": {"end": {"character": 10, "line": 237}, "start": {"character": 0, "line": 237}}}
{"example_id": "0818", "variation": "positive_semantic", "code": "renderNode config node =\n  \"    \" <> escapeName node.niName <> shape\n  where\n    label = if config.mcShowNodeKind\n            then node.niName <> \"<br/>\" <> kindLabel node\n            else node.niName\n    shape = case node.niKind of\n      RuntimeLLM        -> \"[[\\\"\" <> label <> \"\\\"]]\"\n      RuntimeClaudeCode -> \"[[\\\"\" <> label <> \"\\\"]]\"  -- Same shape as LLM\n      RuntimeLogic      -> \"{{\\\"\" <> label <> \"\\\"}}\"\n      RuntimeFork       -> \"{\\\"\" <> label <> \"\\\"}\"     -- Diamond for fork\n      RuntimeBarrier    -> \"[/\\\"\" <> label <> \"\\\"/]\"   -- Trapezoid for barrier\n\n    -- For ClaudeCode nodes, include the model name in the label\n    kindLabel n = case n.niKind of\n      RuntimeLLM -> \"LLM\"\n      RuntimeClaudeCode -> case n.niClaudeCode of\n        Just cci -> \"CC \" <> cci.cciModel  -- e.g., \"CC Sonnet\"\n        Nothing  -> \"ClaudeCode\"\n      RuntimeLogic -> \"Logic\"\n      RuntimeFork -> \"Fork\"\n      RuntimeBarrier -> \"Barrier\"\n\n-- | Generate group (subgraph) declarations.\n", "criteria": "CRITERIA_0818", "selected": "SELECTED_0818", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNode", "range": {"end": {"character": 10, "line": 237}, "start": {"character": 0, "line": 237}}}
{"example_id": "0819", "variation": "negative_1", "code": "renderNode config node =\n  \"    \" <> escapeName node.niName <> shape\n  where\n    label = if config.mcShowNodeKind\n            then node.niName <> \"<br/>\" <> kindLabel node\n            else node.niName\n    shape = case node.niKind of\n      RuntimeLLM        -> \"[[\\\"\" <> label <> \"\\\"]]\"\n      RuntimeClaudeCode -> \"[[\\\"\" <> label <> \"\\\"]]\"  -- Same shape as LLM\n      RuntimeLogic      -> \"{{\\\"\" <> label <> \"\\\"}}\"\n      RuntimeFork       -> \"{\\\"\" <> label <> \"\\\"}\"     -- Diamond for fork\n      RuntimeBarrier    -> \"[/\\\"\" <> label <> \"\\\"/]\"   -- Trapezoid for barrier\n\n    -- For ClaudeCode nodes, include the model name in the label\n    kindLabel n = case n.niKind of\n      RuntimeLLM -> \"LLM\"\n      RuntimeClaudeCode -> case n.niClaudeCode of\n        Just cci -> \"CC \" <> cci.cciModel  -- e.g., \"CC Sonnet\"\n        Nothing  -> \"ClaudeCode\"\n      RuntimeLogic -> \"Logic\"\n      RuntimeFork -> \"Fork\"\n      RuntimeBarrier -> \"Barrier\"\n\n-- | Generate group (subgraph) declarations.\n", "criteria": "CRITERIA_0819", "selected": "SELECTED_0819", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNode", "range": {"end": {"character": 10, "line": 237}, "start": {"character": 0, "line": 237}}}
{"example_id": "0820", "variation": "negative_2", "code": "renderNode config node =\n  \"    \" <> escapeName node.niName <> shape\n  where\n    label = if config.mcShowNodeKind\n            then node.niName <> \"<br/>\" <> kindLabel node\n            else node.niName\n    shape = case node.niKind of\n      RuntimeLLM        -> \"[[\\\"\" <> label <> \"\\\"]]\"\n      RuntimeClaudeCode -> \"[[\\\"\" <> label <> \"\\\"]]\"  -- Same shape as LLM\n      RuntimeLogic      -> \"{{\\\"\" <> label <> \"\\\"}}\"\n      RuntimeFork       -> \"{\\\"\" <> label <> \"\\\"}\"     -- Diamond for fork\n      RuntimeBarrier    -> \"[/\\\"\" <> label <> \"\\\"/]\"   -- Trapezoid for barrier\n\n    -- For ClaudeCode nodes, include the model name in the label\n    kindLabel n = case n.niKind of\n      RuntimeLLM -> \"LLM\"\n      RuntimeClaudeCode -> case n.niClaudeCode of\n        Just cci -> \"CC \" <> cci.cciModel  -- e.g., \"CC Sonnet\"\n        Nothing  -> \"ClaudeCode\"\n      RuntimeLogic -> \"Logic\"\n      RuntimeFork -> \"Fork\"\n      RuntimeBarrier -> \"Barrier\"\n\n-- | Generate group (subgraph) declarations.\n", "criteria": "CRITERIA_0820", "selected": "SELECTED_0820", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNode", "range": {"end": {"character": 10, "line": 237}, "start": {"character": 0, "line": 237}}}
{"example_id": "0821", "variation": "positive_structure", "code": "renderNodeComments node = filter (not . T.null)\n  [ \"    %% NODE: \" <> node.niName\n  , \"    %% kind: \" <> kindText node.niKind\n  , renderClaudeCodeComment node.niClaudeCode\n  , renderTemplateComment node.niTemplate\n  , renderSchemaComment node.niSchema\n  , renderToolsComment node.niToolInfos\n  , renderMemoryComment node.niMemory\n  , renderTransitionsComment node\n  ]\n  where\n    kindText RuntimeLLM = \"LLM\"\n    kindText RuntimeClaudeCode = \"ClaudeCode\"\n    kindText RuntimeLogic = \"Logic\"\n    kindText RuntimeFork = \"Fork\"\n    kindText RuntimeBarrier = \"Barrier\"\n\n-- | Render template comment.\n", "criteria": "CRITERIA_0821", "selected": "SELECTED_0821", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNodeComments", "range": {"end": {"character": 18, "line": 174}, "start": {"character": 0, "line": 174}}}
{"example_id": "0822", "variation": "positive_semantic", "code": "renderNodeComments node = filter (not . T.null)\n  [ \"    %% NODE: \" <> node.niName\n  , \"    %% kind: \" <> kindText node.niKind\n  , renderClaudeCodeComment node.niClaudeCode\n  , renderTemplateComment node.niTemplate\n  , renderSchemaComment node.niSchema\n  , renderToolsComment node.niToolInfos\n  , renderMemoryComment node.niMemory\n  , renderTransitionsComment node\n  ]\n  where\n    kindText RuntimeLLM = \"LLM\"\n    kindText RuntimeClaudeCode = \"ClaudeCode\"\n    kindText RuntimeLogic = \"Logic\"\n    kindText RuntimeFork = \"Fork\"\n    kindText RuntimeBarrier = \"Barrier\"\n\n-- | Render template comment.\n", "criteria": "CRITERIA_0822", "selected": "SELECTED_0822", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNodeComments", "range": {"end": {"character": 18, "line": 174}, "start": {"character": 0, "line": 174}}}
{"example_id": "0823", "variation": "negative_1", "code": "renderNodeComments node = filter (not . T.null)\n  [ \"    %% NODE: \" <> node.niName\n  , \"    %% kind: \" <> kindText node.niKind\n  , renderClaudeCodeComment node.niClaudeCode\n  , renderTemplateComment node.niTemplate\n  , renderSchemaComment node.niSchema\n  , renderToolsComment node.niToolInfos\n  , renderMemoryComment node.niMemory\n  , renderTransitionsComment node\n  ]\n  where\n    kindText RuntimeLLM = \"LLM\"\n    kindText RuntimeClaudeCode = \"ClaudeCode\"\n    kindText RuntimeLogic = \"Logic\"\n    kindText RuntimeFork = \"Fork\"\n    kindText RuntimeBarrier = \"Barrier\"\n\n-- | Render template comment.\n", "criteria": "CRITERIA_0823", "selected": "SELECTED_0823", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNodeComments", "range": {"end": {"character": 18, "line": 174}, "start": {"character": 0, "line": 174}}}
{"example_id": "0824", "variation": "negative_2", "code": "renderNodeComments node = filter (not . T.null)\n  [ \"    %% NODE: \" <> node.niName\n  , \"    %% kind: \" <> kindText node.niKind\n  , renderClaudeCodeComment node.niClaudeCode\n  , renderTemplateComment node.niTemplate\n  , renderSchemaComment node.niSchema\n  , renderToolsComment node.niToolInfos\n  , renderMemoryComment node.niMemory\n  , renderTransitionsComment node\n  ]\n  where\n    kindText RuntimeLLM = \"LLM\"\n    kindText RuntimeClaudeCode = \"ClaudeCode\"\n    kindText RuntimeLogic = \"Logic\"\n    kindText RuntimeFork = \"Fork\"\n    kindText RuntimeBarrier = \"Barrier\"\n\n-- | Render template comment.\n", "criteria": "CRITERIA_0824", "selected": "SELECTED_0824", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNodeComments", "range": {"end": {"character": 18, "line": 174}, "start": {"character": 0, "line": 174}}}
{"example_id": "0825", "variation": "positive_structure", "code": "renderNodeWithComments config node =\n  comments ++ [declaration]\n  where\n    comments = if config.mcIncludeComments\n               then renderNodeComments node\n               else []\n    declaration = renderNode config node\n\n-- | Render structured comments for a node (for LLM context).\n", "criteria": "CRITERIA_0825", "selected": "SELECTED_0825", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNodeWithComments", "range": {"end": {"character": 22, "line": 164}, "start": {"character": 0, "line": 164}}}
{"example_id": "0826", "variation": "positive_semantic", "code": "renderNodeWithComments config node =\n  comments ++ [declaration]\n  where\n    comments = if config.mcIncludeComments\n               then renderNodeComments node\n               else []\n    declaration = renderNode config node\n\n-- | Render structured comments for a node (for LLM context).\n", "criteria": "CRITERIA_0826", "selected": "SELECTED_0826", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNodeWithComments", "range": {"end": {"character": 22, "line": 164}, "start": {"character": 0, "line": 164}}}
{"example_id": "0827", "variation": "negative_1", "code": "renderNodeWithComments config node =\n  comments ++ [declaration]\n  where\n    comments = if config.mcIncludeComments\n               then renderNodeComments node\n               else []\n    declaration = renderNode config node\n\n-- | Render structured comments for a node (for LLM context).\n", "criteria": "CRITERIA_0827", "selected": "SELECTED_0827", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNodeWithComments", "range": {"end": {"character": 22, "line": 164}, "start": {"character": 0, "line": 164}}}
{"example_id": "0828", "variation": "negative_2", "code": "renderNodeWithComments config node =\n  comments ++ [declaration]\n  where\n    comments = if config.mcIncludeComments\n               then renderNodeComments node\n               else []\n    declaration = renderNode config node\n\n-- | Render structured comments for a node (for LLM context).\n", "criteria": "CRITERIA_0828", "selected": "SELECTED_0828", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderNodeWithComments", "range": {"end": {"character": 22, "line": 164}, "start": {"character": 0, "line": 164}}}
{"example_id": "0829", "variation": "positive_structure", "code": "renderParticipant name = \"    participant \" <> escapeName name\n\n-- | Generate sequence messages for the path.\n", "criteria": "CRITERIA_0829", "selected": "SELECTED_0829", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderParticipant", "range": {"end": {"character": 17, "line": 524}, "start": {"character": 0, "line": 524}}}
{"example_id": "0830", "variation": "positive_semantic", "code": "renderParticipant name = \"    participant \" <> escapeName name\n\n-- | Generate sequence messages for the path.\n", "criteria": "CRITERIA_0830", "selected": "SELECTED_0830", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderParticipant", "range": {"end": {"character": 17, "line": 524}, "start": {"character": 0, "line": 524}}}
{"example_id": "0831", "variation": "negative_1", "code": "renderParticipant name = \"    participant \" <> escapeName name\n\n-- | Generate sequence messages for the path.\n", "criteria": "CRITERIA_0831", "selected": "SELECTED_0831", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderParticipant", "range": {"end": {"character": 17, "line": 524}, "start": {"character": 0, "line": 524}}}
{"example_id": "0832", "variation": "negative_2", "code": "renderParticipant name = \"    participant \" <> escapeName name\n\n-- | Generate sequence messages for the path.\n", "criteria": "CRITERIA_0832", "selected": "SELECTED_0832", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderParticipant", "range": {"end": {"character": 17, "line": 524}, "start": {"character": 0, "line": 524}}}
{"example_id": "0833", "variation": "positive_structure", "code": "renderSchemaComment Nothing = \"\"\n", "criteria": "CRITERIA_0833", "selected": "SELECTED_0833", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderSchemaComment", "range": {"end": {"character": 19, "line": 203}, "start": {"character": 0, "line": 203}}}
{"example_id": "0834", "variation": "positive_semantic", "code": "renderSchemaComment Nothing = \"\"\n", "criteria": "CRITERIA_0834", "selected": "SELECTED_0834", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderSchemaComment", "range": {"end": {"character": 19, "line": 203}, "start": {"character": 0, "line": 203}}}
{"example_id": "0835", "variation": "negative_1", "code": "renderSchemaComment Nothing = \"\"\n", "criteria": "CRITERIA_0835", "selected": "SELECTED_0835", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderSchemaComment", "range": {"end": {"character": 19, "line": 203}, "start": {"character": 0, "line": 203}}}
{"example_id": "0836", "variation": "negative_2", "code": "renderSchemaComment Nothing = \"\"\n", "criteria": "CRITERIA_0836", "selected": "SELECTED_0836", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderSchemaComment", "range": {"end": {"character": 19, "line": 203}, "start": {"character": 0, "line": 203}}}
{"example_id": "0837", "variation": "positive_structure", "code": "renderState config node =\n  if config.mcShowNodeKind\n  then \"    \" <> escapeName node.niName <> \" : \" <> kindAnnotation node\n  else \"\"\n  where\n    kindAnnotation n = case n.niKind of\n      RuntimeLLM -> \"LLM\"\n      RuntimeClaudeCode -> case n.niClaudeCode of\n        Just cci -> \"CC \" <> cci.cciModel\n        Nothing  -> \"ClaudeCode\"\n      RuntimeLogic -> \"Logic\"\n      RuntimeFork -> \"Fork\"\n      RuntimeBarrier -> \"Barrier\"\n\n-- | Generate state transitions.\n", "criteria": "CRITERIA_0837", "selected": "SELECTED_0837", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderState", "range": {"end": {"character": 11, "line": 407}, "start": {"character": 0, "line": 407}}}
{"example_id": "0838", "variation": "positive_semantic", "code": "renderState config node =\n  if config.mcShowNodeKind\n  then \"    \" <> escapeName node.niName <> \" : \" <> kindAnnotation node\n  else \"\"\n  where\n    kindAnnotation n = case n.niKind of\n      RuntimeLLM -> \"LLM\"\n      RuntimeClaudeCode -> case n.niClaudeCode of\n        Just cci -> \"CC \" <> cci.cciModel\n        Nothing  -> \"ClaudeCode\"\n      RuntimeLogic -> \"Logic\"\n      RuntimeFork -> \"Fork\"\n      RuntimeBarrier -> \"Barrier\"\n\n-- | Generate state transitions.\n", "criteria": "CRITERIA_0838", "selected": "SELECTED_0838", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderState", "range": {"end": {"character": 11, "line": 407}, "start": {"character": 0, "line": 407}}}
{"example_id": "0839", "variation": "negative_1", "code": "renderState config node =\n  if config.mcShowNodeKind\n  then \"    \" <> escapeName node.niName <> \" : \" <> kindAnnotation node\n  else \"\"\n  where\n    kindAnnotation n = case n.niKind of\n      RuntimeLLM -> \"LLM\"\n      RuntimeClaudeCode -> case n.niClaudeCode of\n        Just cci -> \"CC \" <> cci.cciModel\n        Nothing  -> \"ClaudeCode\"\n      RuntimeLogic -> \"Logic\"\n      RuntimeFork -> \"Fork\"\n      RuntimeBarrier -> \"Barrier\"\n\n-- | Generate state transitions.\n", "criteria": "CRITERIA_0839", "selected": "SELECTED_0839", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderState", "range": {"end": {"character": 11, "line": 407}, "start": {"character": 0, "line": 407}}}
{"example_id": "0840", "variation": "negative_2", "code": "renderState config node =\n  if config.mcShowNodeKind\n  then \"    \" <> escapeName node.niName <> \" : \" <> kindAnnotation node\n  else \"\"\n  where\n    kindAnnotation n = case n.niKind of\n      RuntimeLLM -> \"LLM\"\n      RuntimeClaudeCode -> case n.niClaudeCode of\n        Just cci -> \"CC \" <> cci.cciModel\n        Nothing  -> \"ClaudeCode\"\n      RuntimeLogic -> \"Logic\"\n      RuntimeFork -> \"Fork\"\n      RuntimeBarrier -> \"Barrier\"\n\n-- | Generate state transitions.\n", "criteria": "CRITERIA_0840", "selected": "SELECTED_0840", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderState", "range": {"end": {"character": 11, "line": 407}, "start": {"character": 0, "line": 407}}}
{"example_id": "0841", "variation": "positive_structure", "code": "renderTemplateComment Nothing = \"\"\n", "criteria": "CRITERIA_0841", "selected": "SELECTED_0841", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderTemplateComment", "range": {"end": {"character": 21, "line": 193}, "start": {"character": 0, "line": 193}}}
{"example_id": "0842", "variation": "positive_semantic", "code": "renderTemplateComment Nothing = \"\"\n", "criteria": "CRITERIA_0842", "selected": "SELECTED_0842", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderTemplateComment", "range": {"end": {"character": 21, "line": 193}, "start": {"character": 0, "line": 193}}}
{"example_id": "0843", "variation": "negative_1", "code": "renderTemplateComment Nothing = \"\"\n", "criteria": "CRITERIA_0843", "selected": "SELECTED_0843", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderTemplateComment", "range": {"end": {"character": 21, "line": 193}, "start": {"character": 0, "line": 193}}}
{"example_id": "0844", "variation": "negative_2", "code": "renderTemplateComment Nothing = \"\"\n", "criteria": "CRITERIA_0844", "selected": "SELECTED_0844", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderTemplateComment", "range": {"end": {"character": 21, "line": 193}, "start": {"character": 0, "line": 193}}}
{"example_id": "0845", "variation": "positive_structure", "code": "renderToolsComment [] = \"    %% tools: none\"\n", "criteria": "CRITERIA_0845", "selected": "SELECTED_0845", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderToolsComment", "range": {"end": {"character": 18, "line": 213}, "start": {"character": 0, "line": 213}}}
{"example_id": "0846", "variation": "positive_semantic", "code": "renderToolsComment [] = \"    %% tools: none\"\n", "criteria": "CRITERIA_0846", "selected": "SELECTED_0846", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderToolsComment", "range": {"end": {"character": 18, "line": 213}, "start": {"character": 0, "line": 213}}}
{"example_id": "0847", "variation": "negative_1", "code": "renderToolsComment [] = \"    %% tools: none\"\n", "criteria": "CRITERIA_0847", "selected": "SELECTED_0847", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderToolsComment", "range": {"end": {"character": 18, "line": 213}, "start": {"character": 0, "line": 213}}}
{"example_id": "0848", "variation": "negative_2", "code": "renderToolsComment [] = \"    %% tools: none\"\n", "criteria": "CRITERIA_0848", "selected": "SELECTED_0848", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderToolsComment", "range": {"end": {"character": 18, "line": 213}, "start": {"character": 0, "line": 213}}}
{"example_id": "0849", "variation": "positive_structure", "code": "renderTransitionsComment node\n  | null node.niGotoTargets && not node.niHasGotoExit = \"\"\n  | otherwise = \"    %% transitions: \" <> T.intercalate \", \" targets\n  where\n    targets = map fst node.niGotoTargets\n           ++ [\"Exit\" | node.niHasGotoExit]\n\n-- | Render a single node declaration.\n", "criteria": "CRITERIA_0849", "selected": "SELECTED_0849", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderTransitionsComment", "range": {"end": {"character": 24, "line": 228}, "start": {"character": 0, "line": 228}}}
{"example_id": "0850", "variation": "positive_semantic", "code": "renderTransitionsComment node\n  | null node.niGotoTargets && not node.niHasGotoExit = \"\"\n  | otherwise = \"    %% transitions: \" <> T.intercalate \", \" targets\n  where\n    targets = map fst node.niGotoTargets\n           ++ [\"Exit\" | node.niHasGotoExit]\n\n-- | Render a single node declaration.\n", "criteria": "CRITERIA_0850", "selected": "SELECTED_0850", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderTransitionsComment", "range": {"end": {"character": 24, "line": 228}, "start": {"character": 0, "line": 228}}}
{"example_id": "0851", "variation": "negative_1", "code": "renderTransitionsComment node\n  | null node.niGotoTargets && not node.niHasGotoExit = \"\"\n  | otherwise = \"    %% transitions: \" <> T.intercalate \", \" targets\n  where\n    targets = map fst node.niGotoTargets\n           ++ [\"Exit\" | node.niHasGotoExit]\n\n-- | Render a single node declaration.\n", "criteria": "CRITERIA_0851", "selected": "SELECTED_0851", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderTransitionsComment", "range": {"end": {"character": 24, "line": 228}, "start": {"character": 0, "line": 228}}}
{"example_id": "0852", "variation": "negative_2", "code": "renderTransitionsComment node\n  | null node.niGotoTargets && not node.niHasGotoExit = \"\"\n  | otherwise = \"    %% transitions: \" <> T.intercalate \", \" targets\n  where\n    targets = map fst node.niGotoTargets\n           ++ [\"Exit\" | node.niHasGotoExit]\n\n-- | Render a single node declaration.\n", "criteria": "CRITERIA_0852", "selected": "SELECTED_0852", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Mermaid.hs", "name": "renderTransitionsComment", "range": {"end": {"character": 24, "line": 228}, "start": {"character": 0, "line": 228}}}
{"example_id": "0853", "variation": "positive_structure", "code": "renderScoringPrompt ctx = T.unlines\n  [ \"Rate this \" <> scEdgeType ctx <> \" for the query:\"\n  , \"<escape>\" <> scQuery ctx <> \"<escape>\"\n  , \"\"\n  , \"Location: \" <> scLocation ctx\n  , \"Depth: \" <> T.pack (show $ scDepth ctx)\n  , \"\"\n  , \"Code:\"\n  , \"<escape>\"\n  , scSnippet ctx\n  , \"<escape>\"\n  , \"\"\n  , \"Hover info:\"\n  , \"<escape>\" <> scHover ctx <> \"<escape>\"\n  , \"\"\n  , renderTypeInfo ctx\n  , renderPatterns ctx\n  , renderConstraints ctx\n  , \"Assess relevance (1-5), risk (1-5), and applicable tags.\"\n  ]\n\n-- | Render type info section if present.\n", "criteria": "CRITERIA_0853", "selected": "SELECTED_0853", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderScoringPrompt", "range": {"end": {"character": 19, "line": 76}, "start": {"character": 0, "line": 76}}}
{"example_id": "0854", "variation": "positive_semantic", "code": "renderScoringPrompt ctx = T.unlines\n  [ \"Rate this \" <> scEdgeType ctx <> \" for the query:\"\n  , \"<escape>\" <> scQuery ctx <> \"<escape>\"\n  , \"\"\n  , \"Location: \" <> scLocation ctx\n  , \"Depth: \" <> T.pack (show $ scDepth ctx)\n  , \"\"\n  , \"Code:\"\n  , \"<escape>\"\n  , scSnippet ctx\n  , \"<escape>\"\n  , \"\"\n  , \"Hover info:\"\n  , \"<escape>\" <> scHover ctx <> \"<escape>\"\n  , \"\"\n  , renderTypeInfo ctx\n  , renderPatterns ctx\n  , renderConstraints ctx\n  , \"Assess relevance (1-5), risk (1-5), and applicable tags.\"\n  ]\n\n-- | Render type info section if present.\n", "criteria": "CRITERIA_0854", "selected": "SELECTED_0854", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderScoringPrompt", "range": {"end": {"character": 19, "line": 76}, "start": {"character": 0, "line": 76}}}
{"example_id": "0855", "variation": "negative_1", "code": "renderScoringPrompt ctx = T.unlines\n  [ \"Rate this \" <> scEdgeType ctx <> \" for the query:\"\n  , \"<escape>\" <> scQuery ctx <> \"<escape>\"\n  , \"\"\n  , \"Location: \" <> scLocation ctx\n  , \"Depth: \" <> T.pack (show $ scDepth ctx)\n  , \"\"\n  , \"Code:\"\n  , \"<escape>\"\n  , scSnippet ctx\n  , \"<escape>\"\n  , \"\"\n  , \"Hover info:\"\n  , \"<escape>\" <> scHover ctx <> \"<escape>\"\n  , \"\"\n  , renderTypeInfo ctx\n  , renderPatterns ctx\n  , renderConstraints ctx\n  , \"Assess relevance (1-5), risk (1-5), and applicable tags.\"\n  ]\n\n-- | Render type info section if present.\n", "criteria": "CRITERIA_0855", "selected": "SELECTED_0855", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderScoringPrompt", "range": {"end": {"character": 19, "line": 76}, "start": {"character": 0, "line": 76}}}
{"example_id": "0856", "variation": "negative_2", "code": "renderScoringPrompt ctx = T.unlines\n  [ \"Rate this \" <> scEdgeType ctx <> \" for the query:\"\n  , \"<escape>\" <> scQuery ctx <> \"<escape>\"\n  , \"\"\n  , \"Location: \" <> scLocation ctx\n  , \"Depth: \" <> T.pack (show $ scDepth ctx)\n  , \"\"\n  , \"Code:\"\n  , \"<escape>\"\n  , scSnippet ctx\n  , \"<escape>\"\n  , \"\"\n  , \"Hover info:\"\n  , \"<escape>\" <> scHover ctx <> \"<escape>\"\n  , \"\"\n  , renderTypeInfo ctx\n  , renderPatterns ctx\n  , renderConstraints ctx\n  , \"Assess relevance (1-5), risk (1-5), and applicable tags.\"\n  ]\n\n-- | Render type info section if present.\n", "criteria": "CRITERIA_0856", "selected": "SELECTED_0856", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderScoringPrompt", "range": {"end": {"character": 19, "line": 76}, "start": {"character": 0, "line": 76}}}
{"example_id": "0857", "variation": "positive_structure", "code": "renderTypeInfo ctx = case scTypeInfo ctx of\n  Nothing -> \"\"\n  Just t  -> \"Type context: \" <> t <> \"\\n\"\n\n-- | Render patterns section if present.\n", "criteria": "CRITERIA_0857", "selected": "SELECTED_0857", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderTypeInfo", "range": {"end": {"character": 14, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0858", "variation": "positive_semantic", "code": "renderTypeInfo ctx = case scTypeInfo ctx of\n  Nothing -> \"\"\n  Just t  -> \"Type context: \" <> t <> \"\\n\"\n\n-- | Render patterns section if present.\n", "criteria": "CRITERIA_0858", "selected": "SELECTED_0858", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderTypeInfo", "range": {"end": {"character": 14, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0859", "variation": "negative_1", "code": "renderTypeInfo ctx = case scTypeInfo ctx of\n  Nothing -> \"\"\n  Just t  -> \"Type context: \" <> t <> \"\\n\"\n\n-- | Render patterns section if present.\n", "criteria": "CRITERIA_0859", "selected": "SELECTED_0859", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderTypeInfo", "range": {"end": {"character": 14, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0860", "variation": "negative_2", "code": "renderTypeInfo ctx = case scTypeInfo ctx of\n  Nothing -> \"\"\n  Just t  -> \"Type context: \" <> t <> \"\\n\"\n\n-- | Render patterns section if present.\n", "criteria": "CRITERIA_0860", "selected": "SELECTED_0860", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderTypeInfo", "range": {"end": {"character": 14, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0861", "variation": "positive_structure", "code": "renderPatterns ctx = case scPatterns ctx of\n  Nothing -> \"\"\n  Just ps -> \"Pattern cases:\\n\" <> T.unlines (map (\"  - \" <>) ps) <> \"\\n\"\n\n-- | Render constraints section if present.\n", "criteria": "CRITERIA_0861", "selected": "SELECTED_0861", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderPatterns", "range": {"end": {"character": 14, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0862", "variation": "positive_semantic", "code": "renderPatterns ctx = case scPatterns ctx of\n  Nothing -> \"\"\n  Just ps -> \"Pattern cases:\\n\" <> T.unlines (map (\"  - \" <>) ps) <> \"\\n\"\n\n-- | Render constraints section if present.\n", "criteria": "CRITERIA_0862", "selected": "SELECTED_0862", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderPatterns", "range": {"end": {"character": 14, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0863", "variation": "negative_1", "code": "renderPatterns ctx = case scPatterns ctx of\n  Nothing -> \"\"\n  Just ps -> \"Pattern cases:\\n\" <> T.unlines (map (\"  - \" <>) ps) <> \"\\n\"\n\n-- | Render constraints section if present.\n", "criteria": "CRITERIA_0863", "selected": "SELECTED_0863", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderPatterns", "range": {"end": {"character": 14, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0864", "variation": "negative_2", "code": "renderPatterns ctx = case scPatterns ctx of\n  Nothing -> \"\"\n  Just ps -> \"Pattern cases:\\n\" <> T.unlines (map (\"  - \" <>) ps) <> \"\\n\"\n\n-- | Render constraints section if present.\n", "criteria": "CRITERIA_0864", "selected": "SELECTED_0864", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderPatterns", "range": {"end": {"character": 14, "line": 105}, "start": {"character": 0, "line": 105}}}
{"example_id": "0865", "variation": "positive_structure", "code": "renderConstraints ctx = case scConstraints ctx of\n  Nothing -> \"\"\n  Just cs -> \"Instance constraints: \" <> T.intercalate \", \" cs <> \"\\n\"\n", "criteria": "CRITERIA_0865", "selected": "SELECTED_0865", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderConstraints", "range": {"end": {"character": 17, "line": 111}, "start": {"character": 0, "line": 111}}}
{"example_id": "0866", "variation": "positive_semantic", "code": "renderConstraints ctx = case scConstraints ctx of\n  Nothing -> \"\"\n  Just cs -> \"Instance constraints: \" <> T.intercalate \", \" cs <> \"\\n\"\n", "criteria": "CRITERIA_0866", "selected": "SELECTED_0866", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderConstraints", "range": {"end": {"character": 17, "line": 111}, "start": {"character": 0, "line": 111}}}
{"example_id": "0867", "variation": "negative_1", "code": "renderConstraints ctx = case scConstraints ctx of\n  Nothing -> \"\"\n  Just cs -> \"Instance constraints: \" <> T.intercalate \", \" cs <> \"\\n\"\n", "criteria": "CRITERIA_0867", "selected": "SELECTED_0867", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderConstraints", "range": {"end": {"character": 17, "line": 111}, "start": {"character": 0, "line": 111}}}
{"example_id": "0868", "variation": "negative_2", "code": "renderConstraints ctx = case scConstraints ctx of\n  Nothing -> \"\"\n  Just cs -> \"Instance constraints: \" <> T.intercalate \", \" cs <> \"\\n\"\n", "criteria": "CRITERIA_0868", "selected": "SELECTED_0868", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Templates.hs", "name": "renderConstraints", "range": {"end": {"character": 17, "line": 111}, "start": {"character": 0, "line": 111}}}
{"example_id": "0869", "variation": "positive_structure", "code": "  in encode $ object [\"text\" .= text]\n\n\n-- | Format candidate groups (Fields, Inputs, Output, References).\n", "criteria": "CRITERIA_0869", "selected": "SELECTED_0869", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatCandidateGroups", "range": {"end": {"character": 21, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0870", "variation": "positive_semantic", "code": "  in encode $ object [\"text\" .= text]\n\n\n-- | Format candidate groups (Fields, Inputs, Output, References).\n", "criteria": "CRITERIA_0870", "selected": "SELECTED_0870", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatCandidateGroups", "range": {"end": {"character": 21, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0871", "variation": "negative_1", "code": "  in encode $ object [\"text\" .= text]\n\n\n-- | Format candidate groups (Fields, Inputs, Output, References).\n", "criteria": "CRITERIA_0871", "selected": "SELECTED_0871", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatCandidateGroups", "range": {"end": {"character": 21, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0872", "variation": "negative_2", "code": "  in encode $ object [\"text\" .= text]\n\n\n-- | Format candidate groups (Fields, Inputs, Output, References).\n", "criteria": "CRITERIA_0872", "selected": "SELECTED_0872", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatCandidateGroups", "range": {"end": {"character": 21, "line": 101}, "start": {"character": 0, "line": 101}}}
{"example_id": "0873", "variation": "positive_structure", "code": "holeMarker :: Text -> Text\n", "criteria": "CRITERIA_0873", "selected": "SELECTED_0873", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatDeveloperTurn", "range": {"end": {"character": 19, "line": 26}, "start": {"character": 0, "line": 26}}}
{"example_id": "0874", "variation": "positive_semantic", "code": "holeMarker :: Text -> Text\n", "criteria": "CRITERIA_0874", "selected": "SELECTED_0874", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatDeveloperTurn", "range": {"end": {"character": 19, "line": 26}, "start": {"character": 0, "line": 26}}}
{"example_id": "0875", "variation": "negative_1", "code": "holeMarker :: Text -> Text\n", "criteria": "CRITERIA_0875", "selected": "SELECTED_0875", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatDeveloperTurn", "range": {"end": {"character": 19, "line": 26}, "start": {"character": 0, "line": 26}}}
{"example_id": "0876", "variation": "negative_2", "code": "holeMarker :: Text -> Text\n", "criteria": "CRITERIA_0876", "selected": "SELECTED_0876", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatDeveloperTurn", "range": {"end": {"character": 19, "line": 26}, "start": {"character": 0, "line": 26}}}
{"example_id": "0877", "variation": "positive_structure", "code": "  , \"<end_of_turn>\"\n  ]\n\n-- | Format model turn with hole for selected symbols.\n", "criteria": "CRITERIA_0877", "selected": "SELECTED_0877", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatModelTurnWithHole", "range": {"end": {"character": 23, "line": 71}, "start": {"character": 0, "line": 71}}}
{"example_id": "0878", "variation": "positive_semantic", "code": "  , \"<end_of_turn>\"\n  ]\n\n-- | Format model turn with hole for selected symbols.\n", "criteria": "CRITERIA_0878", "selected": "SELECTED_0878", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatModelTurnWithHole", "range": {"end": {"character": 23, "line": 71}, "start": {"character": 0, "line": 71}}}
{"example_id": "0879", "variation": "negative_1", "code": "  , \"<end_of_turn>\"\n  ]\n\n-- | Format model turn with hole for selected symbols.\n", "criteria": "CRITERIA_0879", "selected": "SELECTED_0879", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatModelTurnWithHole", "range": {"end": {"character": 23, "line": 71}, "start": {"character": 0, "line": 71}}}
{"example_id": "0880", "variation": "negative_2", "code": "  , \"<end_of_turn>\"\n  ]\n\n-- | Format model turn with hole for selected symbols.\n", "criteria": "CRITERIA_0880", "selected": "SELECTED_0880", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatModelTurnWithHole", "range": {"end": {"character": 23, "line": 71}, "start": {"character": 0, "line": 71}}}
{"example_id": "0881", "variation": "positive_structure", "code": "  -> Text         -- Package name\n  -> Text         -- Signature (cleaned)\n  -> Maybe Text   -- Documentation (first sentence)\n  -> [Text]       -- Candidates\n  -> ByteString\n", "criteria": "CRITERIA_0881", "selected": "SELECTED_0881", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatSelectSymbolsExample", "range": {"end": {"character": 26, "line": 90}, "start": {"character": 0, "line": 90}}}
{"example_id": "0882", "variation": "positive_semantic", "code": "  -> Text         -- Package name\n  -> Text         -- Signature (cleaned)\n  -> Maybe Text   -- Documentation (first sentence)\n  -> [Text]       -- Candidates\n  -> ByteString\n", "criteria": "CRITERIA_0882", "selected": "SELECTED_0882", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatSelectSymbolsExample", "range": {"end": {"character": 26, "line": 90}, "start": {"character": 0, "line": 90}}}
{"example_id": "0883", "variation": "negative_1", "code": "  -> Text         -- Package name\n  -> Text         -- Signature (cleaned)\n  -> Maybe Text   -- Documentation (first sentence)\n  -> [Text]       -- Candidates\n  -> ByteString\n", "criteria": "CRITERIA_0883", "selected": "SELECTED_0883", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatSelectSymbolsExample", "range": {"end": {"character": 26, "line": 90}, "start": {"character": 0, "line": 90}}}
{"example_id": "0884", "variation": "negative_2", "code": "  -> Text         -- Package name\n  -> Text         -- Signature (cleaned)\n  -> Maybe Text   -- Documentation (first sentence)\n  -> [Text]       -- Candidates\n  -> ByteString\n", "criteria": "CRITERIA_0884", "selected": "SELECTED_0884", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatSelectSymbolsExample", "range": {"end": {"character": 26, "line": 90}, "start": {"character": 0, "line": 90}}}
{"example_id": "0885", "variation": "positive_structure", "code": "  -> Text            -- Module name\n  -> Text            -- Package name\n  -> Text            -- Signature (cleaned)\n  -> CandidateGroups -- Grouped candidates\n  -> ByteString\n", "criteria": "CRITERIA_0885", "selected": "SELECTED_0885", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatSelectSymbolsExampleGrouped", "range": {"end": {"character": 33, "line": 144}, "start": {"character": 0, "line": 144}}}
{"example_id": "0886", "variation": "positive_semantic", "code": "  -> Text            -- Module name\n  -> Text            -- Package name\n  -> Text            -- Signature (cleaned)\n  -> CandidateGroups -- Grouped candidates\n  -> ByteString\n", "criteria": "CRITERIA_0886", "selected": "SELECTED_0886", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatSelectSymbolsExampleGrouped", "range": {"end": {"character": 33, "line": 144}, "start": {"character": 0, "line": 144}}}
{"example_id": "0887", "variation": "negative_1", "code": "  -> Text            -- Module name\n  -> Text            -- Package name\n  -> Text            -- Signature (cleaned)\n  -> CandidateGroups -- Grouped candidates\n  -> ByteString\n", "criteria": "CRITERIA_0887", "selected": "SELECTED_0887", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatSelectSymbolsExampleGrouped", "range": {"end": {"character": 33, "line": 144}, "start": {"character": 0, "line": 144}}}
{"example_id": "0888", "variation": "negative_2", "code": "  -> Text            -- Module name\n  -> Text            -- Package name\n  -> Text            -- Signature (cleaned)\n  -> CandidateGroups -- Grouped candidates\n  -> ByteString\n", "criteria": "CRITERIA_0888", "selected": "SELECTED_0888", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatSelectSymbolsExampleGrouped", "range": {"end": {"character": 33, "line": 144}, "start": {"character": 0, "line": 144}}}
{"example_id": "0889", "variation": "positive_structure", "code": "  -> Text         -- Package name (e.g., \"tidepool-core\")\n  -> Text         -- Signature (cleaned)\n  -> Maybe Text   -- Documentation (first sentence only)\n  -> [Text]       -- Candidates\n  -> Text\n", "criteria": "CRITERIA_0889", "selected": "SELECTED_0889", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatUserTurn", "range": {"end": {"character": 14, "line": 55}, "start": {"character": 0, "line": 55}}}
{"example_id": "0890", "variation": "positive_semantic", "code": "  -> Text         -- Package name (e.g., \"tidepool-core\")\n  -> Text         -- Signature (cleaned)\n  -> Maybe Text   -- Documentation (first sentence only)\n  -> [Text]       -- Candidates\n  -> Text\n", "criteria": "CRITERIA_0890", "selected": "SELECTED_0890", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatUserTurn", "range": {"end": {"character": 14, "line": 55}, "start": {"character": 0, "line": 55}}}
{"example_id": "0891", "variation": "negative_1", "code": "  -> Text         -- Package name (e.g., \"tidepool-core\")\n  -> Text         -- Signature (cleaned)\n  -> Maybe Text   -- Documentation (first sentence only)\n  -> [Text]       -- Candidates\n  -> Text\n", "criteria": "CRITERIA_0891", "selected": "SELECTED_0891", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatUserTurn", "range": {"end": {"character": 14, "line": 55}, "start": {"character": 0, "line": 55}}}
{"example_id": "0892", "variation": "negative_2", "code": "  -> Text         -- Package name (e.g., \"tidepool-core\")\n  -> Text         -- Signature (cleaned)\n  -> Maybe Text   -- Documentation (first sentence only)\n  -> [Text]       -- Candidates\n  -> Text\n", "criteria": "CRITERIA_0892", "selected": "SELECTED_0892", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatUserTurn", "range": {"end": {"character": 14, "line": 55}, "start": {"character": 0, "line": 55}}}
{"example_id": "0893", "variation": "positive_structure", "code": "  -> Text            -- Module name\n  -> Text            -- Package name\n  -> Text            -- Signature (cleaned)\n  -> CandidateGroups -- Grouped candidates\n  -> Text\n", "criteria": "CRITERIA_0893", "selected": "SELECTED_0893", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatUserTurnGrouped", "range": {"end": {"character": 21, "line": 123}, "start": {"character": 0, "line": 123}}}
{"example_id": "0894", "variation": "positive_semantic", "code": "  -> Text            -- Module name\n  -> Text            -- Package name\n  -> Text            -- Signature (cleaned)\n  -> CandidateGroups -- Grouped candidates\n  -> Text\n", "criteria": "CRITERIA_0894", "selected": "SELECTED_0894", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatUserTurnGrouped", "range": {"end": {"character": 21, "line": 123}, "start": {"character": 0, "line": 123}}}
{"example_id": "0895", "variation": "negative_1", "code": "  -> Text            -- Module name\n  -> Text            -- Package name\n  -> Text            -- Signature (cleaned)\n  -> CandidateGroups -- Grouped candidates\n  -> Text\n", "criteria": "CRITERIA_0895", "selected": "SELECTED_0895", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatUserTurnGrouped", "range": {"end": {"character": 21, "line": 123}, "start": {"character": 0, "line": 123}}}
{"example_id": "0896", "variation": "negative_2", "code": "  -> Text            -- Module name\n  -> Text            -- Package name\n  -> Text            -- Signature (cleaned)\n  -> CandidateGroups -- Grouped candidates\n  -> Text\n", "criteria": "CRITERIA_0896", "selected": "SELECTED_0896", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/tools/training-generator/src/Tidepool/Training/Format.hs", "name": "formatUserTurnGrouped", "range": {"end": {"character": 21, "line": 123}, "start": {"character": 0, "line": 123}}}
{"example_id": "0897", "variation": "positive_structure", "code": "formatDiagnostic pd = T.unlines\n  [ \"Parse error at: \" <> formatPath pd.pdPath\n  , \"Expected: \" <> pd.pdExpected\n  , \"Got: \" <> pd.pdActual\n  , pd.pdMessage\n  ]\n  where\n    formatPath [] = \"(root)\"\n    formatPath ps = T.intercalate \".\" ps\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WRAPPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Wrapper for enum types that should serialize as plain string enums in JSON Schema.\n", "criteria": "CRITERIA_0897", "selected": "SELECTED_0897", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Class.hs", "name": "formatDiagnostic", "range": {"end": {"character": 16, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0898", "variation": "positive_semantic", "code": "formatDiagnostic pd = T.unlines\n  [ \"Parse error at: \" <> formatPath pd.pdPath\n  , \"Expected: \" <> pd.pdExpected\n  , \"Got: \" <> pd.pdActual\n  , pd.pdMessage\n  ]\n  where\n    formatPath [] = \"(root)\"\n    formatPath ps = T.intercalate \".\" ps\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WRAPPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Wrapper for enum types that should serialize as plain string enums in JSON Schema.\n", "criteria": "CRITERIA_0898", "selected": "SELECTED_0898", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Class.hs", "name": "formatDiagnostic", "range": {"end": {"character": 16, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0899", "variation": "negative_1", "code": "formatDiagnostic pd = T.unlines\n  [ \"Parse error at: \" <> formatPath pd.pdPath\n  , \"Expected: \" <> pd.pdExpected\n  , \"Got: \" <> pd.pdActual\n  , pd.pdMessage\n  ]\n  where\n    formatPath [] = \"(root)\"\n    formatPath ps = T.intercalate \".\" ps\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WRAPPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Wrapper for enum types that should serialize as plain string enums in JSON Schema.\n", "criteria": "CRITERIA_0899", "selected": "SELECTED_0899", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Class.hs", "name": "formatDiagnostic", "range": {"end": {"character": 16, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0900", "variation": "negative_2", "code": "formatDiagnostic pd = T.unlines\n  [ \"Parse error at: \" <> formatPath pd.pdPath\n  , \"Expected: \" <> pd.pdExpected\n  , \"Got: \" <> pd.pdActual\n  , pd.pdMessage\n  ]\n  where\n    formatPath [] = \"(root)\"\n    formatPath ps = T.intercalate \".\" ps\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- WRAPPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Wrapper for enum types that should serialize as plain string enums in JSON Schema.\n", "criteria": "CRITERIA_0900", "selected": "SELECTED_0900", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/StructuredOutput/Class.hs", "name": "formatDiagnostic", "range": {"end": {"character": 16, "line": 99}, "start": {"character": 0, "line": 99}}}
{"example_id": "0901", "variation": "positive_structure", "code": "formatOutput FormatJSON = TL.toStrict . Aeson.encodeToLazyText\n", "criteria": "CRITERIA_0901", "selected": "SELECTED_0901", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "formatOutput", "range": {"end": {"character": 12, "line": 451}, "start": {"character": 0, "line": 451}}}
{"example_id": "0902", "variation": "positive_semantic", "code": "formatOutput FormatJSON = TL.toStrict . Aeson.encodeToLazyText\n", "criteria": "CRITERIA_0902", "selected": "SELECTED_0902", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "formatOutput", "range": {"end": {"character": 12, "line": 451}, "start": {"character": 0, "line": 451}}}
{"example_id": "0903", "variation": "negative_1", "code": "formatOutput FormatJSON = TL.toStrict . Aeson.encodeToLazyText\n", "criteria": "CRITERIA_0903", "selected": "SELECTED_0903", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "formatOutput", "range": {"end": {"character": 12, "line": 451}, "start": {"character": 0, "line": 451}}}
{"example_id": "0904", "variation": "negative_2", "code": "formatOutput FormatJSON = TL.toStrict . Aeson.encodeToLazyText\n", "criteria": "CRITERIA_0904", "selected": "SELECTED_0904", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/CLI.hs", "name": "formatOutput", "range": {"end": {"character": 12, "line": 451}, "start": {"character": 0, "line": 451}}}
{"example_id": "0905", "variation": "positive_structure", "code": "formatMessagesForCompression = T.intercalate \"\\n\\n\" . map formatMessage\n  where\n    formatMessage msg =\n      let roleLabel = case msg.role of\n            User -> \"USER\"\n            Assistant -> \"ASSISTANT\"\n          contentText = T.intercalate \" \" (map formatBlock msg.content)\n      in roleLabel <> \": \" <> contentText\n\n    formatBlock :: ContentBlock -> Text\n    formatBlock (TextBlock t) = t\n    formatBlock (ImageBlock _) = \"[IMAGE]\"\n    formatBlock (ToolUseBlock tu) = \"[TOOL:\" <> tu.toolName <> \"]\"\n    formatBlock (ToolResultBlock tr) = \"[TOOL_RESULT:\" <> tr.toolResultContent <> \"]\"\n    formatBlock (ThinkingBlock tc) = \"[THINKING:\" <> tc.thinkingText <> \"]\"\n    formatBlock (RedactedThinkingBlock _) = \"[REDACTED_THINKING]\"\n    formatBlock (JsonBlock _) = \"[JSON]\"\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LOG AND GAME RUNNERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run the full game effect stack\n", "criteria": "CRITERIA_0905", "selected": "SELECTED_0905", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "formatMessagesForCompression", "range": {"end": {"character": 28, "line": 665}, "start": {"character": 0, "line": 665}}}
{"example_id": "0906", "variation": "positive_semantic", "code": "formatMessagesForCompression = T.intercalate \"\\n\\n\" . map formatMessage\n  where\n    formatMessage msg =\n      let roleLabel = case msg.role of\n            User -> \"USER\"\n            Assistant -> \"ASSISTANT\"\n          contentText = T.intercalate \" \" (map formatBlock msg.content)\n      in roleLabel <> \": \" <> contentText\n\n    formatBlock :: ContentBlock -> Text\n    formatBlock (TextBlock t) = t\n    formatBlock (ImageBlock _) = \"[IMAGE]\"\n    formatBlock (ToolUseBlock tu) = \"[TOOL:\" <> tu.toolName <> \"]\"\n    formatBlock (ToolResultBlock tr) = \"[TOOL_RESULT:\" <> tr.toolResultContent <> \"]\"\n    formatBlock (ThinkingBlock tc) = \"[THINKING:\" <> tc.thinkingText <> \"]\"\n    formatBlock (RedactedThinkingBlock _) = \"[REDACTED_THINKING]\"\n    formatBlock (JsonBlock _) = \"[JSON]\"\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LOG AND GAME RUNNERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run the full game effect stack\n", "criteria": "CRITERIA_0906", "selected": "SELECTED_0906", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "formatMessagesForCompression", "range": {"end": {"character": 28, "line": 665}, "start": {"character": 0, "line": 665}}}
{"example_id": "0907", "variation": "negative_1", "code": "formatMessagesForCompression = T.intercalate \"\\n\\n\" . map formatMessage\n  where\n    formatMessage msg =\n      let roleLabel = case msg.role of\n            User -> \"USER\"\n            Assistant -> \"ASSISTANT\"\n          contentText = T.intercalate \" \" (map formatBlock msg.content)\n      in roleLabel <> \": \" <> contentText\n\n    formatBlock :: ContentBlock -> Text\n    formatBlock (TextBlock t) = t\n    formatBlock (ImageBlock _) = \"[IMAGE]\"\n    formatBlock (ToolUseBlock tu) = \"[TOOL:\" <> tu.toolName <> \"]\"\n    formatBlock (ToolResultBlock tr) = \"[TOOL_RESULT:\" <> tr.toolResultContent <> \"]\"\n    formatBlock (ThinkingBlock tc) = \"[THINKING:\" <> tc.thinkingText <> \"]\"\n    formatBlock (RedactedThinkingBlock _) = \"[REDACTED_THINKING]\"\n    formatBlock (JsonBlock _) = \"[JSON]\"\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LOG AND GAME RUNNERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run the full game effect stack\n", "criteria": "CRITERIA_0907", "selected": "SELECTED_0907", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "formatMessagesForCompression", "range": {"end": {"character": 28, "line": 665}, "start": {"character": 0, "line": 665}}}
{"example_id": "0908", "variation": "negative_2", "code": "formatMessagesForCompression = T.intercalate \"\\n\\n\" . map formatMessage\n  where\n    formatMessage msg =\n      let roleLabel = case msg.role of\n            User -> \"USER\"\n            Assistant -> \"ASSISTANT\"\n          contentText = T.intercalate \" \" (map formatBlock msg.content)\n      in roleLabel <> \": \" <> contentText\n\n    formatBlock :: ContentBlock -> Text\n    formatBlock (TextBlock t) = t\n    formatBlock (ImageBlock _) = \"[IMAGE]\"\n    formatBlock (ToolUseBlock tu) = \"[TOOL:\" <> tu.toolName <> \"]\"\n    formatBlock (ToolResultBlock tr) = \"[TOOL_RESULT:\" <> tr.toolResultContent <> \"]\"\n    formatBlock (ThinkingBlock tc) = \"[THINKING:\" <> tc.thinkingText <> \"]\"\n    formatBlock (RedactedThinkingBlock _) = \"[REDACTED_THINKING]\"\n    formatBlock (JsonBlock _) = \"[JSON]\"\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- LOG AND GAME RUNNERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run the full game effect stack\n", "criteria": "CRITERIA_0908", "selected": "SELECTED_0908", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "formatMessagesForCompression", "range": {"end": {"character": 28, "line": 665}, "start": {"character": 0, "line": 665}}}
{"example_id": "0909", "variation": "positive_structure", "code": "formatPosition pos =\n  T.pack (show (pos.posLine + 1)) <> \":\" <> T.pack (show (pos.posCharacter + 1))\n", "criteria": "CRITERIA_0909", "selected": "SELECTED_0909", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/LSP.hs", "name": "formatPosition", "range": {"end": {"character": 14, "line": 61}, "start": {"character": 0, "line": 61}}}
{"example_id": "0910", "variation": "positive_semantic", "code": "formatPosition pos =\n  T.pack (show (pos.posLine + 1)) <> \":\" <> T.pack (show (pos.posCharacter + 1))\n", "criteria": "CRITERIA_0910", "selected": "SELECTED_0910", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/LSP.hs", "name": "formatPosition", "range": {"end": {"character": 14, "line": 61}, "start": {"character": 0, "line": 61}}}
{"example_id": "0911", "variation": "negative_1", "code": "formatPosition pos =\n  T.pack (show (pos.posLine + 1)) <> \":\" <> T.pack (show (pos.posCharacter + 1))\n", "criteria": "CRITERIA_0911", "selected": "SELECTED_0911", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/LSP.hs", "name": "formatPosition", "range": {"end": {"character": 14, "line": 61}, "start": {"character": 0, "line": 61}}}
{"example_id": "0912", "variation": "negative_2", "code": "formatPosition pos =\n  T.pack (show (pos.posLine + 1)) <> \":\" <> T.pack (show (pos.posCharacter + 1))\n", "criteria": "CRITERIA_0912", "selected": "SELECTED_0912", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/LSP.hs", "name": "formatPosition", "range": {"end": {"character": 14, "line": 61}, "start": {"character": 0, "line": 61}}}
{"example_id": "0913", "variation": "positive_structure", "code": "formatSelectionPrompt = undefined\n\n\n-- | Tool schema for select_symbols function with enum constraint.\n--\n-- The enum constraint is CRITICAL - it tells the model the ONLY valid\n-- outputs are from the candidate list. This prevents hallucination.\n", "criteria": "CRITERIA_0913", "selected": "SELECTED_0913", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "formatSelectionPrompt", "range": {"end": {"character": 21, "line": 254}, "start": {"character": 0, "line": 254}}}
{"example_id": "0914", "variation": "positive_semantic", "code": "formatSelectionPrompt = undefined\n\n\n-- | Tool schema for select_symbols function with enum constraint.\n--\n-- The enum constraint is CRITICAL - it tells the model the ONLY valid\n-- outputs are from the candidate list. This prevents hallucination.\n", "criteria": "CRITERIA_0914", "selected": "SELECTED_0914", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "formatSelectionPrompt", "range": {"end": {"character": 21, "line": 254}, "start": {"character": 0, "line": 254}}}
{"example_id": "0915", "variation": "negative_1", "code": "formatSelectionPrompt = undefined\n\n\n-- | Tool schema for select_symbols function with enum constraint.\n--\n-- The enum constraint is CRITICAL - it tells the model the ONLY valid\n-- outputs are from the candidate list. This prevents hallucination.\n", "criteria": "CRITERIA_0915", "selected": "SELECTED_0915", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "formatSelectionPrompt", "range": {"end": {"character": 21, "line": 254}, "start": {"character": 0, "line": 254}}}
{"example_id": "0916", "variation": "negative_2", "code": "formatSelectionPrompt = undefined\n\n\n-- | Tool schema for select_symbols function with enum constraint.\n--\n-- The enum constraint is CRITICAL - it tells the model the ONLY valid\n-- outputs are from the candidate list. This prevents hallucination.\n", "criteria": "CRITERIA_0916", "selected": "SELECTED_0916", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "formatSelectionPrompt", "range": {"end": {"character": 21, "line": 254}, "start": {"character": 0, "line": 254}}}
{"example_id": "0917", "variation": "positive_structure", "code": "  extractChoice :: GotoChoice targets -> (Text, Value)\n\n\n-- | Base case: single named target.\n", "criteria": "CRITERIA_0917", "selected": "SELECTED_0917", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "extractChoice", "range": {"end": {"character": 54, "line": 454}, "start": {"character": 2, "line": 454}}}
{"example_id": "0918", "variation": "positive_semantic", "code": "  extractChoice :: GotoChoice targets -> (Text, Value)\n\n\n-- | Base case: single named target.\n", "criteria": "CRITERIA_0918", "selected": "SELECTED_0918", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "extractChoice", "range": {"end": {"character": 54, "line": 454}, "start": {"character": 2, "line": 454}}}
{"example_id": "0919", "variation": "negative_1", "code": "  extractChoice :: GotoChoice targets -> (Text, Value)\n\n\n-- | Base case: single named target.\n", "criteria": "CRITERIA_0919", "selected": "SELECTED_0919", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "extractChoice", "range": {"end": {"character": 54, "line": 454}, "start": {"character": 2, "line": 454}}}
{"example_id": "0920", "variation": "negative_2", "code": "  extractChoice :: GotoChoice targets -> (Text, Value)\n\n\n-- | Base case: single named target.\n", "criteria": "CRITERIA_0920", "selected": "SELECTED_0920", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Graph.hs", "name": "extractChoice", "range": {"end": {"character": 54, "line": 454}, "start": {"character": 2, "line": 454}}}
{"example_id": "0921", "variation": "positive_structure", "code": "  extractTargets :: GotoAll targets -> [(Text, Value)]\n\n-- | Base case: empty target list.\n", "criteria": "CRITERIA_0921", "selected": "SELECTED_0921", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Dispatch.hs", "name": "extractTargets", "range": {"end": {"character": 54, "line": 128}, "start": {"character": 2, "line": 128}}}
{"example_id": "0922", "variation": "positive_semantic", "code": "  extractTargets :: GotoAll targets -> [(Text, Value)]\n\n-- | Base case: empty target list.\n", "criteria": "CRITERIA_0922", "selected": "SELECTED_0922", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Dispatch.hs", "name": "extractTargets", "range": {"end": {"character": 54, "line": 128}, "start": {"character": 2, "line": 128}}}
{"example_id": "0923", "variation": "negative_1", "code": "  extractTargets :: GotoAll targets -> [(Text, Value)]\n\n-- | Base case: empty target list.\n", "criteria": "CRITERIA_0923", "selected": "SELECTED_0923", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Dispatch.hs", "name": "extractTargets", "range": {"end": {"character": 54, "line": 128}, "start": {"character": 2, "line": 128}}}
{"example_id": "0924", "variation": "negative_2", "code": "  extractTargets :: GotoAll targets -> [(Text, Value)]\n\n-- | Base case: empty target list.\n", "criteria": "CRITERIA_0924", "selected": "SELECTED_0924", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Dispatch.hs", "name": "extractTargets", "range": {"end": {"character": 54, "line": 128}, "start": {"character": 2, "line": 128}}}
{"example_id": "0925", "variation": "positive_structure", "code": "  extractMergeResults :: HashMap Text Value -> Either Text (HList (FromPayloads sources))\n\n", "criteria": "CRITERIA_0925", "selected": "SELECTED_0925", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Merge.hs", "name": "extractMergeResults", "range": {"end": {"character": 89, "line": 197}, "start": {"character": 2, "line": 197}}}
{"example_id": "0926", "variation": "positive_semantic", "code": "  extractMergeResults :: HashMap Text Value -> Either Text (HList (FromPayloads sources))\n\n", "criteria": "CRITERIA_0926", "selected": "SELECTED_0926", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Merge.hs", "name": "extractMergeResults", "range": {"end": {"character": 89, "line": 197}, "start": {"character": 2, "line": 197}}}
{"example_id": "0927", "variation": "negative_1", "code": "  extractMergeResults :: HashMap Text Value -> Either Text (HList (FromPayloads sources))\n\n", "criteria": "CRITERIA_0927", "selected": "SELECTED_0927", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Merge.hs", "name": "extractMergeResults", "range": {"end": {"character": 89, "line": 197}, "start": {"character": 2, "line": 197}}}
{"example_id": "0928", "variation": "negative_2", "code": "  extractMergeResults :: HashMap Text Value -> Either Text (HList (FromPayloads sources))\n\n", "criteria": "CRITERIA_0928", "selected": "SELECTED_0928", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/runtime/actor/src/Tidepool/Actor/Merge.hs", "name": "extractMergeResults", "range": {"end": {"character": 89, "line": 197}, "start": {"character": 2, "line": 197}}}
{"example_id": "0929", "variation": "positive_structure", "code": "extractSchemaFields schema =\n  [ (name, schemaTypeToText fieldSchema.schemaType, name `elem` schema.schemaRequired)\n  | (name, fieldSchema) <- Map.toList schema.schemaProperties\n  ]\n  where\n    schemaTypeToText TString = \"String\"\n    schemaTypeToText TNumber = \"Number\"\n    schemaTypeToText TInteger = \"Integer\"\n    schemaTypeToText TBoolean = \"Boolean\"\n    schemaTypeToText TObject = \"Object\"\n    schemaTypeToText TArray = \"Array\"\n    schemaTypeToText TNull = \"Null\"\n\n-- | Simplify a TypeRep to just the type name (strip module prefix).\n", "criteria": "CRITERIA_0929", "selected": "SELECTED_0929", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Reify.hs", "name": "extractSchemaFields", "range": {"end": {"character": 19, "line": 256}, "start": {"character": 0, "line": 256}}}
{"example_id": "0930", "variation": "positive_semantic", "code": "extractSchemaFields schema =\n  [ (name, schemaTypeToText fieldSchema.schemaType, name `elem` schema.schemaRequired)\n  | (name, fieldSchema) <- Map.toList schema.schemaProperties\n  ]\n  where\n    schemaTypeToText TString = \"String\"\n    schemaTypeToText TNumber = \"Number\"\n    schemaTypeToText TInteger = \"Integer\"\n    schemaTypeToText TBoolean = \"Boolean\"\n    schemaTypeToText TObject = \"Object\"\n    schemaTypeToText TArray = \"Array\"\n    schemaTypeToText TNull = \"Null\"\n\n-- | Simplify a TypeRep to just the type name (strip module prefix).\n", "criteria": "CRITERIA_0930", "selected": "SELECTED_0930", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Reify.hs", "name": "extractSchemaFields", "range": {"end": {"character": 19, "line": 256}, "start": {"character": 0, "line": 256}}}
{"example_id": "0931", "variation": "negative_1", "code": "extractSchemaFields schema =\n  [ (name, schemaTypeToText fieldSchema.schemaType, name `elem` schema.schemaRequired)\n  | (name, fieldSchema) <- Map.toList schema.schemaProperties\n  ]\n  where\n    schemaTypeToText TString = \"String\"\n    schemaTypeToText TNumber = \"Number\"\n    schemaTypeToText TInteger = \"Integer\"\n    schemaTypeToText TBoolean = \"Boolean\"\n    schemaTypeToText TObject = \"Object\"\n    schemaTypeToText TArray = \"Array\"\n    schemaTypeToText TNull = \"Null\"\n\n-- | Simplify a TypeRep to just the type name (strip module prefix).\n", "criteria": "CRITERIA_0931", "selected": "SELECTED_0931", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Reify.hs", "name": "extractSchemaFields", "range": {"end": {"character": 19, "line": 256}, "start": {"character": 0, "line": 256}}}
{"example_id": "0932", "variation": "negative_2", "code": "extractSchemaFields schema =\n  [ (name, schemaTypeToText fieldSchema.schemaType, name `elem` schema.schemaRequired)\n  | (name, fieldSchema) <- Map.toList schema.schemaProperties\n  ]\n  where\n    schemaTypeToText TString = \"String\"\n    schemaTypeToText TNumber = \"Number\"\n    schemaTypeToText TInteger = \"Integer\"\n    schemaTypeToText TBoolean = \"Boolean\"\n    schemaTypeToText TObject = \"Object\"\n    schemaTypeToText TArray = \"Array\"\n    schemaTypeToText TNull = \"Null\"\n\n-- | Simplify a TypeRep to just the type name (strip module prefix).\n", "criteria": "CRITERIA_0932", "selected": "SELECTED_0932", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Reify.hs", "name": "extractSchemaFields", "range": {"end": {"character": 19, "line": 256}, "start": {"character": 0, "line": 256}}}
{"example_id": "0933", "variation": "positive_structure", "code": "extractMarkupContent content = case content of\n  L.InL mc -> mc._value\n  L.InR msOrList -> case msOrList of\n    L.InL ms -> markedStringToText ms\n    L.InR msList -> T.intercalate \"\\n\" (map markedStringToText msList)\n\n", "criteria": "CRITERIA_0933", "selected": "SELECTED_0933", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractMarkupContent", "range": {"end": {"character": 20, "line": 329}, "start": {"character": 0, "line": 329}}}
{"example_id": "0934", "variation": "positive_semantic", "code": "extractMarkupContent content = case content of\n  L.InL mc -> mc._value\n  L.InR msOrList -> case msOrList of\n    L.InL ms -> markedStringToText ms\n    L.InR msList -> T.intercalate \"\\n\" (map markedStringToText msList)\n\n", "criteria": "CRITERIA_0934", "selected": "SELECTED_0934", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractMarkupContent", "range": {"end": {"character": 20, "line": 329}, "start": {"character": 0, "line": 329}}}
{"example_id": "0935", "variation": "negative_1", "code": "extractMarkupContent content = case content of\n  L.InL mc -> mc._value\n  L.InR msOrList -> case msOrList of\n    L.InL ms -> markedStringToText ms\n    L.InR msList -> T.intercalate \"\\n\" (map markedStringToText msList)\n\n", "criteria": "CRITERIA_0935", "selected": "SELECTED_0935", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractMarkupContent", "range": {"end": {"character": 20, "line": 329}, "start": {"character": 0, "line": 329}}}
{"example_id": "0936", "variation": "negative_2", "code": "extractMarkupContent content = case content of\n  L.InL mc -> mc._value\n  L.InR msOrList -> case msOrList of\n    L.InL ms -> markedStringToText ms\n    L.InR msList -> T.intercalate \"\\n\" (map markedStringToText msList)\n\n", "criteria": "CRITERIA_0936", "selected": "SELECTED_0936", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractMarkupContent", "range": {"end": {"character": 20, "line": 329}, "start": {"character": 0, "line": 329}}}
{"example_id": "0937", "variation": "positive_structure", "code": "extractDocumentation doc = case doc of\n  L.InL t -> t\n  L.InR mc -> mc._value\n\n", "criteria": "CRITERIA_0937", "selected": "SELECTED_0937", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractDocumentation", "range": {"end": {"character": 20, "line": 426}, "start": {"character": 0, "line": 426}}}
{"example_id": "0938", "variation": "positive_semantic", "code": "extractDocumentation doc = case doc of\n  L.InL t -> t\n  L.InR mc -> mc._value\n\n", "criteria": "CRITERIA_0938", "selected": "SELECTED_0938", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractDocumentation", "range": {"end": {"character": 20, "line": 426}, "start": {"character": 0, "line": 426}}}
{"example_id": "0939", "variation": "negative_1", "code": "extractDocumentation doc = case doc of\n  L.InL t -> t\n  L.InR mc -> mc._value\n\n", "criteria": "CRITERIA_0939", "selected": "SELECTED_0939", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractDocumentation", "range": {"end": {"character": 20, "line": 426}, "start": {"character": 0, "line": 426}}}
{"example_id": "0940", "variation": "negative_2", "code": "extractDocumentation doc = case doc of\n  L.InL t -> t\n  L.InR mc -> mc._value\n\n", "criteria": "CRITERIA_0940", "selected": "SELECTED_0940", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractDocumentation", "range": {"end": {"character": 20, "line": 426}, "start": {"character": 0, "line": 426}}}
{"example_id": "0941", "variation": "positive_structure", "code": "extractLocationFromWS loc = case loc of\n  L.InL l -> fromLocation l\n  L.InR (L.LocationUriOnly uri) -> Location\n    { locUri = let L.Uri u = uri in u\n    , locRange = Range (Position 0 0) (Position 0 0)\n    }\n\n", "criteria": "CRITERIA_0941", "selected": "SELECTED_0941", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractLocationFromWS", "range": {"end": {"character": 21, "line": 483}, "start": {"character": 0, "line": 483}}}
{"example_id": "0942", "variation": "positive_semantic", "code": "extractLocationFromWS loc = case loc of\n  L.InL l -> fromLocation l\n  L.InR (L.LocationUriOnly uri) -> Location\n    { locUri = let L.Uri u = uri in u\n    , locRange = Range (Position 0 0) (Position 0 0)\n    }\n\n", "criteria": "CRITERIA_0942", "selected": "SELECTED_0942", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractLocationFromWS", "range": {"end": {"character": 21, "line": 483}, "start": {"character": 0, "line": 483}}}
{"example_id": "0943", "variation": "negative_1", "code": "extractLocationFromWS loc = case loc of\n  L.InL l -> fromLocation l\n  L.InR (L.LocationUriOnly uri) -> Location\n    { locUri = let L.Uri u = uri in u\n    , locRange = Range (Position 0 0) (Position 0 0)\n    }\n\n", "criteria": "CRITERIA_0943", "selected": "SELECTED_0943", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractLocationFromWS", "range": {"end": {"character": 21, "line": 483}, "start": {"character": 0, "line": 483}}}
{"example_id": "0944", "variation": "negative_2", "code": "extractLocationFromWS loc = case loc of\n  L.InL l -> fromLocation l\n  L.InR (L.LocationUriOnly uri) -> Location\n    { locUri = let L.Uri u = uri in u\n    , locRange = Range (Position 0 0) (Position 0 0)\n    }\n\n", "criteria": "CRITERIA_0944", "selected": "SELECTED_0944", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "extractLocationFromWS", "range": {"end": {"character": 21, "line": 483}, "start": {"character": 0, "line": 483}}}
{"example_id": "0945", "variation": "positive_structure", "code": "extractText = T.intercalate \" \" . mapMaybe getText\n  where\n    getText (TextBlock t) = Just t\n    getText _ = Nothing\n", "criteria": "CRITERIA_0945", "selected": "SELECTED_0945", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "extractText", "range": {"end": {"character": 11, "line": 709}, "start": {"character": 0, "line": 709}}}
{"example_id": "0946", "variation": "positive_semantic", "code": "extractText = T.intercalate \" \" . mapMaybe getText\n  where\n    getText (TextBlock t) = Just t\n    getText _ = Nothing\n", "criteria": "CRITERIA_0946", "selected": "SELECTED_0946", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "extractText", "range": {"end": {"character": 11, "line": 709}, "start": {"character": 0, "line": 709}}}
{"example_id": "0947", "variation": "negative_1", "code": "extractText = T.intercalate \" \" . mapMaybe getText\n  where\n    getText (TextBlock t) = Just t\n    getText _ = Nothing\n", "criteria": "CRITERIA_0947", "selected": "SELECTED_0947", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "extractText", "range": {"end": {"character": 11, "line": 709}, "start": {"character": 0, "line": 709}}}
{"example_id": "0948", "variation": "negative_2", "code": "extractText = T.intercalate \" \" . mapMaybe getText\n  where\n    getText (TextBlock t) = Just t\n    getText _ = Nothing\n", "criteria": "CRITERIA_0948", "selected": "SELECTED_0948", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Effect/Runners.hs", "name": "extractText", "range": {"end": {"character": 11, "line": 709}, "start": {"character": 0, "line": 709}}}
{"example_id": "0949", "variation": "positive_structure", "code": "extractFinalOutput blocks =\n  -- First, look for a JsonBlock (from output_format structured output)\n  case [v | JsonBlock v <- blocks] of\n    (jsonVal:_) -> jsonVal\n    [] ->\n      -- Fall back to parsing the last text block as JSON\n      case [t | TextBlock t <- reverse blocks] of\n        [] -> Null\n        (lastText:_) ->\n          case decode (LBS.fromStrict $ TE.encodeUtf8 lastText) of\n            Just v -> v\n            Nothing -> String lastText  -- If not valid JSON, return as string\n", "criteria": "CRITERIA_0949", "selected": "SELECTED_0949", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Anthropic/Client.hs", "name": "extractFinalOutput", "range": {"end": {"character": 18, "line": 318}, "start": {"character": 0, "line": 318}}}
{"example_id": "0950", "variation": "positive_semantic", "code": "extractFinalOutput blocks =\n  -- First, look for a JsonBlock (from output_format structured output)\n  case [v | JsonBlock v <- blocks] of\n    (jsonVal:_) -> jsonVal\n    [] ->\n      -- Fall back to parsing the last text block as JSON\n      case [t | TextBlock t <- reverse blocks] of\n        [] -> Null\n        (lastText:_) ->\n          case decode (LBS.fromStrict $ TE.encodeUtf8 lastText) of\n            Just v -> v\n            Nothing -> String lastText  -- If not valid JSON, return as string\n", "criteria": "CRITERIA_0950", "selected": "SELECTED_0950", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Anthropic/Client.hs", "name": "extractFinalOutput", "range": {"end": {"character": 18, "line": 318}, "start": {"character": 0, "line": 318}}}
{"example_id": "0951", "variation": "negative_1", "code": "extractFinalOutput blocks =\n  -- First, look for a JsonBlock (from output_format structured output)\n  case [v | JsonBlock v <- blocks] of\n    (jsonVal:_) -> jsonVal\n    [] ->\n      -- Fall back to parsing the last text block as JSON\n      case [t | TextBlock t <- reverse blocks] of\n        [] -> Null\n        (lastText:_) ->\n          case decode (LBS.fromStrict $ TE.encodeUtf8 lastText) of\n            Just v -> v\n            Nothing -> String lastText  -- If not valid JSON, return as string\n", "criteria": "CRITERIA_0951", "selected": "SELECTED_0951", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Anthropic/Client.hs", "name": "extractFinalOutput", "range": {"end": {"character": 18, "line": 318}, "start": {"character": 0, "line": 318}}}
{"example_id": "0952", "variation": "negative_2", "code": "extractFinalOutput blocks =\n  -- First, look for a JsonBlock (from output_format structured output)\n  case [v | JsonBlock v <- blocks] of\n    (jsonVal:_) -> jsonVal\n    [] ->\n      -- Fall back to parsing the last text block as JSON\n      case [t | TextBlock t <- reverse blocks] of\n        [] -> Null\n        (lastText:_) ->\n          case decode (LBS.fromStrict $ TE.encodeUtf8 lastText) of\n            Just v -> v\n            Nothing -> String lastText  -- If not valid JSON, return as string\n", "criteria": "CRITERIA_0952", "selected": "SELECTED_0952", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Anthropic/Client.hs", "name": "extractFinalOutput", "range": {"end": {"character": 18, "line": 318}, "start": {"character": 0, "line": 318}}}
{"example_id": "0953", "variation": "positive_structure", "code": "extractOutput blocks =\n  -- Look for JsonBlock first\n  case [v | JsonBlock v <- blocks] of\n    (v:_) -> case fromJSON v of\n      Success so -> Just so\n      Error _ -> Nothing\n    [] -> Nothing\n", "criteria": "CRITERIA_0953", "selected": "SELECTED_0953", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Graph/CLI/Example/Graph.hs", "name": "extractOutput", "range": {"end": {"character": 13, "line": 82}, "start": {"character": 0, "line": 82}}}
{"example_id": "0954", "variation": "positive_semantic", "code": "extractOutput blocks =\n  -- Look for JsonBlock first\n  case [v | JsonBlock v <- blocks] of\n    (v:_) -> case fromJSON v of\n      Success so -> Just so\n      Error _ -> Nothing\n    [] -> Nothing\n", "criteria": "CRITERIA_0954", "selected": "SELECTED_0954", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Graph/CLI/Example/Graph.hs", "name": "extractOutput", "range": {"end": {"character": 13, "line": 82}, "start": {"character": 0, "line": 82}}}
{"example_id": "0955", "variation": "negative_1", "code": "extractOutput blocks =\n  -- Look for JsonBlock first\n  case [v | JsonBlock v <- blocks] of\n    (v:_) -> case fromJSON v of\n      Success so -> Just so\n      Error _ -> Nothing\n    [] -> Nothing\n", "criteria": "CRITERIA_0955", "selected": "SELECTED_0955", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Graph/CLI/Example/Graph.hs", "name": "extractOutput", "range": {"end": {"character": 13, "line": 82}, "start": {"character": 0, "line": 82}}}
{"example_id": "0956", "variation": "negative_2", "code": "extractOutput blocks =\n  -- Look for JsonBlock first\n  case [v | JsonBlock v <- blocks] of\n    (v:_) -> case fromJSON v of\n      Success so -> Just so\n      Error _ -> Nothing\n    [] -> Nothing\n", "criteria": "CRITERIA_0956", "selected": "SELECTED_0956", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Graph/CLI/Example/Graph.hs", "name": "extractOutput", "range": {"end": {"character": 13, "line": 82}, "start": {"character": 0, "line": 82}}}
{"example_id": "0957", "variation": "positive_structure", "code": "extractTypeName TypeReference hover =\n  case T.words hover of\n    (\"data\":name:_)    -> Just name\n    (\"newtype\":name:_) -> Just name\n    (\"type\":name:_)    -> Just name\n    (\"class\":name:_)   -> Just name\n    _                  -> Nothing\n", "criteria": "CRITERIA_0957", "selected": "SELECTED_0957", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractTypeName", "range": {"end": {"character": 15, "line": 155}, "start": {"character": 0, "line": 155}}}
{"example_id": "0958", "variation": "positive_semantic", "code": "extractTypeName TypeReference hover =\n  case T.words hover of\n    (\"data\":name:_)    -> Just name\n    (\"newtype\":name:_) -> Just name\n    (\"type\":name:_)    -> Just name\n    (\"class\":name:_)   -> Just name\n    _                  -> Nothing\n", "criteria": "CRITERIA_0958", "selected": "SELECTED_0958", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractTypeName", "range": {"end": {"character": 15, "line": 155}, "start": {"character": 0, "line": 155}}}
{"example_id": "0959", "variation": "negative_1", "code": "extractTypeName TypeReference hover =\n  case T.words hover of\n    (\"data\":name:_)    -> Just name\n    (\"newtype\":name:_) -> Just name\n    (\"type\":name:_)    -> Just name\n    (\"class\":name:_)   -> Just name\n    _                  -> Nothing\n", "criteria": "CRITERIA_0959", "selected": "SELECTED_0959", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractTypeName", "range": {"end": {"character": 15, "line": 155}, "start": {"character": 0, "line": 155}}}
{"example_id": "0960", "variation": "negative_2", "code": "extractTypeName TypeReference hover =\n  case T.words hover of\n    (\"data\":name:_)    -> Just name\n    (\"newtype\":name:_) -> Just name\n    (\"type\":name:_)    -> Just name\n    (\"class\":name:_)   -> Just name\n    _                  -> Nothing\n", "criteria": "CRITERIA_0960", "selected": "SELECTED_0960", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractTypeName", "range": {"end": {"character": 15, "line": 155}, "start": {"character": 0, "line": 155}}}
{"example_id": "0961", "variation": "positive_structure", "code": "extractFunctionSig ValueReference hover\n  | \" :: \" `T.isInfixOf` hover = Just $ T.strip $ snd $ T.breakOn \" :: \" hover\n", "criteria": "CRITERIA_0961", "selected": "SELECTED_0961", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractFunctionSig", "range": {"end": {"character": 18, "line": 166}, "start": {"character": 0, "line": 166}}}
{"example_id": "0962", "variation": "positive_semantic", "code": "extractFunctionSig ValueReference hover\n  | \" :: \" `T.isInfixOf` hover = Just $ T.strip $ snd $ T.breakOn \" :: \" hover\n", "criteria": "CRITERIA_0962", "selected": "SELECTED_0962", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractFunctionSig", "range": {"end": {"character": 18, "line": 166}, "start": {"character": 0, "line": 166}}}
{"example_id": "0963", "variation": "negative_1", "code": "extractFunctionSig ValueReference hover\n  | \" :: \" `T.isInfixOf` hover = Just $ T.strip $ snd $ T.breakOn \" :: \" hover\n", "criteria": "CRITERIA_0963", "selected": "SELECTED_0963", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractFunctionSig", "range": {"end": {"character": 18, "line": 166}, "start": {"character": 0, "line": 166}}}
{"example_id": "0964", "variation": "negative_2", "code": "extractFunctionSig ValueReference hover\n  | \" :: \" `T.isInfixOf` hover = Just $ T.strip $ snd $ T.breakOn \" :: \" hover\n", "criteria": "CRITERIA_0964", "selected": "SELECTED_0964", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractFunctionSig", "range": {"end": {"character": 18, "line": 166}, "start": {"character": 0, "line": 166}}}
{"example_id": "0965", "variation": "positive_structure", "code": "extractPatterns PatternMatchSite snippet =\n  let lns = T.lines snippet\n      patternLines = filter (\\l -> \"->\" `T.isInfixOf` l || \"= case\" `T.isInfixOf` l) lns\n  in if null patternLines then Nothing else Just patternLines\n", "criteria": "CRITERIA_0965", "selected": "SELECTED_0965", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractPatterns", "range": {"end": {"character": 15, "line": 174}, "start": {"character": 0, "line": 174}}}
{"example_id": "0966", "variation": "positive_semantic", "code": "extractPatterns PatternMatchSite snippet =\n  let lns = T.lines snippet\n      patternLines = filter (\\l -> \"->\" `T.isInfixOf` l || \"= case\" `T.isInfixOf` l) lns\n  in if null patternLines then Nothing else Just patternLines\n", "criteria": "CRITERIA_0966", "selected": "SELECTED_0966", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractPatterns", "range": {"end": {"character": 15, "line": 174}, "start": {"character": 0, "line": 174}}}
{"example_id": "0967", "variation": "negative_1", "code": "extractPatterns PatternMatchSite snippet =\n  let lns = T.lines snippet\n      patternLines = filter (\\l -> \"->\" `T.isInfixOf` l || \"= case\" `T.isInfixOf` l) lns\n  in if null patternLines then Nothing else Just patternLines\n", "criteria": "CRITERIA_0967", "selected": "SELECTED_0967", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractPatterns", "range": {"end": {"character": 15, "line": 174}, "start": {"character": 0, "line": 174}}}
{"example_id": "0968", "variation": "negative_2", "code": "extractPatterns PatternMatchSite snippet =\n  let lns = T.lines snippet\n      patternLines = filter (\\l -> \"->\" `T.isInfixOf` l || \"= case\" `T.isInfixOf` l) lns\n  in if null patternLines then Nothing else Just patternLines\n", "criteria": "CRITERIA_0968", "selected": "SELECTED_0968", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractPatterns", "range": {"end": {"character": 15, "line": 174}, "start": {"character": 0, "line": 174}}}
{"example_id": "0969", "variation": "positive_structure", "code": "extractConstraints InstanceSite hover\n  | \"=>\" `T.isInfixOf` hover =\n      let (constraints, _) = T.breakOn \"=>\" hover\n      in Just $ map T.strip $ T.splitOn \",\" constraints\n", "criteria": "CRITERIA_0969", "selected": "SELECTED_0969", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractConstraints", "range": {"end": {"character": 18, "line": 182}, "start": {"character": 0, "line": 182}}}
{"example_id": "0970", "variation": "positive_semantic", "code": "extractConstraints InstanceSite hover\n  | \"=>\" `T.isInfixOf` hover =\n      let (constraints, _) = T.breakOn \"=>\" hover\n      in Just $ map T.strip $ T.splitOn \",\" constraints\n", "criteria": "CRITERIA_0970", "selected": "SELECTED_0970", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractConstraints", "range": {"end": {"character": 18, "line": 182}, "start": {"character": 0, "line": 182}}}
{"example_id": "0971", "variation": "negative_1", "code": "extractConstraints InstanceSite hover\n  | \"=>\" `T.isInfixOf` hover =\n      let (constraints, _) = T.breakOn \"=>\" hover\n      in Just $ map T.strip $ T.splitOn \",\" constraints\n", "criteria": "CRITERIA_0971", "selected": "SELECTED_0971", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractConstraints", "range": {"end": {"character": 18, "line": 182}, "start": {"character": 0, "line": 182}}}
{"example_id": "0972", "variation": "negative_2", "code": "extractConstraints InstanceSite hover\n  | \"=>\" `T.isInfixOf` hover =\n      let (constraints, _) = T.breakOn \"=>\" hover\n      in Just $ map T.strip $ T.splitOn \",\" constraints\n", "criteria": "CRITERIA_0972", "selected": "SELECTED_0972", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/EdgeTypes.hs", "name": "extractConstraints", "range": {"end": {"character": 18, "line": 182}, "start": {"character": 0, "line": 182}}}
{"example_id": "0973", "variation": "positive_structure", "code": "extractFunctionName snippet =\n  case T.words (T.takeWhile (/= '=') snippet) of\n    (name:_) | T.all isIdentChar name -> Just (T.toLower name)\n    _ -> Nothing\n  where\n    isIdentChar c = c `elem` (\"_'\" :: String) || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n", "criteria": "CRITERIA_0973", "selected": "SELECTED_0973", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Heuristics.hs", "name": "extractFunctionName", "range": {"end": {"character": 19, "line": 200}, "start": {"character": 0, "line": 200}}}
{"example_id": "0974", "variation": "positive_semantic", "code": "extractFunctionName snippet =\n  case T.words (T.takeWhile (/= '=') snippet) of\n    (name:_) | T.all isIdentChar name -> Just (T.toLower name)\n    _ -> Nothing\n  where\n    isIdentChar c = c `elem` (\"_'\" :: String) || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n", "criteria": "CRITERIA_0974", "selected": "SELECTED_0974", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Heuristics.hs", "name": "extractFunctionName", "range": {"end": {"character": 19, "line": 200}, "start": {"character": 0, "line": 200}}}
{"example_id": "0975", "variation": "negative_1", "code": "extractFunctionName snippet =\n  case T.words (T.takeWhile (/= '=') snippet) of\n    (name:_) | T.all isIdentChar name -> Just (T.toLower name)\n    _ -> Nothing\n  where\n    isIdentChar c = c `elem` (\"_'\" :: String) || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n", "criteria": "CRITERIA_0975", "selected": "SELECTED_0975", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Heuristics.hs", "name": "extractFunctionName", "range": {"end": {"character": 19, "line": 200}, "start": {"character": 0, "line": 200}}}
{"example_id": "0976", "variation": "negative_2", "code": "extractFunctionName snippet =\n  case T.words (T.takeWhile (/= '=') snippet) of\n    (name:_) | T.all isIdentChar name -> Just (T.toLower name)\n    _ -> Nothing\n  where\n    isIdentChar c = c `elem` (\"_'\" :: String) || (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n", "criteria": "CRITERIA_0976", "selected": "SELECTED_0976", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Heuristics.hs", "name": "extractFunctionName", "range": {"end": {"character": 19, "line": 200}, "start": {"character": 0, "line": 200}}}
{"example_id": "0977", "variation": "positive_structure", "code": "extractCandidates sig =\n  let -- Strip markdown: extract just the code from ```haskell ... ```\n      codeOnly = extractCodeBlock sig\n      -- Tokenize: split on whitespace and punctuation\n      tokens = concatMap (T.splitOn \" \")\n             $ concatMap (T.splitOn \"->\")\n             $ concatMap (T.splitOn \"=>\")\n             $ T.splitOn \"::\" codeOnly\n      -- Clean each token\n      cleaned = map cleanToken tokens\n      -- Keep uppercase identifiers (type names)\n      typeNames = filter isTypeName cleaned\n      -- Remove primitives and common wrappers\n      filtered = filter (not . isCommonType) typeNames\n  in nub filtered  -- deduplicate\n  where\n    -- Extract code from markdown code blocks, or return raw if no blocks\n    extractCodeBlock :: Text -> Text\n    extractCodeBlock t =\n      let lines' = T.lines t\n          -- Find content between ``` markers\n          inCodeBlock = dropWhile (not . T.isPrefixOf \"```\") lines'\n          afterOpen = drop 1 inCodeBlock  -- Drop the ```haskell line\n          codeLines = takeWhile (not . T.isPrefixOf \"```\") afterOpen\n      in if null codeLines\n         then t  -- No code block found, use raw text\n         else T.unlines codeLines\n\n    cleanToken :: Text -> Text\n    cleanToken = T.filter (`notElem` (\"()[]{},:=`*\\n\" :: String)) . T.strip\n\n", "criteria": "CRITERIA_0977", "selected": "SELECTED_0977", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "extractCandidates", "range": {"end": {"character": 17, "line": 124}, "start": {"character": 0, "line": 124}}}
{"example_id": "0978", "variation": "positive_semantic", "code": "extractCandidates sig =\n  let -- Strip markdown: extract just the code from ```haskell ... ```\n      codeOnly = extractCodeBlock sig\n      -- Tokenize: split on whitespace and punctuation\n      tokens = concatMap (T.splitOn \" \")\n             $ concatMap (T.splitOn \"->\")\n             $ concatMap (T.splitOn \"=>\")\n             $ T.splitOn \"::\" codeOnly\n      -- Clean each token\n      cleaned = map cleanToken tokens\n      -- Keep uppercase identifiers (type names)\n      typeNames = filter isTypeName cleaned\n      -- Remove primitives and common wrappers\n      filtered = filter (not . isCommonType) typeNames\n  in nub filtered  -- deduplicate\n  where\n    -- Extract code from markdown code blocks, or return raw if no blocks\n    extractCodeBlock :: Text -> Text\n    extractCodeBlock t =\n      let lines' = T.lines t\n          -- Find content between ``` markers\n          inCodeBlock = dropWhile (not . T.isPrefixOf \"```\") lines'\n          afterOpen = drop 1 inCodeBlock  -- Drop the ```haskell line\n          codeLines = takeWhile (not . T.isPrefixOf \"```\") afterOpen\n      in if null codeLines\n         then t  -- No code block found, use raw text\n         else T.unlines codeLines\n\n    cleanToken :: Text -> Text\n    cleanToken = T.filter (`notElem` (\"()[]{},:=`*\\n\" :: String)) . T.strip\n\n", "criteria": "CRITERIA_0978", "selected": "SELECTED_0978", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "extractCandidates", "range": {"end": {"character": 17, "line": 124}, "start": {"character": 0, "line": 124}}}
{"example_id": "0979", "variation": "negative_1", "code": "extractCandidates sig =\n  let -- Strip markdown: extract just the code from ```haskell ... ```\n      codeOnly = extractCodeBlock sig\n      -- Tokenize: split on whitespace and punctuation\n      tokens = concatMap (T.splitOn \" \")\n             $ concatMap (T.splitOn \"->\")\n             $ concatMap (T.splitOn \"=>\")\n             $ T.splitOn \"::\" codeOnly\n      -- Clean each token\n      cleaned = map cleanToken tokens\n      -- Keep uppercase identifiers (type names)\n      typeNames = filter isTypeName cleaned\n      -- Remove primitives and common wrappers\n      filtered = filter (not . isCommonType) typeNames\n  in nub filtered  -- deduplicate\n  where\n    -- Extract code from markdown code blocks, or return raw if no blocks\n    extractCodeBlock :: Text -> Text\n    extractCodeBlock t =\n      let lines' = T.lines t\n          -- Find content between ``` markers\n          inCodeBlock = dropWhile (not . T.isPrefixOf \"```\") lines'\n          afterOpen = drop 1 inCodeBlock  -- Drop the ```haskell line\n          codeLines = takeWhile (not . T.isPrefixOf \"```\") afterOpen\n      in if null codeLines\n         then t  -- No code block found, use raw text\n         else T.unlines codeLines\n\n    cleanToken :: Text -> Text\n    cleanToken = T.filter (`notElem` (\"()[]{},:=`*\\n\" :: String)) . T.strip\n\n", "criteria": "CRITERIA_0979", "selected": "SELECTED_0979", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "extractCandidates", "range": {"end": {"character": 17, "line": 124}, "start": {"character": 0, "line": 124}}}
{"example_id": "0980", "variation": "negative_2", "code": "extractCandidates sig =\n  let -- Strip markdown: extract just the code from ```haskell ... ```\n      codeOnly = extractCodeBlock sig\n      -- Tokenize: split on whitespace and punctuation\n      tokens = concatMap (T.splitOn \" \")\n             $ concatMap (T.splitOn \"->\")\n             $ concatMap (T.splitOn \"=>\")\n             $ T.splitOn \"::\" codeOnly\n      -- Clean each token\n      cleaned = map cleanToken tokens\n      -- Keep uppercase identifiers (type names)\n      typeNames = filter isTypeName cleaned\n      -- Remove primitives and common wrappers\n      filtered = filter (not . isCommonType) typeNames\n  in nub filtered  -- deduplicate\n  where\n    -- Extract code from markdown code blocks, or return raw if no blocks\n    extractCodeBlock :: Text -> Text\n    extractCodeBlock t =\n      let lines' = T.lines t\n          -- Find content between ``` markers\n          inCodeBlock = dropWhile (not . T.isPrefixOf \"```\") lines'\n          afterOpen = drop 1 inCodeBlock  -- Drop the ```haskell line\n          codeLines = takeWhile (not . T.isPrefixOf \"```\") afterOpen\n      in if null codeLines\n         then t  -- No code block found, use raw text\n         else T.unlines codeLines\n\n    cleanToken :: Text -> Text\n    cleanToken = T.filter (`notElem` (\"()[]{},:=`*\\n\" :: String)) . T.strip\n\n", "criteria": "CRITERIA_0980", "selected": "SELECTED_0980", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "extractCandidates", "range": {"end": {"character": 17, "line": 124}, "start": {"character": 0, "line": 124}}}
{"example_id": "0981", "variation": "positive_structure", "code": "extractSelectedFromToolCall json = case json of\n  Aeson.Object obj ->\n    case parseMaybe (.: \"message\") obj of\n      Just (Aeson.Object msg) ->\n        case parseMaybe (.: \"tool_calls\") msg of\n          Just (Aeson.Array calls) | not (V.null calls) ->\n            case V.head calls of\n              Aeson.Object call ->\n                case parseMaybe (.: \"function\") call of\n                  Just (Aeson.Object fn) ->\n                    case parseMaybe (.: \"arguments\") fn of\n                      Just (Aeson.Object args) ->\n                        case parseMaybe (.: \"selected\") args of\n                          Just (Aeson.Array arr) ->\n                            -- Extract strings from array\n                            Right $ extractStrings (V.toList arr)\n                          _ -> Left \"No 'selected' array in arguments\"\n                      _ -> Left \"No arguments in function\"\n                  _ -> Left \"No function in tool_call\"\n              _ -> Left \"Invalid tool_call format\"\n          _ -> Left \"No tool_calls in message\"\n      _ -> Left \"No message in response\"\n  _ -> Left \"Response is not an object\"\n  where\n    extractStrings :: [Value] -> [Text]\n    extractStrings = concatMap $ \\case\n      Aeson.String s -> [s]\n      _ -> []\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n", "criteria": "CRITERIA_0981", "selected": "SELECTED_0981", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "extractSelectedFromToolCall", "range": {"end": {"character": 27, "line": 309}, "start": {"character": 0, "line": 309}}}
{"example_id": "0982", "variation": "positive_semantic", "code": "extractSelectedFromToolCall json = case json of\n  Aeson.Object obj ->\n    case parseMaybe (.: \"message\") obj of\n      Just (Aeson.Object msg) ->\n        case parseMaybe (.: \"tool_calls\") msg of\n          Just (Aeson.Array calls) | not (V.null calls) ->\n            case V.head calls of\n              Aeson.Object call ->\n                case parseMaybe (.: \"function\") call of\n                  Just (Aeson.Object fn) ->\n                    case parseMaybe (.: \"arguments\") fn of\n                      Just (Aeson.Object args) ->\n                        case parseMaybe (.: \"selected\") args of\n                          Just (Aeson.Array arr) ->\n                            -- Extract strings from array\n                            Right $ extractStrings (V.toList arr)\n                          _ -> Left \"No 'selected' array in arguments\"\n                      _ -> Left \"No arguments in function\"\n                  _ -> Left \"No function in tool_call\"\n              _ -> Left \"Invalid tool_call format\"\n          _ -> Left \"No tool_calls in message\"\n      _ -> Left \"No message in response\"\n  _ -> Left \"Response is not an object\"\n  where\n    extractStrings :: [Value] -> [Text]\n    extractStrings = concatMap $ \\case\n      Aeson.String s -> [s]\n      _ -> []\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n", "criteria": "CRITERIA_0982", "selected": "SELECTED_0982", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "extractSelectedFromToolCall", "range": {"end": {"character": 27, "line": 309}, "start": {"character": 0, "line": 309}}}
{"example_id": "0983", "variation": "negative_1", "code": "extractSelectedFromToolCall json = case json of\n  Aeson.Object obj ->\n    case parseMaybe (.: \"message\") obj of\n      Just (Aeson.Object msg) ->\n        case parseMaybe (.: \"tool_calls\") msg of\n          Just (Aeson.Array calls) | not (V.null calls) ->\n            case V.head calls of\n              Aeson.Object call ->\n                case parseMaybe (.: \"function\") call of\n                  Just (Aeson.Object fn) ->\n                    case parseMaybe (.: \"arguments\") fn of\n                      Just (Aeson.Object args) ->\n                        case parseMaybe (.: \"selected\") args of\n                          Just (Aeson.Array arr) ->\n                            -- Extract strings from array\n                            Right $ extractStrings (V.toList arr)\n                          _ -> Left \"No 'selected' array in arguments\"\n                      _ -> Left \"No arguments in function\"\n                  _ -> Left \"No function in tool_call\"\n              _ -> Left \"Invalid tool_call format\"\n          _ -> Left \"No tool_calls in message\"\n      _ -> Left \"No message in response\"\n  _ -> Left \"Response is not an object\"\n  where\n    extractStrings :: [Value] -> [Text]\n    extractStrings = concatMap $ \\case\n      Aeson.String s -> [s]\n      _ -> []\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n", "criteria": "CRITERIA_0983", "selected": "SELECTED_0983", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "extractSelectedFromToolCall", "range": {"end": {"character": 27, "line": 309}, "start": {"character": 0, "line": 309}}}
{"example_id": "0984", "variation": "negative_2", "code": "extractSelectedFromToolCall json = case json of\n  Aeson.Object obj ->\n    case parseMaybe (.: \"message\") obj of\n      Just (Aeson.Object msg) ->\n        case parseMaybe (.: \"tool_calls\") msg of\n          Just (Aeson.Array calls) | not (V.null calls) ->\n            case V.head calls of\n              Aeson.Object call ->\n                case parseMaybe (.: \"function\") call of\n                  Just (Aeson.Object fn) ->\n                    case parseMaybe (.: \"arguments\") fn of\n                      Just (Aeson.Object args) ->\n                        case parseMaybe (.: \"selected\") args of\n                          Just (Aeson.Array arr) ->\n                            -- Extract strings from array\n                            Right $ extractStrings (V.toList arr)\n                          _ -> Left \"No 'selected' array in arguments\"\n                      _ -> Left \"No arguments in function\"\n                  _ -> Left \"No function in tool_call\"\n              _ -> Left \"Invalid tool_call format\"\n          _ -> Left \"No tool_calls in message\"\n      _ -> Left \"No message in response\"\n  _ -> Left \"Response is not an object\"\n  where\n    extractStrings :: [Value] -> [Text]\n    extractStrings = concatMap $ \\case\n      Aeson.String s -> [s]\n      _ -> []\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n", "criteria": "CRITERIA_0984", "selected": "SELECTED_0984", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach/Gemma.hs", "name": "extractSelectedFromToolCall", "range": {"end": {"character": 27, "line": 309}, "start": {"character": 0, "line": 309}}}
{"example_id": "0985", "variation": "positive_structure", "code": "extractModuleName hoverText filePath =\n  case extractFromDefinedIn hoverText of\n    Just m -> m\n    Nothing -> extractFromFilePath filePath\n  where\n    -- Pattern: *Defined in 'Module.Name'*\n    extractFromDefinedIn t =\n      let needle = \"Defined in '\"\n      in case T.breakOn needle t of\n           (_, rest) | T.null rest -> Nothing\n           (_, rest) ->\n             let afterNeedle = T.drop (T.length needle) rest\n             in case T.breakOn \"'\" afterNeedle of\n                  (moduleName, _) | not (T.null moduleName) -> Just moduleName\n                  _ -> Nothing\n\n    -- Extract module from path like .../src/Tidepool/Effect/LSP.hs\n    extractFromFilePath p =\n      let fileName = T.takeWhileEnd (/= '/') p\n          baseName = T.dropEnd 3 fileName  -- Remove .hs\n          -- Try to find src/ prefix for module path\n          parts = T.splitOn \"/\" p\n          afterSrc = dropWhile (/= \"src\") parts\n      in case afterSrc of\n           (_src : rest) ->\n             let modPath = T.intercalate \".\" $ map (T.dropEnd 3) $ filter (T.isSuffixOf \".hs\") rest\n             in if T.null modPath then baseName else T.replace \"/\" \".\" $ T.intercalate \"/\" (init rest) <> \".\" <> baseName\n           _ -> baseName\n\n-- | Extract package name from hover info.\n--\n", "criteria": "CRITERIA_0985", "selected": "SELECTED_0985", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractModuleName", "range": {"end": {"character": 17, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0986", "variation": "positive_semantic", "code": "extractModuleName hoverText filePath =\n  case extractFromDefinedIn hoverText of\n    Just m -> m\n    Nothing -> extractFromFilePath filePath\n  where\n    -- Pattern: *Defined in 'Module.Name'*\n    extractFromDefinedIn t =\n      let needle = \"Defined in '\"\n      in case T.breakOn needle t of\n           (_, rest) | T.null rest -> Nothing\n           (_, rest) ->\n             let afterNeedle = T.drop (T.length needle) rest\n             in case T.breakOn \"'\" afterNeedle of\n                  (moduleName, _) | not (T.null moduleName) -> Just moduleName\n                  _ -> Nothing\n\n    -- Extract module from path like .../src/Tidepool/Effect/LSP.hs\n    extractFromFilePath p =\n      let fileName = T.takeWhileEnd (/= '/') p\n          baseName = T.dropEnd 3 fileName  -- Remove .hs\n          -- Try to find src/ prefix for module path\n          parts = T.splitOn \"/\" p\n          afterSrc = dropWhile (/= \"src\") parts\n      in case afterSrc of\n           (_src : rest) ->\n             let modPath = T.intercalate \".\" $ map (T.dropEnd 3) $ filter (T.isSuffixOf \".hs\") rest\n             in if T.null modPath then baseName else T.replace \"/\" \".\" $ T.intercalate \"/\" (init rest) <> \".\" <> baseName\n           _ -> baseName\n\n-- | Extract package name from hover info.\n--\n", "criteria": "CRITERIA_0986", "selected": "SELECTED_0986", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractModuleName", "range": {"end": {"character": 17, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0987", "variation": "negative_1", "code": "extractModuleName hoverText filePath =\n  case extractFromDefinedIn hoverText of\n    Just m -> m\n    Nothing -> extractFromFilePath filePath\n  where\n    -- Pattern: *Defined in 'Module.Name'*\n    extractFromDefinedIn t =\n      let needle = \"Defined in '\"\n      in case T.breakOn needle t of\n           (_, rest) | T.null rest -> Nothing\n           (_, rest) ->\n             let afterNeedle = T.drop (T.length needle) rest\n             in case T.breakOn \"'\" afterNeedle of\n                  (moduleName, _) | not (T.null moduleName) -> Just moduleName\n                  _ -> Nothing\n\n    -- Extract module from path like .../src/Tidepool/Effect/LSP.hs\n    extractFromFilePath p =\n      let fileName = T.takeWhileEnd (/= '/') p\n          baseName = T.dropEnd 3 fileName  -- Remove .hs\n          -- Try to find src/ prefix for module path\n          parts = T.splitOn \"/\" p\n          afterSrc = dropWhile (/= \"src\") parts\n      in case afterSrc of\n           (_src : rest) ->\n             let modPath = T.intercalate \".\" $ map (T.dropEnd 3) $ filter (T.isSuffixOf \".hs\") rest\n             in if T.null modPath then baseName else T.replace \"/\" \".\" $ T.intercalate \"/\" (init rest) <> \".\" <> baseName\n           _ -> baseName\n\n-- | Extract package name from hover info.\n--\n", "criteria": "CRITERIA_0987", "selected": "SELECTED_0987", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractModuleName", "range": {"end": {"character": 17, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0988", "variation": "negative_2", "code": "extractModuleName hoverText filePath =\n  case extractFromDefinedIn hoverText of\n    Just m -> m\n    Nothing -> extractFromFilePath filePath\n  where\n    -- Pattern: *Defined in 'Module.Name'*\n    extractFromDefinedIn t =\n      let needle = \"Defined in '\"\n      in case T.breakOn needle t of\n           (_, rest) | T.null rest -> Nothing\n           (_, rest) ->\n             let afterNeedle = T.drop (T.length needle) rest\n             in case T.breakOn \"'\" afterNeedle of\n                  (moduleName, _) | not (T.null moduleName) -> Just moduleName\n                  _ -> Nothing\n\n    -- Extract module from path like .../src/Tidepool/Effect/LSP.hs\n    extractFromFilePath p =\n      let fileName = T.takeWhileEnd (/= '/') p\n          baseName = T.dropEnd 3 fileName  -- Remove .hs\n          -- Try to find src/ prefix for module path\n          parts = T.splitOn \"/\" p\n          afterSrc = dropWhile (/= \"src\") parts\n      in case afterSrc of\n           (_src : rest) ->\n             let modPath = T.intercalate \".\" $ map (T.dropEnd 3) $ filter (T.isSuffixOf \".hs\") rest\n             in if T.null modPath then baseName else T.replace \"/\" \".\" $ T.intercalate \"/\" (init rest) <> \".\" <> baseName\n           _ -> baseName\n\n-- | Extract package name from hover info.\n--\n", "criteria": "CRITERIA_0988", "selected": "SELECTED_0988", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractModuleName", "range": {"end": {"character": 17, "line": 58}, "start": {"character": 0, "line": 58}}}
{"example_id": "0989", "variation": "positive_structure", "code": "extractPackageName hoverText =\n  case extractFromParens hoverText of\n    Just pkg -> pkg\n    Nothing -> \"unknown\"\n  where\n    extractFromParens t =\n      -- Pattern: *(package-name-0.1.0.0)*\n      let needle = \"*(\"\n      in case T.breakOn needle t of\n           (_, rest) | T.null rest -> Nothing\n           (_, rest) ->\n             let afterNeedle = T.drop (T.length needle) rest\n             in case T.breakOn \")*\" afterNeedle of\n                  (pkgVersion, _) | not (T.null pkgVersion) ->\n                    -- Strip version: \"tidepool-core-0.1.0.0\" -> \"tidepool-core\"\n                    Just $ stripVersion pkgVersion\n                  _ -> Nothing\n\n    -- Strip version from package name\n    -- \"tidepool-core-0.1.0.0\" -> \"tidepool-core\"\n    stripVersion pkg =\n      let parts = T.splitOn \"-\" pkg\n          -- Version parts start with digits, package parts don't\n          isVersionPart p = not (T.null p) && T.head p >= '0' && T.head p <= '9'\n          pkgParts = takeWhile (not . isVersionPart) parts\n      in if null pkgParts then pkg else T.intercalate \"-\" pkgParts\n\n-- | Extract first sentence of documentation from hover.\n--\n-- Returns Nothing if no docs found. Only returns real Haddock docs,\n-- not signature fragments.\n", "criteria": "CRITERIA_0989", "selected": "SELECTED_0989", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractPackageName", "range": {"end": {"character": 18, "line": 92}, "start": {"character": 0, "line": 92}}}
{"example_id": "0990", "variation": "positive_semantic", "code": "extractPackageName hoverText =\n  case extractFromParens hoverText of\n    Just pkg -> pkg\n    Nothing -> \"unknown\"\n  where\n    extractFromParens t =\n      -- Pattern: *(package-name-0.1.0.0)*\n      let needle = \"*(\"\n      in case T.breakOn needle t of\n           (_, rest) | T.null rest -> Nothing\n           (_, rest) ->\n             let afterNeedle = T.drop (T.length needle) rest\n             in case T.breakOn \")*\" afterNeedle of\n                  (pkgVersion, _) | not (T.null pkgVersion) ->\n                    -- Strip version: \"tidepool-core-0.1.0.0\" -> \"tidepool-core\"\n                    Just $ stripVersion pkgVersion\n                  _ -> Nothing\n\n    -- Strip version from package name\n    -- \"tidepool-core-0.1.0.0\" -> \"tidepool-core\"\n    stripVersion pkg =\n      let parts = T.splitOn \"-\" pkg\n          -- Version parts start with digits, package parts don't\n          isVersionPart p = not (T.null p) && T.head p >= '0' && T.head p <= '9'\n          pkgParts = takeWhile (not . isVersionPart) parts\n      in if null pkgParts then pkg else T.intercalate \"-\" pkgParts\n\n-- | Extract first sentence of documentation from hover.\n--\n-- Returns Nothing if no docs found. Only returns real Haddock docs,\n-- not signature fragments.\n", "criteria": "CRITERIA_0990", "selected": "SELECTED_0990", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractPackageName", "range": {"end": {"character": 18, "line": 92}, "start": {"character": 0, "line": 92}}}
{"example_id": "0991", "variation": "negative_1", "code": "extractPackageName hoverText =\n  case extractFromParens hoverText of\n    Just pkg -> pkg\n    Nothing -> \"unknown\"\n  where\n    extractFromParens t =\n      -- Pattern: *(package-name-0.1.0.0)*\n      let needle = \"*(\"\n      in case T.breakOn needle t of\n           (_, rest) | T.null rest -> Nothing\n           (_, rest) ->\n             let afterNeedle = T.drop (T.length needle) rest\n             in case T.breakOn \")*\" afterNeedle of\n                  (pkgVersion, _) | not (T.null pkgVersion) ->\n                    -- Strip version: \"tidepool-core-0.1.0.0\" -> \"tidepool-core\"\n                    Just $ stripVersion pkgVersion\n                  _ -> Nothing\n\n    -- Strip version from package name\n    -- \"tidepool-core-0.1.0.0\" -> \"tidepool-core\"\n    stripVersion pkg =\n      let parts = T.splitOn \"-\" pkg\n          -- Version parts start with digits, package parts don't\n          isVersionPart p = not (T.null p) && T.head p >= '0' && T.head p <= '9'\n          pkgParts = takeWhile (not . isVersionPart) parts\n      in if null pkgParts then pkg else T.intercalate \"-\" pkgParts\n\n-- | Extract first sentence of documentation from hover.\n--\n-- Returns Nothing if no docs found. Only returns real Haddock docs,\n-- not signature fragments.\n", "criteria": "CRITERIA_0991", "selected": "SELECTED_0991", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractPackageName", "range": {"end": {"character": 18, "line": 92}, "start": {"character": 0, "line": 92}}}
{"example_id": "0992", "variation": "negative_2", "code": "extractPackageName hoverText =\n  case extractFromParens hoverText of\n    Just pkg -> pkg\n    Nothing -> \"unknown\"\n  where\n    extractFromParens t =\n      -- Pattern: *(package-name-0.1.0.0)*\n      let needle = \"*(\"\n      in case T.breakOn needle t of\n           (_, rest) | T.null rest -> Nothing\n           (_, rest) ->\n             let afterNeedle = T.drop (T.length needle) rest\n             in case T.breakOn \")*\" afterNeedle of\n                  (pkgVersion, _) | not (T.null pkgVersion) ->\n                    -- Strip version: \"tidepool-core-0.1.0.0\" -> \"tidepool-core\"\n                    Just $ stripVersion pkgVersion\n                  _ -> Nothing\n\n    -- Strip version from package name\n    -- \"tidepool-core-0.1.0.0\" -> \"tidepool-core\"\n    stripVersion pkg =\n      let parts = T.splitOn \"-\" pkg\n          -- Version parts start with digits, package parts don't\n          isVersionPart p = not (T.null p) && T.head p >= '0' && T.head p <= '9'\n          pkgParts = takeWhile (not . isVersionPart) parts\n      in if null pkgParts then pkg else T.intercalate \"-\" pkgParts\n\n-- | Extract first sentence of documentation from hover.\n--\n-- Returns Nothing if no docs found. Only returns real Haddock docs,\n-- not signature fragments.\n", "criteria": "CRITERIA_0992", "selected": "SELECTED_0992", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractPackageName", "range": {"end": {"character": 18, "line": 92}, "start": {"character": 0, "line": 92}}}
{"example_id": "0993", "variation": "positive_structure", "code": "extractFirstSentenceDoc hoverText =\n  -- HLS hover format puts docs after the signature, typically after a blank line\n  -- or following specific patterns. Be conservative - only extract if clearly docs.\n  let allLines = T.lines hoverText\n      -- Find docs section: lines after signature that look like prose\n      docsSection = dropWhile isSignatureLine allLines\n      docLines = filter isDocLine $ take 5 docsSection  -- Look at first 5 non-sig lines\n  in case docLines of\n       [] -> Nothing\n       (firstDoc : _) ->\n         let sentence = T.strip $ firstSentence firstDoc\n         -- Reject if it still looks like code\n         in if T.null sentence || looksLikeCode sentence\n            then Nothing\n            else Just sentence\n  where\n    -- A line is part of the signature/metadata\n    isSignatureLine line =\n      let stripped = T.strip line\n      in T.null stripped\n         || \"```\" `T.isPrefixOf` stripped\n         || \"*Defined\" `T.isPrefixOf` stripped\n         || \"::\" `T.isInfixOf` stripped\n         || \"=>\" `T.isInfixOf` stripped\n         || \"forall\" `T.isPrefixOf` stripped\n         || \"->\" `T.isInfixOf` stripped\n         || \"(\" `T.isPrefixOf` stripped && \")\" `T.isSuffixOf` stripped\n\n    -- A line looks like documentation prose\n    isDocLine line =\n      let stripped = T.strip line\n", "criteria": "CRITERIA_0993", "selected": "SELECTED_0993", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractFirstSentenceDoc", "range": {"end": {"character": 23, "line": 124}, "start": {"character": 0, "line": 124}}}
{"example_id": "0994", "variation": "positive_semantic", "code": "extractFirstSentenceDoc hoverText =\n  -- HLS hover format puts docs after the signature, typically after a blank line\n  -- or following specific patterns. Be conservative - only extract if clearly docs.\n  let allLines = T.lines hoverText\n      -- Find docs section: lines after signature that look like prose\n      docsSection = dropWhile isSignatureLine allLines\n      docLines = filter isDocLine $ take 5 docsSection  -- Look at first 5 non-sig lines\n  in case docLines of\n       [] -> Nothing\n       (firstDoc : _) ->\n         let sentence = T.strip $ firstSentence firstDoc\n         -- Reject if it still looks like code\n         in if T.null sentence || looksLikeCode sentence\n            then Nothing\n            else Just sentence\n  where\n    -- A line is part of the signature/metadata\n    isSignatureLine line =\n      let stripped = T.strip line\n      in T.null stripped\n         || \"```\" `T.isPrefixOf` stripped\n         || \"*Defined\" `T.isPrefixOf` stripped\n         || \"::\" `T.isInfixOf` stripped\n         || \"=>\" `T.isInfixOf` stripped\n         || \"forall\" `T.isPrefixOf` stripped\n         || \"->\" `T.isInfixOf` stripped\n         || \"(\" `T.isPrefixOf` stripped && \")\" `T.isSuffixOf` stripped\n\n    -- A line looks like documentation prose\n    isDocLine line =\n      let stripped = T.strip line\n", "criteria": "CRITERIA_0994", "selected": "SELECTED_0994", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractFirstSentenceDoc", "range": {"end": {"character": 23, "line": 124}, "start": {"character": 0, "line": 124}}}
{"example_id": "0995", "variation": "negative_1", "code": "extractFirstSentenceDoc hoverText =\n  -- HLS hover format puts docs after the signature, typically after a blank line\n  -- or following specific patterns. Be conservative - only extract if clearly docs.\n  let allLines = T.lines hoverText\n      -- Find docs section: lines after signature that look like prose\n      docsSection = dropWhile isSignatureLine allLines\n      docLines = filter isDocLine $ take 5 docsSection  -- Look at first 5 non-sig lines\n  in case docLines of\n       [] -> Nothing\n       (firstDoc : _) ->\n         let sentence = T.strip $ firstSentence firstDoc\n         -- Reject if it still looks like code\n         in if T.null sentence || looksLikeCode sentence\n            then Nothing\n            else Just sentence\n  where\n    -- A line is part of the signature/metadata\n    isSignatureLine line =\n      let stripped = T.strip line\n      in T.null stripped\n         || \"```\" `T.isPrefixOf` stripped\n         || \"*Defined\" `T.isPrefixOf` stripped\n         || \"::\" `T.isInfixOf` stripped\n         || \"=>\" `T.isInfixOf` stripped\n         || \"forall\" `T.isPrefixOf` stripped\n         || \"->\" `T.isInfixOf` stripped\n         || \"(\" `T.isPrefixOf` stripped && \")\" `T.isSuffixOf` stripped\n\n    -- A line looks like documentation prose\n    isDocLine line =\n      let stripped = T.strip line\n", "criteria": "CRITERIA_0995", "selected": "SELECTED_0995", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractFirstSentenceDoc", "range": {"end": {"character": 23, "line": 124}, "start": {"character": 0, "line": 124}}}
{"example_id": "0996", "variation": "negative_2", "code": "extractFirstSentenceDoc hoverText =\n  -- HLS hover format puts docs after the signature, typically after a blank line\n  -- or following specific patterns. Be conservative - only extract if clearly docs.\n  let allLines = T.lines hoverText\n      -- Find docs section: lines after signature that look like prose\n      docsSection = dropWhile isSignatureLine allLines\n      docLines = filter isDocLine $ take 5 docsSection  -- Look at first 5 non-sig lines\n  in case docLines of\n       [] -> Nothing\n       (firstDoc : _) ->\n         let sentence = T.strip $ firstSentence firstDoc\n         -- Reject if it still looks like code\n         in if T.null sentence || looksLikeCode sentence\n            then Nothing\n            else Just sentence\n  where\n    -- A line is part of the signature/metadata\n    isSignatureLine line =\n      let stripped = T.strip line\n      in T.null stripped\n         || \"```\" `T.isPrefixOf` stripped\n         || \"*Defined\" `T.isPrefixOf` stripped\n         || \"::\" `T.isInfixOf` stripped\n         || \"=>\" `T.isInfixOf` stripped\n         || \"forall\" `T.isPrefixOf` stripped\n         || \"->\" `T.isInfixOf` stripped\n         || \"(\" `T.isPrefixOf` stripped && \")\" `T.isSuffixOf` stripped\n\n    -- A line looks like documentation prose\n    isDocLine line =\n      let stripped = T.strip line\n", "criteria": "CRITERIA_0996", "selected": "SELECTED_0996", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractFirstSentenceDoc", "range": {"end": {"character": 23, "line": 124}, "start": {"character": 0, "line": 124}}}
{"example_id": "0997", "variation": "positive_structure", "code": "extractReferences session fileUri pos = do\n  let doc = textDocument fileUri\n  refs <- runM $ runLSP session $ references doc pos\n  let refCount = length refs\n  if refCount > referenceCap\n    then pure $ Left $ \"[many references (\" <> T.pack (show refCount) <> \") - hub symbol]\"\n    else pure $ Right $ map locationToText refs\n  where\n    -- Format Location as \"Module.hs:42\" or similar\n    locationToText (Location uri (Range (Position line _) _)) =\n      let file = case T.stripPrefix \"file://\" uri of\n            Just f -> T.takeWhileEnd (/= '/') f  -- Just filename\n            Nothing -> uri\n      in file <> \":\" <> T.pack (show (line + 1))  -- 1-indexed for display\n\n\n-- | Build CandidateGroups from LSP orchestration.\n--\n-- - Fields: Empty (documentSymbol not available in our LSP effect)\n-- - Types: Extracted from signature via extractCandidates\n-- - References: Via findReferences with cap\n", "criteria": "CRITERIA_0997", "selected": "SELECTED_0997", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractReferences", "range": {"end": {"character": 17, "line": 316}, "start": {"character": 0, "line": 316}}}
{"example_id": "0998", "variation": "positive_semantic", "code": "extractReferences session fileUri pos = do\n  let doc = textDocument fileUri\n  refs <- runM $ runLSP session $ references doc pos\n  let refCount = length refs\n  if refCount > referenceCap\n    then pure $ Left $ \"[many references (\" <> T.pack (show refCount) <> \") - hub symbol]\"\n    else pure $ Right $ map locationToText refs\n  where\n    -- Format Location as \"Module.hs:42\" or similar\n    locationToText (Location uri (Range (Position line _) _)) =\n      let file = case T.stripPrefix \"file://\" uri of\n            Just f -> T.takeWhileEnd (/= '/') f  -- Just filename\n            Nothing -> uri\n      in file <> \":\" <> T.pack (show (line + 1))  -- 1-indexed for display\n\n\n-- | Build CandidateGroups from LSP orchestration.\n--\n-- - Fields: Empty (documentSymbol not available in our LSP effect)\n-- - Types: Extracted from signature via extractCandidates\n-- - References: Via findReferences with cap\n", "criteria": "CRITERIA_0998", "selected": "SELECTED_0998", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractReferences", "range": {"end": {"character": 17, "line": 316}, "start": {"character": 0, "line": 316}}}
{"example_id": "0999", "variation": "negative_1", "code": "extractReferences session fileUri pos = do\n  let doc = textDocument fileUri\n  refs <- runM $ runLSP session $ references doc pos\n  let refCount = length refs\n  if refCount > referenceCap\n    then pure $ Left $ \"[many references (\" <> T.pack (show refCount) <> \") - hub symbol]\"\n    else pure $ Right $ map locationToText refs\n  where\n    -- Format Location as \"Module.hs:42\" or similar\n    locationToText (Location uri (Range (Position line _) _)) =\n      let file = case T.stripPrefix \"file://\" uri of\n            Just f -> T.takeWhileEnd (/= '/') f  -- Just filename\n            Nothing -> uri\n      in file <> \":\" <> T.pack (show (line + 1))  -- 1-indexed for display\n\n\n-- | Build CandidateGroups from LSP orchestration.\n--\n-- - Fields: Empty (documentSymbol not available in our LSP effect)\n-- - Types: Extracted from signature via extractCandidates\n-- - References: Via findReferences with cap\n", "criteria": "CRITERIA_0999", "selected": "SELECTED_0999", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractReferences", "range": {"end": {"character": 17, "line": 316}, "start": {"character": 0, "line": 316}}}
{"example_id": "1000", "variation": "negative_2", "code": "extractReferences session fileUri pos = do\n  let doc = textDocument fileUri\n  refs <- runM $ runLSP session $ references doc pos\n  let refCount = length refs\n  if refCount > referenceCap\n    then pure $ Left $ \"[many references (\" <> T.pack (show refCount) <> \") - hub symbol]\"\n    else pure $ Right $ map locationToText refs\n  where\n    -- Format Location as \"Module.hs:42\" or similar\n    locationToText (Location uri (Range (Position line _) _)) =\n      let file = case T.stripPrefix \"file://\" uri of\n            Just f -> T.takeWhileEnd (/= '/') f  -- Just filename\n            Nothing -> uri\n      in file <> \":\" <> T.pack (show (line + 1))  -- 1-indexed for display\n\n\n-- | Build CandidateGroups from LSP orchestration.\n--\n-- - Fields: Empty (documentSymbol not available in our LSP effect)\n-- - Types: Extracted from signature via extractCandidates\n-- - References: Via findReferences with cap\n", "criteria": "CRITERIA_1000", "selected": "SELECTED_1000", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "extractReferences", "range": {"end": {"character": 17, "line": 316}, "start": {"character": 0, "line": 316}}}
{"example_id": "1001", "variation": "positive_structure", "code": "buildAnthropicRequest config userMsg maybeTools = Anthropic.AnthropicRequest\n  { Anthropic.arModel = config.acModel\n  , Anthropic.arMaxTokens = config.acMaxTokens\n  , Anthropic.arMessages = [Anthropic.AnthropicMessage \"user\" userMsg]\n  , Anthropic.arSystem = config.acSystemPrompt\n  , Anthropic.arTools = maybeTools\n  , Anthropic.arThinking = case config.acThinking of\n      ThinkingDisabled -> Nothing\n      ThinkingEnabled budget -> Just Anthropic.ThinkingConfig\n        { Anthropic.tcType = \"enabled\"\n        , Anthropic.tcBudgetTokens = budget\n        }\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- OPENAI CLIENT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Make a request to the OpenAI Chat Completions API using servant-client.\n", "criteria": "CRITERIA_1001", "selected": "SELECTED_1001", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "buildAnthropicRequest", "range": {"end": {"character": 21, "line": 115}, "start": {"character": 0, "line": 115}}}
{"example_id": "1002", "variation": "positive_semantic", "code": "buildAnthropicRequest config userMsg maybeTools = Anthropic.AnthropicRequest\n  { Anthropic.arModel = config.acModel\n  , Anthropic.arMaxTokens = config.acMaxTokens\n  , Anthropic.arMessages = [Anthropic.AnthropicMessage \"user\" userMsg]\n  , Anthropic.arSystem = config.acSystemPrompt\n  , Anthropic.arTools = maybeTools\n  , Anthropic.arThinking = case config.acThinking of\n      ThinkingDisabled -> Nothing\n      ThinkingEnabled budget -> Just Anthropic.ThinkingConfig\n        { Anthropic.tcType = \"enabled\"\n        , Anthropic.tcBudgetTokens = budget\n        }\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- OPENAI CLIENT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Make a request to the OpenAI Chat Completions API using servant-client.\n", "criteria": "CRITERIA_1002", "selected": "SELECTED_1002", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "buildAnthropicRequest", "range": {"end": {"character": 21, "line": 115}, "start": {"character": 0, "line": 115}}}
{"example_id": "1003", "variation": "negative_1", "code": "buildAnthropicRequest config userMsg maybeTools = Anthropic.AnthropicRequest\n  { Anthropic.arModel = config.acModel\n  , Anthropic.arMaxTokens = config.acMaxTokens\n  , Anthropic.arMessages = [Anthropic.AnthropicMessage \"user\" userMsg]\n  , Anthropic.arSystem = config.acSystemPrompt\n  , Anthropic.arTools = maybeTools\n  , Anthropic.arThinking = case config.acThinking of\n      ThinkingDisabled -> Nothing\n      ThinkingEnabled budget -> Just Anthropic.ThinkingConfig\n        { Anthropic.tcType = \"enabled\"\n        , Anthropic.tcBudgetTokens = budget\n        }\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- OPENAI CLIENT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Make a request to the OpenAI Chat Completions API using servant-client.\n", "criteria": "CRITERIA_1003", "selected": "SELECTED_1003", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "buildAnthropicRequest", "range": {"end": {"character": 21, "line": 115}, "start": {"character": 0, "line": 115}}}
{"example_id": "1004", "variation": "negative_2", "code": "buildAnthropicRequest config userMsg maybeTools = Anthropic.AnthropicRequest\n  { Anthropic.arModel = config.acModel\n  , Anthropic.arMaxTokens = config.acMaxTokens\n  , Anthropic.arMessages = [Anthropic.AnthropicMessage \"user\" userMsg]\n  , Anthropic.arSystem = config.acSystemPrompt\n  , Anthropic.arTools = maybeTools\n  , Anthropic.arThinking = case config.acThinking of\n      ThinkingDisabled -> Nothing\n      ThinkingEnabled budget -> Just Anthropic.ThinkingConfig\n        { Anthropic.tcType = \"enabled\"\n        , Anthropic.tcBudgetTokens = budget\n        }\n  }\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- OPENAI CLIENT\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Make a request to the OpenAI Chat Completions API using servant-client.\n", "criteria": "CRITERIA_1004", "selected": "SELECTED_1004", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "buildAnthropicRequest", "range": {"end": {"character": 21, "line": 115}, "start": {"character": 0, "line": 115}}}
{"example_id": "1005", "variation": "positive_structure", "code": "buildOpenAIRequest config userMsg maybeTools = OpenAI.OpenAIRequest\n  { OpenAI.orModel = config.oaModel\n  , OpenAI.orMaxTokens = config.oaMaxTokens\n  , OpenAI.orMessages = systemMsgs ++ [OpenAI.OpenAIMessage \"user\" (Just userMsg)]\n  , OpenAI.orTemperature = config.oaTemperature\n  , OpenAI.orTools = maybeTools\n  }\n  where\n    systemMsgs = case config.oaSystemPrompt of\n      Nothing -> []\n      Just sys -> [OpenAI.OpenAIMessage \"system\" (Just sys)]\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Parse a base URL from Text.\n--\n-- Defaults to HTTPS on port 443 if not specified.\n-- Handles edge cases like empty strings, missing ports, malformed URLs.\n", "criteria": "CRITERIA_1005", "selected": "SELECTED_1005", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "buildOpenAIRequest", "range": {"end": {"character": 18, "line": 163}, "start": {"character": 0, "line": 163}}}
{"example_id": "1006", "variation": "positive_semantic", "code": "buildOpenAIRequest config userMsg maybeTools = OpenAI.OpenAIRequest\n  { OpenAI.orModel = config.oaModel\n  , OpenAI.orMaxTokens = config.oaMaxTokens\n  , OpenAI.orMessages = systemMsgs ++ [OpenAI.OpenAIMessage \"user\" (Just userMsg)]\n  , OpenAI.orTemperature = config.oaTemperature\n  , OpenAI.orTools = maybeTools\n  }\n  where\n    systemMsgs = case config.oaSystemPrompt of\n      Nothing -> []\n      Just sys -> [OpenAI.OpenAIMessage \"system\" (Just sys)]\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Parse a base URL from Text.\n--\n-- Defaults to HTTPS on port 443 if not specified.\n-- Handles edge cases like empty strings, missing ports, malformed URLs.\n", "criteria": "CRITERIA_1006", "selected": "SELECTED_1006", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "buildOpenAIRequest", "range": {"end": {"character": 18, "line": 163}, "start": {"character": 0, "line": 163}}}
{"example_id": "1007", "variation": "negative_1", "code": "buildOpenAIRequest config userMsg maybeTools = OpenAI.OpenAIRequest\n  { OpenAI.orModel = config.oaModel\n  , OpenAI.orMaxTokens = config.oaMaxTokens\n  , OpenAI.orMessages = systemMsgs ++ [OpenAI.OpenAIMessage \"user\" (Just userMsg)]\n  , OpenAI.orTemperature = config.oaTemperature\n  , OpenAI.orTools = maybeTools\n  }\n  where\n    systemMsgs = case config.oaSystemPrompt of\n      Nothing -> []\n      Just sys -> [OpenAI.OpenAIMessage \"system\" (Just sys)]\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Parse a base URL from Text.\n--\n-- Defaults to HTTPS on port 443 if not specified.\n-- Handles edge cases like empty strings, missing ports, malformed URLs.\n", "criteria": "CRITERIA_1007", "selected": "SELECTED_1007", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "buildOpenAIRequest", "range": {"end": {"character": 18, "line": 163}, "start": {"character": 0, "line": 163}}}
{"example_id": "1008", "variation": "negative_2", "code": "buildOpenAIRequest config userMsg maybeTools = OpenAI.OpenAIRequest\n  { OpenAI.orModel = config.oaModel\n  , OpenAI.orMaxTokens = config.oaMaxTokens\n  , OpenAI.orMessages = systemMsgs ++ [OpenAI.OpenAIMessage \"user\" (Just userMsg)]\n  , OpenAI.orTemperature = config.oaTemperature\n  , OpenAI.orTools = maybeTools\n  }\n  where\n    systemMsgs = case config.oaSystemPrompt of\n      Nothing -> []\n      Just sys -> [OpenAI.OpenAIMessage \"system\" (Just sys)]\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- HELPERS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Parse a base URL from Text.\n--\n-- Defaults to HTTPS on port 443 if not specified.\n-- Handles edge cases like empty strings, missing ports, malformed URLs.\n", "criteria": "CRITERIA_1008", "selected": "SELECTED_1008", "file": "haskell/effects/llm-interpreter/src/Tidepool/LLM/Interpreter.hs", "name": "buildOpenAIRequest", "range": {"end": {"character": 18, "line": 163}, "start": {"character": 0, "line": 163}}}
{"example_id": "1009", "variation": "positive_structure", "code": "buildDependencyTree rootPath = do\n  (includes, extends) <- buildTreeFrom rootPath Set.empty Map.empty Map.empty\n  pure DependencyTree\n    { dtRoot = rootPath\n    , dtIncludes = includes\n    , dtExtends = extends\n    }\n\n-- | Recursively build dependency maps.\n", "criteria": "CRITERIA_1009", "selected": "SELECTED_1009", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "buildDependencyTree", "range": {"end": {"character": 19, "line": 153}, "start": {"character": 0, "line": 153}}}
{"example_id": "1010", "variation": "positive_semantic", "code": "buildDependencyTree rootPath = do\n  (includes, extends) <- buildTreeFrom rootPath Set.empty Map.empty Map.empty\n  pure DependencyTree\n    { dtRoot = rootPath\n    , dtIncludes = includes\n    , dtExtends = extends\n    }\n\n-- | Recursively build dependency maps.\n", "criteria": "CRITERIA_1010", "selected": "SELECTED_1010", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "buildDependencyTree", "range": {"end": {"character": 19, "line": 153}, "start": {"character": 0, "line": 153}}}
{"example_id": "1011", "variation": "negative_1", "code": "buildDependencyTree rootPath = do\n  (includes, extends) <- buildTreeFrom rootPath Set.empty Map.empty Map.empty\n  pure DependencyTree\n    { dtRoot = rootPath\n    , dtIncludes = includes\n    , dtExtends = extends\n    }\n\n-- | Recursively build dependency maps.\n", "criteria": "CRITERIA_1011", "selected": "SELECTED_1011", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "buildDependencyTree", "range": {"end": {"character": 19, "line": 153}, "start": {"character": 0, "line": 153}}}
{"example_id": "1012", "variation": "negative_2", "code": "buildDependencyTree rootPath = do\n  (includes, extends) <- buildTreeFrom rootPath Set.empty Map.empty Map.empty\n  pure DependencyTree\n    { dtRoot = rootPath\n    , dtIncludes = includes\n    , dtExtends = extends\n    }\n\n-- | Recursively build dependency maps.\n", "criteria": "CRITERIA_1012", "selected": "SELECTED_1012", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "buildDependencyTree", "range": {"end": {"character": 19, "line": 153}, "start": {"character": 0, "line": 153}}}
{"example_id": "1013", "variation": "positive_structure", "code": "buildTreeFrom path visited incMap extMap\n  | path `Set.member` visited = pure (incMap, extMap)  -- Cycle detected\n  | otherwise = do\n      exists <- doesFileExist path\n      if not exists\n        then pure (incMap, extMap)  -- File doesn't exist, skip\n        else do\n          content <- TIO.readFile path\n          let baseDir = takeDirectory path\n          let (incs, exts) = parseAllDependencies content\n\n          -- Resolve relative paths\n          let resolvedIncs = map (normalise . (baseDir </>)) incs\n          let resolvedExts = map (normalise . (baseDir </>)) exts\n\n          -- Update maps\n          let incMap' = if null resolvedIncs then incMap else Map.insert path resolvedIncs incMap\n          let extMap' = if null resolvedExts then extMap else Map.insert path resolvedExts extMap\n\n          -- Recursively process dependencies\n          let visited' = Set.insert path visited\n          let allDeps = resolvedIncs ++ resolvedExts\n\n          foldM\n            (\\(im, em) dep -> buildTreeFrom dep visited' im em)\n            (incMap', extMap')\n            allDeps\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE PARSING\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n", "criteria": "CRITERIA_1013", "selected": "SELECTED_1013", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "buildTreeFrom", "range": {"end": {"character": 13, "line": 168}, "start": {"character": 0, "line": 168}}}
{"example_id": "1014", "variation": "positive_semantic", "code": "buildTreeFrom path visited incMap extMap\n  | path `Set.member` visited = pure (incMap, extMap)  -- Cycle detected\n  | otherwise = do\n      exists <- doesFileExist path\n      if not exists\n        then pure (incMap, extMap)  -- File doesn't exist, skip\n        else do\n          content <- TIO.readFile path\n          let baseDir = takeDirectory path\n          let (incs, exts) = parseAllDependencies content\n\n          -- Resolve relative paths\n          let resolvedIncs = map (normalise . (baseDir </>)) incs\n          let resolvedExts = map (normalise . (baseDir </>)) exts\n\n          -- Update maps\n          let incMap' = if null resolvedIncs then incMap else Map.insert path resolvedIncs incMap\n          let extMap' = if null resolvedExts then extMap else Map.insert path resolvedExts extMap\n\n          -- Recursively process dependencies\n          let visited' = Set.insert path visited\n          let allDeps = resolvedIncs ++ resolvedExts\n\n          foldM\n            (\\(im, em) dep -> buildTreeFrom dep visited' im em)\n            (incMap', extMap')\n            allDeps\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE PARSING\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n", "criteria": "CRITERIA_1014", "selected": "SELECTED_1014", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "buildTreeFrom", "range": {"end": {"character": 13, "line": 168}, "start": {"character": 0, "line": 168}}}
{"example_id": "1015", "variation": "negative_1", "code": "buildTreeFrom path visited incMap extMap\n  | path `Set.member` visited = pure (incMap, extMap)  -- Cycle detected\n  | otherwise = do\n      exists <- doesFileExist path\n      if not exists\n        then pure (incMap, extMap)  -- File doesn't exist, skip\n        else do\n          content <- TIO.readFile path\n          let baseDir = takeDirectory path\n          let (incs, exts) = parseAllDependencies content\n\n          -- Resolve relative paths\n          let resolvedIncs = map (normalise . (baseDir </>)) incs\n          let resolvedExts = map (normalise . (baseDir </>)) exts\n\n          -- Update maps\n          let incMap' = if null resolvedIncs then incMap else Map.insert path resolvedIncs incMap\n          let extMap' = if null resolvedExts then extMap else Map.insert path resolvedExts extMap\n\n          -- Recursively process dependencies\n          let visited' = Set.insert path visited\n          let allDeps = resolvedIncs ++ resolvedExts\n\n          foldM\n            (\\(im, em) dep -> buildTreeFrom dep visited' im em)\n            (incMap', extMap')\n            allDeps\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE PARSING\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n", "criteria": "CRITERIA_1015", "selected": "SELECTED_1015", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "buildTreeFrom", "range": {"end": {"character": 13, "line": 168}, "start": {"character": 0, "line": 168}}}
{"example_id": "1016", "variation": "negative_2", "code": "buildTreeFrom path visited incMap extMap\n  | path `Set.member` visited = pure (incMap, extMap)  -- Cycle detected\n  | otherwise = do\n      exists <- doesFileExist path\n      if not exists\n        then pure (incMap, extMap)  -- File doesn't exist, skip\n        else do\n          content <- TIO.readFile path\n          let baseDir = takeDirectory path\n          let (incs, exts) = parseAllDependencies content\n\n          -- Resolve relative paths\n          let resolvedIncs = map (normalise . (baseDir </>)) incs\n          let resolvedExts = map (normalise . (baseDir </>)) exts\n\n          -- Update maps\n          let incMap' = if null resolvedIncs then incMap else Map.insert path resolvedIncs incMap\n          let extMap' = if null resolvedExts then extMap else Map.insert path resolvedExts extMap\n\n          -- Recursively process dependencies\n          let visited' = Set.insert path visited\n          let allDeps = resolvedIncs ++ resolvedExts\n\n          foldM\n            (\\(im, em) dep -> buildTreeFrom dep visited' im em)\n            (incMap', extMap')\n            allDeps\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- TEMPLATE PARSING\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n", "criteria": "CRITERIA_1016", "selected": "SELECTED_1016", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Template/DependencyTree.hs", "name": "buildTreeFrom", "range": {"end": {"character": 13, "line": 168}, "start": {"character": 0, "line": 168}}}
{"example_id": "1017", "variation": "positive_structure", "code": "buildTeachingDoc query graph =\n  let -- Convert to list of TeachingUnits\n      units = map toUnit (Map.toList graph)\n\n      -- Sort by depth, then name\n      sorted = sortOn (\\u -> (tuDepth u, lsName (tuSymbol u))) units\n\n      -- Partition by depth\n      (core, rest) = partition (\\u -> tuDepth u == 0) sorted\n      (prereqs, support) = partition (\\u -> tuDepth u <= 2) rest\n\n  in TeachingDoc\n    { tdTitle = \"Understanding: \" <> tqTopic query\n    , tdTopic = tqTopic query\n    , tdCore = core\n    , tdPrereqs = prereqs\n    , tdSupport = support\n    }\n  where\n    toUnit (_, (depth, lsp)) = TeachingUnit\n      { tuSymbol = lsp\n      , tuDepth = depth\n      }\n\n\n-- | Create an empty document when no seeds found.\n", "criteria": "CRITERIA_1017", "selected": "SELECTED_1017", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach.hs", "name": "buildTeachingDoc", "range": {"end": {"character": 16, "line": 366}, "start": {"character": 0, "line": 366}}}
{"example_id": "1018", "variation": "positive_semantic", "code": "buildTeachingDoc query graph =\n  let -- Convert to list of TeachingUnits\n      units = map toUnit (Map.toList graph)\n\n      -- Sort by depth, then name\n      sorted = sortOn (\\u -> (tuDepth u, lsName (tuSymbol u))) units\n\n      -- Partition by depth\n      (core, rest) = partition (\\u -> tuDepth u == 0) sorted\n      (prereqs, support) = partition (\\u -> tuDepth u <= 2) rest\n\n  in TeachingDoc\n    { tdTitle = \"Understanding: \" <> tqTopic query\n    , tdTopic = tqTopic query\n    , tdCore = core\n    , tdPrereqs = prereqs\n    , tdSupport = support\n    }\n  where\n    toUnit (_, (depth, lsp)) = TeachingUnit\n      { tuSymbol = lsp\n      , tuDepth = depth\n      }\n\n\n-- | Create an empty document when no seeds found.\n", "criteria": "CRITERIA_1018", "selected": "SELECTED_1018", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach.hs", "name": "buildTeachingDoc", "range": {"end": {"character": 16, "line": 366}, "start": {"character": 0, "line": 366}}}
{"example_id": "1019", "variation": "negative_1", "code": "buildTeachingDoc query graph =\n  let -- Convert to list of TeachingUnits\n      units = map toUnit (Map.toList graph)\n\n      -- Sort by depth, then name\n      sorted = sortOn (\\u -> (tuDepth u, lsName (tuSymbol u))) units\n\n      -- Partition by depth\n      (core, rest) = partition (\\u -> tuDepth u == 0) sorted\n      (prereqs, support) = partition (\\u -> tuDepth u <= 2) rest\n\n  in TeachingDoc\n    { tdTitle = \"Understanding: \" <> tqTopic query\n    , tdTopic = tqTopic query\n    , tdCore = core\n    , tdPrereqs = prereqs\n    , tdSupport = support\n    }\n  where\n    toUnit (_, (depth, lsp)) = TeachingUnit\n      { tuSymbol = lsp\n      , tuDepth = depth\n      }\n\n\n-- | Create an empty document when no seeds found.\n", "criteria": "CRITERIA_1019", "selected": "SELECTED_1019", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach.hs", "name": "buildTeachingDoc", "range": {"end": {"character": 16, "line": 366}, "start": {"character": 0, "line": 366}}}
{"example_id": "1020", "variation": "negative_2", "code": "buildTeachingDoc query graph =\n  let -- Convert to list of TeachingUnits\n      units = map toUnit (Map.toList graph)\n\n      -- Sort by depth, then name\n      sorted = sortOn (\\u -> (tuDepth u, lsName (tuSymbol u))) units\n\n      -- Partition by depth\n      (core, rest) = partition (\\u -> tuDepth u == 0) sorted\n      (prereqs, support) = partition (\\u -> tuDepth u <= 2) rest\n\n  in TeachingDoc\n    { tdTitle = \"Understanding: \" <> tqTopic query\n    , tdTopic = tqTopic query\n    , tdCore = core\n    , tdPrereqs = prereqs\n    , tdSupport = support\n    }\n  where\n    toUnit (_, (depth, lsp)) = TeachingUnit\n      { tuSymbol = lsp\n      , tuDepth = depth\n      }\n\n\n-- | Create an empty document when no seeds found.\n", "criteria": "CRITERIA_1020", "selected": "SELECTED_1020", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Scout/Teach.hs", "name": "buildTeachingDoc", "range": {"end": {"character": 16, "line": 366}, "start": {"character": 0, "line": 366}}}
{"example_id": "1021", "variation": "positive_structure", "code": "buildCandidateGroups session fileUri pos rawSig = do\n  -- Clean signature first, then parse to split inputs from output\n  let cleaned = cleanSignature rawSig\n      (inputs, output) = parseSignatureTypes cleaned\n\n  -- References with cap\n  refs <- extractReferences session fileUri pos\n\n  pure CandidateGroups\n    { cgFields = []  -- documentSymbol not available\n    , cgInputs = inputs\n    , cgOutput = output\n    , cgReferences = refs\n    }\n\n-- | Export training examples for given seed symbols.\n", "criteria": "CRITERIA_1021", "selected": "SELECTED_1021", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "buildCandidateGroups", "range": {"end": {"character": 20, "line": 343}, "start": {"character": 0, "line": 343}}}
{"example_id": "1022", "variation": "positive_semantic", "code": "buildCandidateGroups session fileUri pos rawSig = do\n  -- Clean signature first, then parse to split inputs from output\n  let cleaned = cleanSignature rawSig\n      (inputs, output) = parseSignatureTypes cleaned\n\n  -- References with cap\n  refs <- extractReferences session fileUri pos\n\n  pure CandidateGroups\n    { cgFields = []  -- documentSymbol not available\n    , cgInputs = inputs\n    , cgOutput = output\n    , cgReferences = refs\n    }\n\n-- | Export training examples for given seed symbols.\n", "criteria": "CRITERIA_1022", "selected": "SELECTED_1022", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "buildCandidateGroups", "range": {"end": {"character": 20, "line": 343}, "start": {"character": 0, "line": 343}}}
{"example_id": "1023", "variation": "negative_1", "code": "buildCandidateGroups session fileUri pos rawSig = do\n  -- Clean signature first, then parse to split inputs from output\n  let cleaned = cleanSignature rawSig\n      (inputs, output) = parseSignatureTypes cleaned\n\n  -- References with cap\n  refs <- extractReferences session fileUri pos\n\n  pure CandidateGroups\n    { cgFields = []  -- documentSymbol not available\n    , cgInputs = inputs\n    , cgOutput = output\n    , cgReferences = refs\n    }\n\n-- | Export training examples for given seed symbols.\n", "criteria": "CRITERIA_1023", "selected": "SELECTED_1023", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "buildCandidateGroups", "range": {"end": {"character": 20, "line": 343}, "start": {"character": 0, "line": 343}}}
{"example_id": "1024", "variation": "negative_2", "code": "buildCandidateGroups session fileUri pos rawSig = do\n  -- Clean signature first, then parse to split inputs from output\n  let cleaned = cleanSignature rawSig\n      (inputs, output) = parseSignatureTypes cleaned\n\n  -- References with cap\n  refs <- extractReferences session fileUri pos\n\n  pure CandidateGroups\n    { cgFields = []  -- documentSymbol not available\n    , cgInputs = inputs\n    , cgOutput = output\n    , cgReferences = refs\n    }\n\n-- | Export training examples for given seed symbols.\n", "criteria": "CRITERIA_1024", "selected": "SELECTED_1024", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "buildCandidateGroups", "range": {"end": {"character": 20, "line": 343}, "start": {"character": 0, "line": 343}}}
{"example_id": "1025", "variation": "positive_structure", "code": "createBead = send . CreateBead\n\n-- | Update an existing bead.\n--\n-- Example:\n--\n-- @\n-- updateBead \"bd-123\" $ emptyUpdateInput\n--   { ubiStatus = Just StatusInProgress\n--   , ubiAssignee = Just \"alice\"\n--   }\n-- @\n", "criteria": "CRITERIA_1025", "selected": "SELECTED_1025", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "createBead", "range": {"end": {"character": 10, "line": 417}, "start": {"character": 0, "line": 417}}}
{"example_id": "1026", "variation": "positive_semantic", "code": "createBead = send . CreateBead\n\n-- | Update an existing bead.\n--\n-- Example:\n--\n-- @\n-- updateBead \"bd-123\" $ emptyUpdateInput\n--   { ubiStatus = Just StatusInProgress\n--   , ubiAssignee = Just \"alice\"\n--   }\n-- @\n", "criteria": "CRITERIA_1026", "selected": "SELECTED_1026", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "createBead", "range": {"end": {"character": 10, "line": 417}, "start": {"character": 0, "line": 417}}}
{"example_id": "1027", "variation": "negative_1", "code": "createBead = send . CreateBead\n\n-- | Update an existing bead.\n--\n-- Example:\n--\n-- @\n-- updateBead \"bd-123\" $ emptyUpdateInput\n--   { ubiStatus = Just StatusInProgress\n--   , ubiAssignee = Just \"alice\"\n--   }\n-- @\n", "criteria": "CRITERIA_1027", "selected": "SELECTED_1027", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "createBead", "range": {"end": {"character": 10, "line": 417}, "start": {"character": 0, "line": 417}}}
{"example_id": "1028", "variation": "negative_2", "code": "createBead = send . CreateBead\n\n-- | Update an existing bead.\n--\n-- Example:\n--\n-- @\n-- updateBead \"bd-123\" $ emptyUpdateInput\n--   { ubiStatus = Just StatusInProgress\n--   , ubiAssignee = Just \"alice\"\n--   }\n-- @\n", "criteria": "CRITERIA_1028", "selected": "SELECTED_1028", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/BD.hs", "name": "createBead", "range": {"end": {"character": 10, "line": 417}, "start": {"character": 0, "line": 417}}}
{"example_id": "1029", "variation": "positive_structure", "code": "createWorktree = send . CreateWorktree\n\n-- | Delete a worktree and its associated branch.\n--\n-- Returns 'Right ()' on success (including when the worktree doesn't exist),\n-- or 'Left WorktreeGitError' if git fails unexpectedly.\n", "criteria": "CRITERIA_1029", "selected": "SELECTED_1029", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Worktree.hs", "name": "createWorktree", "range": {"end": {"character": 14, "line": 231}, "start": {"character": 0, "line": 231}}}
{"example_id": "1030", "variation": "positive_semantic", "code": "createWorktree = send . CreateWorktree\n\n-- | Delete a worktree and its associated branch.\n--\n-- Returns 'Right ()' on success (including when the worktree doesn't exist),\n-- or 'Left WorktreeGitError' if git fails unexpectedly.\n", "criteria": "CRITERIA_1030", "selected": "SELECTED_1030", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Worktree.hs", "name": "createWorktree", "range": {"end": {"character": 14, "line": 231}, "start": {"character": 0, "line": 231}}}
{"example_id": "1031", "variation": "negative_1", "code": "createWorktree = send . CreateWorktree\n\n-- | Delete a worktree and its associated branch.\n--\n-- Returns 'Right ()' on success (including when the worktree doesn't exist),\n-- or 'Left WorktreeGitError' if git fails unexpectedly.\n", "criteria": "CRITERIA_1031", "selected": "SELECTED_1031", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Worktree.hs", "name": "createWorktree", "range": {"end": {"character": 14, "line": 231}, "start": {"character": 0, "line": 231}}}
{"example_id": "1032", "variation": "negative_2", "code": "createWorktree = send . CreateWorktree\n\n-- | Delete a worktree and its associated branch.\n--\n-- Returns 'Right ()' on success (including when the worktree doesn't exist),\n-- or 'Left WorktreeGitError' if git fails unexpectedly.\n", "criteria": "CRITERIA_1032", "selected": "SELECTED_1032", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Worktree.hs", "name": "createWorktree", "range": {"end": {"character": 14, "line": 231}, "start": {"character": 0, "line": 231}}}
{"example_id": "1033", "variation": "positive_structure", "code": "createTodo title = send (CreateTodo title)\n\n", "criteria": "CRITERIA_1033", "selected": "SELECTED_1033", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "createTodo", "range": {"end": {"character": 10, "line": 93}, "start": {"character": 0, "line": 93}}}
{"example_id": "1034", "variation": "positive_semantic", "code": "createTodo title = send (CreateTodo title)\n\n", "criteria": "CRITERIA_1034", "selected": "SELECTED_1034", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "createTodo", "range": {"end": {"character": 10, "line": 93}, "start": {"character": 0, "line": 93}}}
{"example_id": "1035", "variation": "negative_1", "code": "createTodo title = send (CreateTodo title)\n\n", "criteria": "CRITERIA_1035", "selected": "SELECTED_1035", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "createTodo", "range": {"end": {"character": 10, "line": 93}, "start": {"character": 0, "line": 93}}}
{"example_id": "1036", "variation": "negative_2", "code": "createTodo title = send (CreateTodo title)\n\n", "criteria": "CRITERIA_1036", "selected": "SELECTED_1036", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "createTodo", "range": {"end": {"character": 10, "line": 93}, "start": {"character": 0, "line": 93}}}
{"example_id": "1037", "variation": "positive_structure", "code": "createTodoTry title = send (CreateTodoTry title)\n\n", "criteria": "CRITERIA_1037", "selected": "SELECTED_1037", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "createTodoTry", "range": {"end": {"character": 13, "line": 116}, "start": {"character": 0, "line": 116}}}
{"example_id": "1038", "variation": "positive_semantic", "code": "createTodoTry title = send (CreateTodoTry title)\n\n", "criteria": "CRITERIA_1038", "selected": "SELECTED_1038", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "createTodoTry", "range": {"end": {"character": 13, "line": 116}, "start": {"character": 0, "line": 116}}}
{"example_id": "1039", "variation": "negative_1", "code": "createTodoTry title = send (CreateTodoTry title)\n\n", "criteria": "CRITERIA_1039", "selected": "SELECTED_1039", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "createTodoTry", "range": {"end": {"character": 13, "line": 116}, "start": {"character": 0, "line": 116}}}
{"example_id": "1040", "variation": "negative_2", "code": "createTodoTry title = send (CreateTodoTry title)\n\n", "criteria": "CRITERIA_1040", "selected": "SELECTED_1040", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/Habitica.hs", "name": "createTodoTry", "range": {"end": {"character": 13, "line": 116}, "start": {"character": 0, "line": 116}}}
{"example_id": "1041", "variation": "positive_structure", "code": "createIssue repo title body labels = send (CreateIssue repo title body labels)\n\n", "criteria": "CRITERIA_1041", "selected": "SELECTED_1041", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "createIssue", "range": {"end": {"character": 11, "line": 318}, "start": {"character": 0, "line": 318}}}
{"example_id": "1042", "variation": "positive_semantic", "code": "createIssue repo title body labels = send (CreateIssue repo title body labels)\n\n", "criteria": "CRITERIA_1042", "selected": "SELECTED_1042", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "createIssue", "range": {"end": {"character": 11, "line": 318}, "start": {"character": 0, "line": 318}}}
{"example_id": "1043", "variation": "negative_1", "code": "createIssue repo title body labels = send (CreateIssue repo title body labels)\n\n", "criteria": "CRITERIA_1043", "selected": "SELECTED_1043", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "createIssue", "range": {"end": {"character": 11, "line": 318}, "start": {"character": 0, "line": 318}}}
{"example_id": "1044", "variation": "negative_2", "code": "createIssue repo title body labels = send (CreateIssue repo title body labels)\n\n", "criteria": "CRITERIA_1044", "selected": "SELECTED_1044", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effects/GitHub.hs", "name": "createIssue", "range": {"end": {"character": 11, "line": 318}, "start": {"character": 0, "line": 318}}}
{"example_id": "1045", "variation": "positive_structure", "code": "createGame conn mName initialState = do\n  uuid <- UUID4.nextRandom\n  let gameId = GameId (UUID.toText uuid)\n  now <- iso8601Now\n  let stateJson = encode initialState\n\n  execute conn\n    \"INSERT INTO games (id, name, world_state, created_at, updated_at) \\\n    \\VALUES (?, ?, ?, ?, ?)\"\n    (gameId, mName, stateJson, now, now)\n\n  return gameId\n\n-- | Load a game by ID\n", "criteria": "CRITERIA_1045", "selected": "SELECTED_1045", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "createGame", "range": {"end": {"character": 10, "line": 127}, "start": {"character": 0, "line": 127}}}
{"example_id": "1046", "variation": "positive_semantic", "code": "createGame conn mName initialState = do\n  uuid <- UUID4.nextRandom\n  let gameId = GameId (UUID.toText uuid)\n  now <- iso8601Now\n  let stateJson = encode initialState\n\n  execute conn\n    \"INSERT INTO games (id, name, world_state, created_at, updated_at) \\\n    \\VALUES (?, ?, ?, ?, ?)\"\n    (gameId, mName, stateJson, now, now)\n\n  return gameId\n\n-- | Load a game by ID\n", "criteria": "CRITERIA_1046", "selected": "SELECTED_1046", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "createGame", "range": {"end": {"character": 10, "line": 127}, "start": {"character": 0, "line": 127}}}
{"example_id": "1047", "variation": "negative_1", "code": "createGame conn mName initialState = do\n  uuid <- UUID4.nextRandom\n  let gameId = GameId (UUID.toText uuid)\n  now <- iso8601Now\n  let stateJson = encode initialState\n\n  execute conn\n    \"INSERT INTO games (id, name, world_state, created_at, updated_at) \\\n    \\VALUES (?, ?, ?, ?, ?)\"\n    (gameId, mName, stateJson, now, now)\n\n  return gameId\n\n-- | Load a game by ID\n", "criteria": "CRITERIA_1047", "selected": "SELECTED_1047", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "createGame", "range": {"end": {"character": 10, "line": 127}, "start": {"character": 0, "line": 127}}}
{"example_id": "1048", "variation": "negative_2", "code": "createGame conn mName initialState = do\n  uuid <- UUID4.nextRandom\n  let gameId = GameId (UUID.toText uuid)\n  now <- iso8601Now\n  let stateJson = encode initialState\n\n  execute conn\n    \"INSERT INTO games (id, name, world_state, created_at, updated_at) \\\n    \\VALUES (?, ?, ?, ?, ?)\"\n    (gameId, mName, stateJson, now, now)\n\n  return gameId\n\n-- | Load a game by ID\n", "criteria": "CRITERIA_1048", "selected": "SELECTED_1048", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/platform/src/Tidepool/Storage.hs", "name": "createGame", "range": {"end": {"character": 10, "line": 127}, "start": {"character": 0, "line": 127}}}
{"example_id": "1049", "variation": "positive_structure", "code": "processSymbol session symName countRef visitedFilesRef targetCount = do\n  count <- readIORef countRef\n  if count >= targetCount\n    then pure []\n    else do\n      symbols <- runM $ runLSP session $ workspaceSymbol symName\n      candidatesLists <- forM symbols $ \\symInfo -> do\n        c <- readIORef countRef\n        if c >= targetCount\n          then pure []\n          else do\n            let SymbolInformation name _ loc _ = symInfo\n                Location uri rng = loc\n                file = case T.stripPrefix \"file://\" uri of\n                  Just f -> f\n                  Nothing -> uri\n                Range startPosRec _ = rng\n                Position line char = startPosRec\n                startPos = position line char\n\n            -- Mark file as visited\n            modifyIORef' visitedFilesRef (Set.insert file)\n\n            -- Get hover info\n            maybeHover <- runM $ runLSP session $ hover (textDocument file) startPos\n            let rawSig = case maybeHover of\n                  Just hoverInfo ->\n                    let HoverInfo contents _ = hoverInfo\n                    in contents\n                  Nothing -> name\n\n", "criteria": "CRITERIA_1049", "selected": "SELECTED_1049", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "processSymbol", "range": {"end": {"character": 13, "line": 641}, "start": {"character": 0, "line": 641}}}
{"example_id": "1050", "variation": "positive_semantic", "code": "processSymbol session symName countRef visitedFilesRef targetCount = do\n  count <- readIORef countRef\n  if count >= targetCount\n    then pure []\n    else do\n      symbols <- runM $ runLSP session $ workspaceSymbol symName\n      candidatesLists <- forM symbols $ \\symInfo -> do\n        c <- readIORef countRef\n        if c >= targetCount\n          then pure []\n          else do\n            let SymbolInformation name _ loc _ = symInfo\n                Location uri rng = loc\n                file = case T.stripPrefix \"file://\" uri of\n                  Just f -> f\n                  Nothing -> uri\n                Range startPosRec _ = rng\n                Position line char = startPosRec\n                startPos = position line char\n\n            -- Mark file as visited\n            modifyIORef' visitedFilesRef (Set.insert file)\n\n            -- Get hover info\n            maybeHover <- runM $ runLSP session $ hover (textDocument file) startPos\n            let rawSig = case maybeHover of\n                  Just hoverInfo ->\n                    let HoverInfo contents _ = hoverInfo\n                    in contents\n                  Nothing -> name\n\n", "criteria": "CRITERIA_1050", "selected": "SELECTED_1050", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "processSymbol", "range": {"end": {"character": 13, "line": 641}, "start": {"character": 0, "line": 641}}}
{"example_id": "1051", "variation": "negative_1", "code": "processSymbol session symName countRef visitedFilesRef targetCount = do\n  count <- readIORef countRef\n  if count >= targetCount\n    then pure []\n    else do\n      symbols <- runM $ runLSP session $ workspaceSymbol symName\n      candidatesLists <- forM symbols $ \\symInfo -> do\n        c <- readIORef countRef\n        if c >= targetCount\n          then pure []\n          else do\n            let SymbolInformation name _ loc _ = symInfo\n                Location uri rng = loc\n                file = case T.stripPrefix \"file://\" uri of\n                  Just f -> f\n                  Nothing -> uri\n                Range startPosRec _ = rng\n                Position line char = startPosRec\n                startPos = position line char\n\n            -- Mark file as visited\n            modifyIORef' visitedFilesRef (Set.insert file)\n\n            -- Get hover info\n            maybeHover <- runM $ runLSP session $ hover (textDocument file) startPos\n            let rawSig = case maybeHover of\n                  Just hoverInfo ->\n                    let HoverInfo contents _ = hoverInfo\n                    in contents\n                  Nothing -> name\n\n", "criteria": "CRITERIA_1051", "selected": "SELECTED_1051", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "processSymbol", "range": {"end": {"character": 13, "line": 641}, "start": {"character": 0, "line": 641}}}
{"example_id": "1052", "variation": "negative_2", "code": "processSymbol session symName countRef visitedFilesRef targetCount = do\n  count <- readIORef countRef\n  if count >= targetCount\n    then pure []\n    else do\n      symbols <- runM $ runLSP session $ workspaceSymbol symName\n      candidatesLists <- forM symbols $ \\symInfo -> do\n        c <- readIORef countRef\n        if c >= targetCount\n          then pure []\n          else do\n            let SymbolInformation name _ loc _ = symInfo\n                Location uri rng = loc\n                file = case T.stripPrefix \"file://\" uri of\n                  Just f -> f\n                  Nothing -> uri\n                Range startPosRec _ = rng\n                Position line char = startPosRec\n                startPos = position line char\n\n            -- Mark file as visited\n            modifyIORef' visitedFilesRef (Set.insert file)\n\n            -- Get hover info\n            maybeHover <- runM $ runLSP session $ hover (textDocument file) startPos\n            let rawSig = case maybeHover of\n                  Just hoverInfo ->\n                    let HoverInfo contents _ = hoverInfo\n                    in contents\n                  Nothing -> name\n\n", "criteria": "CRITERIA_1052", "selected": "SELECTED_1052", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/control-server/src/Tidepool/Control/Export.hs", "name": "processSymbol", "range": {"end": {"character": 13, "line": 641}, "start": {"character": 0, "line": 641}}}
{"example_id": "1053", "variation": "positive_structure", "code": "evalMemory initial = fmap fst . runMemory initial\n\n-- | Run memory effect with pure initial value, discarding final state.\n--\n-- Alias for 'evalMemory' for symmetry with State naming conventions.\n", "criteria": "CRITERIA_1053", "selected": "SELECTED_1053", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "evalMemory", "range": {"end": {"character": 10, "line": 212}, "start": {"character": 0, "line": 212}}}
{"example_id": "1054", "variation": "positive_semantic", "code": "evalMemory initial = fmap fst . runMemory initial\n\n-- | Run memory effect with pure initial value, discarding final state.\n--\n-- Alias for 'evalMemory' for symmetry with State naming conventions.\n", "criteria": "CRITERIA_1054", "selected": "SELECTED_1054", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "evalMemory", "range": {"end": {"character": 10, "line": 212}, "start": {"character": 0, "line": 212}}}
{"example_id": "1055", "variation": "negative_1", "code": "evalMemory initial = fmap fst . runMemory initial\n\n-- | Run memory effect with pure initial value, discarding final state.\n--\n-- Alias for 'evalMemory' for symmetry with State naming conventions.\n", "criteria": "CRITERIA_1055", "selected": "SELECTED_1055", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "evalMemory", "range": {"end": {"character": 10, "line": 212}, "start": {"character": 0, "line": 212}}}
{"example_id": "1056", "variation": "negative_2", "code": "evalMemory initial = fmap fst . runMemory initial\n\n-- | Run memory effect with pure initial value, discarding final state.\n--\n-- Alias for 'evalMemory' for symmetry with State naming conventions.\n", "criteria": "CRITERIA_1056", "selected": "SELECTED_1056", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "evalMemory", "range": {"end": {"character": 10, "line": 212}, "start": {"character": 0, "line": 212}}}
{"example_id": "1057", "variation": "positive_structure", "code": "evalMemoryScoped scopeName defaultVal store =\n  fmap fst . runMemoryScoped scopeName defaultVal store\n", "criteria": "CRITERIA_1057", "selected": "SELECTED_1057", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "evalMemoryScoped", "range": {"end": {"character": 16, "line": 465}, "start": {"character": 0, "line": 465}}}
{"example_id": "1058", "variation": "positive_semantic", "code": "evalMemoryScoped scopeName defaultVal store =\n  fmap fst . runMemoryScoped scopeName defaultVal store\n", "criteria": "CRITERIA_1058", "selected": "SELECTED_1058", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "evalMemoryScoped", "range": {"end": {"character": 16, "line": 465}, "start": {"character": 0, "line": 465}}}
{"example_id": "1059", "variation": "negative_1", "code": "evalMemoryScoped scopeName defaultVal store =\n  fmap fst . runMemoryScoped scopeName defaultVal store\n", "criteria": "CRITERIA_1059", "selected": "SELECTED_1059", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "evalMemoryScoped", "range": {"end": {"character": 16, "line": 465}, "start": {"character": 0, "line": 465}}}
{"example_id": "1060", "variation": "negative_2", "code": "evalMemoryScoped scopeName defaultVal store =\n  fmap fst . runMemoryScoped scopeName defaultVal store\n", "criteria": "CRITERIA_1060", "selected": "SELECTED_1060", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Memory.hs", "name": "evalMemoryScoped", "range": {"end": {"character": 16, "line": 465}, "start": {"character": 0, "line": 465}}}
{"example_id": "1061", "variation": "positive_structure", "code": "evaluate = send . Evaluate\n\n-- | Check if code compiles without executing it.\n--\n-- @\n-- checkCompiles \"let x :: Int; x = \\\"hello\\\" in x\"\n-- -- Right False\n-- @\n", "criteria": "CRITERIA_1061", "selected": "SELECTED_1061", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GHCi.hs", "name": "evaluate", "range": {"end": {"character": 8, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "1062", "variation": "positive_semantic", "code": "evaluate = send . Evaluate\n\n-- | Check if code compiles without executing it.\n--\n-- @\n-- checkCompiles \"let x :: Int; x = \\\"hello\\\" in x\"\n-- -- Right False\n-- @\n", "criteria": "CRITERIA_1062", "selected": "SELECTED_1062", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GHCi.hs", "name": "evaluate", "range": {"end": {"character": 8, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "1063", "variation": "negative_1", "code": "evaluate = send . Evaluate\n\n-- | Check if code compiles without executing it.\n--\n-- @\n-- checkCompiles \"let x :: Int; x = \\\"hello\\\" in x\"\n-- -- Right False\n-- @\n", "criteria": "CRITERIA_1063", "selected": "SELECTED_1063", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GHCi.hs", "name": "evaluate", "range": {"end": {"character": 8, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "1064", "variation": "negative_2", "code": "evaluate = send . Evaluate\n\n-- | Check if code compiles without executing it.\n--\n-- @\n-- checkCompiles \"let x :: Int; x = \\\"hello\\\" in x\"\n-- -- Right False\n-- @\n", "criteria": "CRITERIA_1064", "selected": "SELECTED_1064", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Effect/GHCi.hs", "name": "evaluate", "range": {"end": {"character": 8, "line": 269}, "start": {"character": 0, "line": 269}}}
{"example_id": "1065", "variation": "positive_structure", "code": "executeClaudeCodeHandler mSystemTpl userTpl beforeFn afterFn input = do\n  let model = singModelChoice @model\n\n  -- Build context and get session operation from before-handler\n  (ctx, sessionOp) <- beforeFn input\n\n  -- Render templates\n  let systemPrompt :: Text\n      systemPrompt = maybe \"\" (runTypedTemplate ctx) mSystemTpl\n      userPrompt :: Text\n      userPrompt = runTypedTemplate ctx userTpl\n      -- Combine system and user prompts for Claude Code\n      -- (Claude Code doesn't have separate system prompt, so prepend it)\n      fullPrompt :: Text\n      fullPrompt = if systemPrompt == \"\"\n                   then userPrompt\n                   else systemPrompt <> \"\\n\\n\" <> userPrompt\n\n  -- Get decision tools if schema is a sum type with data\n  let mDecisionTools :: Maybe [DecisionTool]\n      mDecisionTools = ccDecisionTools @schema\n\n      -- Convert to JSON Value for session API\n      mToolsJson :: Maybe Value\n      mToolsJson = toJSON <$> mDecisionTools\n\n      -- Schema is only used when NOT using decision tools\n      -- (Sum types use tools instead of structured output schema)\n      schemaVal :: Maybe Value\n      schemaVal = case mDecisionTools of\n        Just _ -> Nothing  -- Don't pass schema when using decision tools\n", "criteria": "CRITERIA_1065", "selected": "SELECTED_1065", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeClaudeCodeHandler", "range": {"end": {"character": 24, "line": 353}, "start": {"character": 0, "line": 353}}}
{"example_id": "1066", "variation": "positive_semantic", "code": "executeClaudeCodeHandler mSystemTpl userTpl beforeFn afterFn input = do\n  let model = singModelChoice @model\n\n  -- Build context and get session operation from before-handler\n  (ctx, sessionOp) <- beforeFn input\n\n  -- Render templates\n  let systemPrompt :: Text\n      systemPrompt = maybe \"\" (runTypedTemplate ctx) mSystemTpl\n      userPrompt :: Text\n      userPrompt = runTypedTemplate ctx userTpl\n      -- Combine system and user prompts for Claude Code\n      -- (Claude Code doesn't have separate system prompt, so prepend it)\n      fullPrompt :: Text\n      fullPrompt = if systemPrompt == \"\"\n                   then userPrompt\n                   else systemPrompt <> \"\\n\\n\" <> userPrompt\n\n  -- Get decision tools if schema is a sum type with data\n  let mDecisionTools :: Maybe [DecisionTool]\n      mDecisionTools = ccDecisionTools @schema\n\n      -- Convert to JSON Value for session API\n      mToolsJson :: Maybe Value\n      mToolsJson = toJSON <$> mDecisionTools\n\n      -- Schema is only used when NOT using decision tools\n      -- (Sum types use tools instead of structured output schema)\n      schemaVal :: Maybe Value\n      schemaVal = case mDecisionTools of\n        Just _ -> Nothing  -- Don't pass schema when using decision tools\n", "criteria": "CRITERIA_1066", "selected": "SELECTED_1066", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeClaudeCodeHandler", "range": {"end": {"character": 24, "line": 353}, "start": {"character": 0, "line": 353}}}
{"example_id": "1067", "variation": "negative_1", "code": "executeClaudeCodeHandler mSystemTpl userTpl beforeFn afterFn input = do\n  let model = singModelChoice @model\n\n  -- Build context and get session operation from before-handler\n  (ctx, sessionOp) <- beforeFn input\n\n  -- Render templates\n  let systemPrompt :: Text\n      systemPrompt = maybe \"\" (runTypedTemplate ctx) mSystemTpl\n      userPrompt :: Text\n      userPrompt = runTypedTemplate ctx userTpl\n      -- Combine system and user prompts for Claude Code\n      -- (Claude Code doesn't have separate system prompt, so prepend it)\n      fullPrompt :: Text\n      fullPrompt = if systemPrompt == \"\"\n                   then userPrompt\n                   else systemPrompt <> \"\\n\\n\" <> userPrompt\n\n  -- Get decision tools if schema is a sum type with data\n  let mDecisionTools :: Maybe [DecisionTool]\n      mDecisionTools = ccDecisionTools @schema\n\n      -- Convert to JSON Value for session API\n      mToolsJson :: Maybe Value\n      mToolsJson = toJSON <$> mDecisionTools\n\n      -- Schema is only used when NOT using decision tools\n      -- (Sum types use tools instead of structured output schema)\n      schemaVal :: Maybe Value\n      schemaVal = case mDecisionTools of\n        Just _ -> Nothing  -- Don't pass schema when using decision tools\n", "criteria": "CRITERIA_1067", "selected": "SELECTED_1067", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeClaudeCodeHandler", "range": {"end": {"character": 24, "line": 353}, "start": {"character": 0, "line": 353}}}
{"example_id": "1068", "variation": "negative_2", "code": "executeClaudeCodeHandler mSystemTpl userTpl beforeFn afterFn input = do\n  let model = singModelChoice @model\n\n  -- Build context and get session operation from before-handler\n  (ctx, sessionOp) <- beforeFn input\n\n  -- Render templates\n  let systemPrompt :: Text\n      systemPrompt = maybe \"\" (runTypedTemplate ctx) mSystemTpl\n      userPrompt :: Text\n      userPrompt = runTypedTemplate ctx userTpl\n      -- Combine system and user prompts for Claude Code\n      -- (Claude Code doesn't have separate system prompt, so prepend it)\n      fullPrompt :: Text\n      fullPrompt = if systemPrompt == \"\"\n                   then userPrompt\n                   else systemPrompt <> \"\\n\\n\" <> userPrompt\n\n  -- Get decision tools if schema is a sum type with data\n  let mDecisionTools :: Maybe [DecisionTool]\n      mDecisionTools = ccDecisionTools @schema\n\n      -- Convert to JSON Value for session API\n      mToolsJson :: Maybe Value\n      mToolsJson = toJSON <$> mDecisionTools\n\n      -- Schema is only used when NOT using decision tools\n      -- (Sum types use tools instead of structured output schema)\n      schemaVal :: Maybe Value\n      schemaVal = case mDecisionTools of\n        Just _ -> Nothing  -- Don't pass schema when using decision tools\n", "criteria": "CRITERIA_1068", "selected": "SELECTED_1068", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeClaudeCodeHandler", "range": {"end": {"character": 24, "line": 353}, "start": {"character": 0, "line": 353}}}
{"example_id": "1069", "variation": "positive_structure", "code": "executeLLMHandler mSystemTpl userTpl beforeFn afterFn input = do\n  -- Build context from before-handler\n  ctx <- beforeFn input\n  -- Render templates\n  let systemPrompt = maybe \"\" (runTypedTemplate ctx) mSystemTpl\n      userPrompt = runTypedTemplate ctx userTpl\n      schemaVal = schemaToValue (structuredSchema @schema)\n  -- Call LLM with rendered prompts and handle tool-initiated transitions\n  turnResult <- runTurn @schema systemPrompt userPrompt schemaVal []\n  case turnResult of\n    TurnBroken reason -> error $ \"LLM turn broken: \" <> T.unpack reason\n    TurnTransitionHint targetName payload ->\n      case convertTransitionHint @targets targetName payload of\n        Just choice -> pure choice\n        Nothing -> error $ \"Tool transition to unknown target or wrong type: \" <> T.unpack targetName\n    TurnCompleted (TurnParsed (TurnResult {trOutput})) -> afterFn trOutput\n    TurnCompleted (TurnParseFailed {tpfError}) -> error $ \"Parse failed: \" <> tpfError\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CLAUDE CODE HANDLER EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Execute a ClaudeCodeLLMHandler, returning a GotoChoice.\n--\n-- Similar to 'executeLLMHandler', but uses the Session effect to spawn\n-- a dockerized Claude Code session via mantle.\n--\n-- This function:\n-- 1. Calls the before-handler to build template context AND session strategy\n-- 2. Renders the user template (system template appended to prompt)\n", "criteria": "CRITERIA_1069", "selected": "SELECTED_1069", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeLLMHandler", "range": {"end": {"character": 17, "line": 272}, "start": {"character": 0, "line": 272}}}
{"example_id": "1070", "variation": "positive_semantic", "code": "executeLLMHandler mSystemTpl userTpl beforeFn afterFn input = do\n  -- Build context from before-handler\n  ctx <- beforeFn input\n  -- Render templates\n  let systemPrompt = maybe \"\" (runTypedTemplate ctx) mSystemTpl\n      userPrompt = runTypedTemplate ctx userTpl\n      schemaVal = schemaToValue (structuredSchema @schema)\n  -- Call LLM with rendered prompts and handle tool-initiated transitions\n  turnResult <- runTurn @schema systemPrompt userPrompt schemaVal []\n  case turnResult of\n    TurnBroken reason -> error $ \"LLM turn broken: \" <> T.unpack reason\n    TurnTransitionHint targetName payload ->\n      case convertTransitionHint @targets targetName payload of\n        Just choice -> pure choice\n        Nothing -> error $ \"Tool transition to unknown target or wrong type: \" <> T.unpack targetName\n    TurnCompleted (TurnParsed (TurnResult {trOutput})) -> afterFn trOutput\n    TurnCompleted (TurnParseFailed {tpfError}) -> error $ \"Parse failed: \" <> tpfError\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CLAUDE CODE HANDLER EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Execute a ClaudeCodeLLMHandler, returning a GotoChoice.\n--\n-- Similar to 'executeLLMHandler', but uses the Session effect to spawn\n-- a dockerized Claude Code session via mantle.\n--\n-- This function:\n-- 1. Calls the before-handler to build template context AND session strategy\n-- 2. Renders the user template (system template appended to prompt)\n", "criteria": "CRITERIA_1070", "selected": "SELECTED_1070", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeLLMHandler", "range": {"end": {"character": 17, "line": 272}, "start": {"character": 0, "line": 272}}}
{"example_id": "1071", "variation": "negative_1", "code": "executeLLMHandler mSystemTpl userTpl beforeFn afterFn input = do\n  -- Build context from before-handler\n  ctx <- beforeFn input\n  -- Render templates\n  let systemPrompt = maybe \"\" (runTypedTemplate ctx) mSystemTpl\n      userPrompt = runTypedTemplate ctx userTpl\n      schemaVal = schemaToValue (structuredSchema @schema)\n  -- Call LLM with rendered prompts and handle tool-initiated transitions\n  turnResult <- runTurn @schema systemPrompt userPrompt schemaVal []\n  case turnResult of\n    TurnBroken reason -> error $ \"LLM turn broken: \" <> T.unpack reason\n    TurnTransitionHint targetName payload ->\n      case convertTransitionHint @targets targetName payload of\n        Just choice -> pure choice\n        Nothing -> error $ \"Tool transition to unknown target or wrong type: \" <> T.unpack targetName\n    TurnCompleted (TurnParsed (TurnResult {trOutput})) -> afterFn trOutput\n    TurnCompleted (TurnParseFailed {tpfError}) -> error $ \"Parse failed: \" <> tpfError\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CLAUDE CODE HANDLER EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Execute a ClaudeCodeLLMHandler, returning a GotoChoice.\n--\n-- Similar to 'executeLLMHandler', but uses the Session effect to spawn\n-- a dockerized Claude Code session via mantle.\n--\n-- This function:\n-- 1. Calls the before-handler to build template context AND session strategy\n-- 2. Renders the user template (system template appended to prompt)\n", "criteria": "CRITERIA_1071", "selected": "SELECTED_1071", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeLLMHandler", "range": {"end": {"character": 17, "line": 272}, "start": {"character": 0, "line": 272}}}
{"example_id": "1072", "variation": "negative_2", "code": "executeLLMHandler mSystemTpl userTpl beforeFn afterFn input = do\n  -- Build context from before-handler\n  ctx <- beforeFn input\n  -- Render templates\n  let systemPrompt = maybe \"\" (runTypedTemplate ctx) mSystemTpl\n      userPrompt = runTypedTemplate ctx userTpl\n      schemaVal = schemaToValue (structuredSchema @schema)\n  -- Call LLM with rendered prompts and handle tool-initiated transitions\n  turnResult <- runTurn @schema systemPrompt userPrompt schemaVal []\n  case turnResult of\n    TurnBroken reason -> error $ \"LLM turn broken: \" <> T.unpack reason\n    TurnTransitionHint targetName payload ->\n      case convertTransitionHint @targets targetName payload of\n        Just choice -> pure choice\n        Nothing -> error $ \"Tool transition to unknown target or wrong type: \" <> T.unpack targetName\n    TurnCompleted (TurnParsed (TurnResult {trOutput})) -> afterFn trOutput\n    TurnCompleted (TurnParseFailed {tpfError}) -> error $ \"Parse failed: \" <> tpfError\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- CLAUDE CODE HANDLER EXECUTION\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Execute a ClaudeCodeLLMHandler, returning a GotoChoice.\n--\n-- Similar to 'executeLLMHandler', but uses the Session effect to spawn\n-- a dockerized Claude Code session via mantle.\n--\n-- This function:\n-- 1. Calls the before-handler to build template context AND session strategy\n-- 2. Renders the user template (system template appended to prompt)\n", "criteria": "CRITERIA_1072", "selected": "SELECTED_1072", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeLLMHandler", "range": {"end": {"character": 17, "line": 272}, "start": {"character": 0, "line": 272}}}
{"example_id": "1073", "variation": "positive_structure", "code": "executeGraphNode = runGraph\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- DISPATCH TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Dispatch on a 'GotoChoice', recursively executing handlers until Exit.\n--\n-- This typeclass enables fully typed dispatch through a graph. Each instance\n-- handles one case of the target list, recursively calling handlers until\n-- an Exit target is reached.\n--\n-- = Type Parameters\n--\n-- * @graph@ - The graph record type (e.g., @TestGraph@)\n-- * @targets@ - The current target list to dispatch on\n-- * @es@ - The effect stack available to handlers\n-- * @exitType@ - The graph's exit type (what 'runGraph' returns)\n--\n-- = How It Works\n--\n-- Given @GotoChoice '[To \\\"a\\\" A, To \\\"b\\\" B, To Exit R]@:\n--\n-- 1. Pattern match on @OneOf '[A, B, R]@\n-- 2. If @Here payload@: call handler \\\"a\\\" with payload :: A\n-- 3. If @There (Here payload)@: call handler \\\"b\\\" with payload :: B\n-- 4. If @There (There (Here result))@: return result :: R\n--\n-- Each handler returns its own @GotoChoice@, so dispatch recurses through\n-- the graph until Exit is reached.\n", "criteria": "CRITERIA_1073", "selected": "SELECTED_1073", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeGraphNode", "range": {"end": {"character": 16, "line": 585}, "start": {"character": 0, "line": 585}}}
{"example_id": "1074", "variation": "positive_semantic", "code": "executeGraphNode = runGraph\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- DISPATCH TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Dispatch on a 'GotoChoice', recursively executing handlers until Exit.\n--\n-- This typeclass enables fully typed dispatch through a graph. Each instance\n-- handles one case of the target list, recursively calling handlers until\n-- an Exit target is reached.\n--\n-- = Type Parameters\n--\n-- * @graph@ - The graph record type (e.g., @TestGraph@)\n-- * @targets@ - The current target list to dispatch on\n-- * @es@ - The effect stack available to handlers\n-- * @exitType@ - The graph's exit type (what 'runGraph' returns)\n--\n-- = How It Works\n--\n-- Given @GotoChoice '[To \\\"a\\\" A, To \\\"b\\\" B, To Exit R]@:\n--\n-- 1. Pattern match on @OneOf '[A, B, R]@\n-- 2. If @Here payload@: call handler \\\"a\\\" with payload :: A\n-- 3. If @There (Here payload)@: call handler \\\"b\\\" with payload :: B\n-- 4. If @There (There (Here result))@: return result :: R\n--\n-- Each handler returns its own @GotoChoice@, so dispatch recurses through\n-- the graph until Exit is reached.\n", "criteria": "CRITERIA_1074", "selected": "SELECTED_1074", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeGraphNode", "range": {"end": {"character": 16, "line": 585}, "start": {"character": 0, "line": 585}}}
{"example_id": "1075", "variation": "negative_1", "code": "executeGraphNode = runGraph\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- DISPATCH TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Dispatch on a 'GotoChoice', recursively executing handlers until Exit.\n--\n-- This typeclass enables fully typed dispatch through a graph. Each instance\n-- handles one case of the target list, recursively calling handlers until\n-- an Exit target is reached.\n--\n-- = Type Parameters\n--\n-- * @graph@ - The graph record type (e.g., @TestGraph@)\n-- * @targets@ - The current target list to dispatch on\n-- * @es@ - The effect stack available to handlers\n-- * @exitType@ - The graph's exit type (what 'runGraph' returns)\n--\n-- = How It Works\n--\n-- Given @GotoChoice '[To \\\"a\\\" A, To \\\"b\\\" B, To Exit R]@:\n--\n-- 1. Pattern match on @OneOf '[A, B, R]@\n-- 2. If @Here payload@: call handler \\\"a\\\" with payload :: A\n-- 3. If @There (Here payload)@: call handler \\\"b\\\" with payload :: B\n-- 4. If @There (There (Here result))@: return result :: R\n--\n-- Each handler returns its own @GotoChoice@, so dispatch recurses through\n-- the graph until Exit is reached.\n", "criteria": "CRITERIA_1075", "selected": "SELECTED_1075", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeGraphNode", "range": {"end": {"character": 16, "line": 585}, "start": {"character": 0, "line": 585}}}
{"example_id": "1076", "variation": "negative_2", "code": "executeGraphNode = runGraph\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- DISPATCH TYPECLASS\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Dispatch on a 'GotoChoice', recursively executing handlers until Exit.\n--\n-- This typeclass enables fully typed dispatch through a graph. Each instance\n-- handles one case of the target list, recursively calling handlers until\n-- an Exit target is reached.\n--\n-- = Type Parameters\n--\n-- * @graph@ - The graph record type (e.g., @TestGraph@)\n-- * @targets@ - The current target list to dispatch on\n-- * @es@ - The effect stack available to handlers\n-- * @exitType@ - The graph's exit type (what 'runGraph' returns)\n--\n-- = How It Works\n--\n-- Given @GotoChoice '[To \\\"a\\\" A, To \\\"b\\\" B, To Exit R]@:\n--\n-- 1. Pattern match on @OneOf '[A, B, R]@\n-- 2. If @Here payload@: call handler \\\"a\\\" with payload :: A\n-- 3. If @There (Here payload)@: call handler \\\"b\\\" with payload :: B\n-- 4. If @There (There (Here result))@: return result :: R\n--\n-- Each handler returns its own @GotoChoice@, so dispatch recurses through\n-- the graph until Exit is reached.\n", "criteria": "CRITERIA_1076", "selected": "SELECTED_1076", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/dsl/core/src/Tidepool/Graph/Interpret.hs", "name": "executeGraphNode", "range": {"end": {"character": 16, "line": 585}, "start": {"character": 0, "line": 585}}}
{"example_id": "1077", "variation": "positive_structure", "code": "executeSession session action = do\n  responseMVar <- newEmptyMVar\n  writeChan session.lspRequestChan $ LSPRequest action responseMVar\n\n  -- Wait for response with timeout\n  maybeResult <- timeout defaultRequestTimeout $ takeMVar responseMVar\n\n  case maybeResult of\n    Nothing ->\n      fail \"LSP request timed out. HLS may still be indexing the project.\"\n    Just result ->\n      case result of\n        Right value -> pure value\n        Left err -> throwIO err\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- EFFECT INTERPRETER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run LSP effects using an active session.\n", "criteria": "CRITERIA_1077", "selected": "SELECTED_1077", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "executeSession", "range": {"end": {"character": 14, "line": 158}, "start": {"character": 0, "line": 158}}}
{"example_id": "1078", "variation": "positive_semantic", "code": "executeSession session action = do\n  responseMVar <- newEmptyMVar\n  writeChan session.lspRequestChan $ LSPRequest action responseMVar\n\n  -- Wait for response with timeout\n  maybeResult <- timeout defaultRequestTimeout $ takeMVar responseMVar\n\n  case maybeResult of\n    Nothing ->\n      fail \"LSP request timed out. HLS may still be indexing the project.\"\n    Just result ->\n      case result of\n        Right value -> pure value\n        Left err -> throwIO err\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- EFFECT INTERPRETER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run LSP effects using an active session.\n", "criteria": "CRITERIA_1078", "selected": "SELECTED_1078", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "executeSession", "range": {"end": {"character": 14, "line": 158}, "start": {"character": 0, "line": 158}}}
{"example_id": "1079", "variation": "negative_1", "code": "executeSession session action = do\n  responseMVar <- newEmptyMVar\n  writeChan session.lspRequestChan $ LSPRequest action responseMVar\n\n  -- Wait for response with timeout\n  maybeResult <- timeout defaultRequestTimeout $ takeMVar responseMVar\n\n  case maybeResult of\n    Nothing ->\n      fail \"LSP request timed out. HLS may still be indexing the project.\"\n    Just result ->\n      case result of\n        Right value -> pure value\n        Left err -> throwIO err\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- EFFECT INTERPRETER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run LSP effects using an active session.\n", "criteria": "CRITERIA_1079", "selected": "SELECTED_1079", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "executeSession", "range": {"end": {"character": 14, "line": 158}, "start": {"character": 0, "line": 158}}}
{"example_id": "1080", "variation": "negative_2", "code": "executeSession session action = do\n  responseMVar <- newEmptyMVar\n  writeChan session.lspRequestChan $ LSPRequest action responseMVar\n\n  -- Wait for response with timeout\n  maybeResult <- timeout defaultRequestTimeout $ takeMVar responseMVar\n\n  case maybeResult of\n    Nothing ->\n      fail \"LSP request timed out. HLS may still be indexing the project.\"\n    Just result ->\n      case result of\n        Right value -> pure value\n        Left err -> throwIO err\n\n\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n-- EFFECT INTERPRETER\n-- \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n-- | Run LSP effects using an active session.\n", "criteria": "CRITERIA_1080", "selected": "SELECTED_1080", "file": "/home/inanna/tidepool-heavy-industries/tidepool/haskell/effects/lsp-interpreter/src/Tidepool/LSP/Interpreter.hs", "name": "executeSession", "range": {"end": {"character": 14, "line": 158}, "start": {"character": 0, "line": 158}}}
