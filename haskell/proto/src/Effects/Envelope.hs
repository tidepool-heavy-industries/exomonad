{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE NegativeLiterals #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# OPTIONS_GHC -fno-warn-missing-export-lists #-}
{-# OPTIONS_GHC -fno-warn-name-shadowing #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}
{-# OPTIONS_GHC -fno-warn-unused-matches #-}

-- | Generated by Haskell protocol buffer compiler. DO NOT EDIT!
module Effects.Envelope where

import Control.Applicative ((<$>), (<*>), (<|>))
import Control.Applicative qualified as Hs
import Control.DeepSeq qualified as Hs
import Control.Monad qualified as Hs
import Data.ByteString qualified as Hs
import Data.Coerce qualified as Hs
import Data.Int qualified as Hs (Int16, Int32, Int64)
import Data.List.NonEmpty qualified as Hs (NonEmpty (..))
import Data.Map qualified as Hs (Map, mapKeysMonotonic)
import Data.Proxy qualified as Proxy
import Data.String qualified as Hs (fromString)
import Data.Text.Lazy qualified as Hs (Text)
import Data.Vector qualified as Hs (Vector)
import Data.Word qualified as Hs (Word16, Word32, Word64)
import Effects.EffectError qualified
import GHC.Enum qualified as Hs
import GHC.Generics qualified as Hs
import Google.Protobuf.Wrappers.Polymorphic qualified as HsProtobuf
  ( Wrapped (..),
  )
import Proto3.Suite.Class qualified as HsProtobuf
import Proto3.Suite.DotProto qualified as HsProtobufAST
import Proto3.Suite.JSONPB ((.:), (.=))
import Proto3.Suite.JSONPB qualified as HsJSONPB
import Proto3.Suite.Types qualified as HsProtobuf
import Proto3.Wire qualified as HsProtobuf
import Proto3.Wire.Decode qualified as HsProtobuf
  ( Parser,
    RawField,
  )
import Unsafe.Coerce qualified as Hs
import Prelude qualified as Hs

data EffectEnvelope
  = EffectEnvelope
  { effectEnvelopeEffectType :: Hs.Text,
    effectEnvelopePayload :: Hs.ByteString
  }
  deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic)

instance (Hs.NFData EffectEnvelope)

instance (HsProtobuf.Named EffectEnvelope) where
  nameOf _ = Hs.fromString "EffectEnvelope"

instance (HsProtobuf.HasDefault EffectEnvelope)

instance (HsProtobuf.Message EffectEnvelope) where
  encodeMessage
    _
    EffectEnvelope {effectEnvelopeEffectType, effectEnvelopePayload} =
      Hs.mappend
        ( HsProtobuf.encodeMessageField
            (HsProtobuf.FieldNumber 1)
            ( (Hs.coerce @Hs.Text @(HsProtobuf.String Hs.Text))
                effectEnvelopeEffectType
            )
        )
        ( HsProtobuf.encodeMessageField
            (HsProtobuf.FieldNumber 2)
            ( (Hs.coerce @Hs.ByteString @(HsProtobuf.Bytes Hs.ByteString))
                effectEnvelopePayload
            )
        )
  decodeMessage _ =
    Hs.pure EffectEnvelope
      <*> ( (HsProtobuf.coerceOver @(HsProtobuf.String Hs.Text) @Hs.Text)
              ( HsProtobuf.at
                  HsProtobuf.decodeMessageField
                  (HsProtobuf.FieldNumber 1)
              )
          )
      <*> ( ( HsProtobuf.coerceOver
                @(HsProtobuf.Bytes Hs.ByteString)
                @Hs.ByteString
            )
              ( HsProtobuf.at
                  HsProtobuf.decodeMessageField
                  (HsProtobuf.FieldNumber 2)
              )
          )
  dotProto _ =
    [ HsProtobufAST.DotProtoField
        (HsProtobuf.FieldNumber 1)
        (HsProtobufAST.Prim HsProtobufAST.String)
        (HsProtobufAST.Single "effect_type")
        []
        "",
      HsProtobufAST.DotProtoField
        (HsProtobuf.FieldNumber 2)
        (HsProtobufAST.Prim HsProtobufAST.Bytes)
        (HsProtobufAST.Single "payload")
        []
        ""
    ]

instance (HsJSONPB.ToJSONPB EffectEnvelope) where
  toJSONPB (EffectEnvelope f1 f2) =
    HsJSONPB.object
      [ "effect_type"
          .= ((Hs.coerce @Hs.Text @(HsProtobuf.String Hs.Text)) f1),
        "payload"
          .= ((Hs.coerce @Hs.ByteString @(HsProtobuf.Bytes Hs.ByteString)) f2)
      ]
  toEncodingPB (EffectEnvelope f1 f2) =
    HsJSONPB.pairs
      [ "effect_type"
          .= ((Hs.coerce @Hs.Text @(HsProtobuf.String Hs.Text)) f1),
        "payload"
          .= ((Hs.coerce @Hs.ByteString @(HsProtobuf.Bytes Hs.ByteString)) f2)
      ]

instance (HsJSONPB.FromJSONPB EffectEnvelope) where
  parseJSONPB =
    HsJSONPB.withObject
      "EffectEnvelope"
      ( \obj ->
          Hs.pure EffectEnvelope
            <*> ( (HsProtobuf.coerceOver @(HsProtobuf.String Hs.Text) @Hs.Text)
                    (obj .: "effect_type")
                )
            <*> ( ( HsProtobuf.coerceOver
                      @(HsProtobuf.Bytes Hs.ByteString)
                      @Hs.ByteString
                  )
                    (obj .: "payload")
                )
      )

instance (HsJSONPB.ToJSON EffectEnvelope) where
  toJSON = HsJSONPB.toAesonValue
  toEncoding = HsJSONPB.toAesonEncoding

instance (HsJSONPB.FromJSON EffectEnvelope) where
  parseJSON = HsJSONPB.parseJSONPB

newtype EffectResponse
  = EffectResponse {effectResponseResult :: (Hs.Maybe EffectResponseResult)}
  deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic)

instance (Hs.NFData EffectResponse)

instance (HsProtobuf.Named EffectResponse) where
  nameOf _ = Hs.fromString "EffectResponse"

instance (HsProtobuf.HasDefault EffectResponse)

instance (HsProtobuf.Message EffectResponse) where
  encodeMessage _ EffectResponse {effectResponseResult} =
    ( case effectResponseResult of
        Hs.Nothing -> Hs.mempty
        Hs.Just x ->
          case x of
            EffectResponseResultPayload y ->
              HsProtobuf.encodeMessageField
                (HsProtobuf.FieldNumber 1)
                ( HsProtobuf.ForceEmit
                    ((Hs.coerce @Hs.ByteString @(HsProtobuf.Bytes Hs.ByteString)) y)
                )
            EffectResponseResultError y ->
              HsProtobuf.encodeMessageField
                (HsProtobuf.FieldNumber 2)
                ( ( Hs.coerce
                      @(Hs.Maybe Effects.EffectError.EffectError)
                      @(HsProtobuf.Nested Effects.EffectError.EffectError)
                  )
                    (Hs.Just y)
                )
    )
  decodeMessage _ =
    Hs.pure EffectResponse
      <*> HsProtobuf.oneof
        Hs.Nothing
        [ ( (HsProtobuf.FieldNumber 1),
            Hs.pure (Hs.Just Hs.. EffectResponseResultPayload)
              <*> ( ( HsProtobuf.coerceOver
                        @(HsProtobuf.Bytes Hs.ByteString)
                        @Hs.ByteString
                    )
                      HsProtobuf.decodeMessageField
                  )
          ),
          ( (HsProtobuf.FieldNumber 2),
            Hs.pure (Hs.fmap EffectResponseResultError)
              <*> ( ( HsProtobuf.coerceOver
                        @(HsProtobuf.Nested Effects.EffectError.EffectError)
                        @(Hs.Maybe Effects.EffectError.EffectError)
                    )
                      HsProtobuf.decodeMessageField
                  )
          )
        ]
  dotProto _ = []

instance (HsJSONPB.ToJSONPB EffectResponse) where
  toJSONPB (EffectResponse f1_or_f2) =
    HsJSONPB.object
      [ ( let encodeResult =
                ( case f1_or_f2 of
                    Hs.Just (EffectResponseResultPayload f1) ->
                      HsJSONPB.pair
                        "payload"
                        ((Hs.coerce @Hs.ByteString @(HsProtobuf.Bytes Hs.ByteString)) f1)
                    Hs.Just (EffectResponseResultError f2) -> HsJSONPB.pair "error" f2
                    Hs.Nothing -> Hs.mempty
                )
           in ( \options ->
                  if HsJSONPB.optEmitNamedOneof options
                    then
                      ("result" .= HsJSONPB.objectOrNull [encodeResult] options) options
                    else
                      encodeResult options
              )
        )
      ]
  toEncodingPB (EffectResponse f1_or_f2) =
    HsJSONPB.pairs
      [ ( let encodeResult =
                ( case f1_or_f2 of
                    Hs.Just (EffectResponseResultPayload f1) ->
                      HsJSONPB.pair
                        "payload"
                        ((Hs.coerce @Hs.ByteString @(HsProtobuf.Bytes Hs.ByteString)) f1)
                    Hs.Just (EffectResponseResultError f2) -> HsJSONPB.pair "error" f2
                    Hs.Nothing -> Hs.mempty
                )
           in ( \options ->
                  if HsJSONPB.optEmitNamedOneof options
                    then
                      ("result" .= HsJSONPB.pairsOrNull [encodeResult] options) options
                    else
                      encodeResult options
              )
        )
      ]

instance (HsJSONPB.FromJSONPB EffectResponse) where
  parseJSONPB =
    HsJSONPB.withObject
      "EffectResponse"
      ( \obj ->
          Hs.pure EffectResponse
            <*> ( let parseResult parseObj =
                        Hs.msum
                          [ Hs.Just
                              Hs.. EffectResponseResultPayload
                              Hs.. (Hs.coerce @(HsProtobuf.Bytes Hs.ByteString) @Hs.ByteString)
                              <$> HsJSONPB.parseField parseObj "payload",
                            Hs.Just Hs.. EffectResponseResultError
                              <$> HsJSONPB.parseField parseObj "error",
                            Hs.pure Hs.Nothing
                          ]
                   in (obj .: "result" Hs.>>= HsJSONPB.withObject "result" parseResult)
                        <|> (parseResult obj)
                )
      )

instance (HsJSONPB.ToJSON EffectResponse) where
  toJSON = HsJSONPB.toAesonValue
  toEncoding = HsJSONPB.toAesonEncoding

instance (HsJSONPB.FromJSON EffectResponse) where
  parseJSON = HsJSONPB.parseJSONPB

data EffectResponseResult
  = EffectResponseResultPayload Hs.ByteString
  | EffectResponseResultError Effects.EffectError.EffectError
  deriving (Hs.Show, Hs.Eq, Hs.Ord, Hs.Generic)

instance (Hs.NFData EffectResponseResult)

instance (HsProtobuf.Named EffectResponseResult) where
  nameOf _ = Hs.fromString "EffectResponseResult"
