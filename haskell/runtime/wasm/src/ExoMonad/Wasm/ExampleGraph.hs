{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}
{-# OPTIONS_GHC -Wno-incomplete-patterns #-}

-- Pattern exhaustiveness checker doesn't understand GADT constraints for OneOf

-- | Example graph demonstrating multi-node branching with effects.
--
-- This graph implements a message classifier that:
-- 1. Takes a user message
-- 2. Classifies it into Greeting, Question, or Statement
-- 3. Routes to the appropriate handler
-- 4. Each handler generates a response
--
-- Structure:
--   Entry(UserMessage) -> classify -> handleGreeting -+
--                                  |                  |
--                                  +-> handleQuestion +-> Exit(Response)
--                                  |                  |
--                                  +-> handleStatement+
--
-- This exercises:
-- - Branching via GotoChoice with 3+ targets
-- - Multiple logic nodes with real implementations
-- - Effect yields (Log, LlmComplete) at different points
-- - Newtypes for domain concepts
module ExoMonad.Wasm.ExampleGraph
  ( -- * Domain Types
    UserMessage (..),
    Classification (..),
    Response (..),

    -- * Graph Type
    ExampleGraph (..),

    -- * WASM Handlers
    classifyHandlerWasm,
    greetingHandlerWasm,
    questionHandlerWasm,
    statementHandlerWasm,

    -- * Entry Point
    runExampleGraph,
  )
where

import Data.Aeson (FromJSON (..), ToJSON (..), Value (..))
import Data.Maybe (fromMaybe)
import Data.Text (Text)
import Data.Text qualified as T
import ExoMonad.Graph.Generic (GraphMode (..), type (:-))
import ExoMonad.Graph.Generic qualified as G (EntryNode, ExitNode, LogicNode)
import ExoMonad.Graph.Goto (Goto, GotoChoice, To, gotoChoice, gotoExit)
import ExoMonad.Graph.Goto.Internal (GotoChoice (..), OneOf (..)) -- For dispatch
import ExoMonad.Graph.Types (Exit, Input, Self, UsesEffects, type (:@))
import ExoMonad.Wasm.Effect (WasmM, llmComplete, logInfo)
import ExoMonad.Wasm.Error (formatWasmError)
import ExoMonad.Wasm.GraphInput (GraphInput (..))
import GHC.Generics (Generic)

-- ============================================================================
-- Domain Types (newtypes for type safety)
-- ============================================================================

-- | A message from the user to be classified.
newtype UserMessage = UserMessage {unUserMessage :: Text}
  deriving stock (Show, Eq, Generic)

-- UserMessage is a Text wrapper - parse as text
instance FromJSON UserMessage where
  parseJSON v = UserMessage <$> parseJSON v

-- | Classification result from the classifier.
data Classification
  = -- | A hello/goodbye/greeting message
    Greeting
  | -- | A question (ends with ? or starts with interrogative)
    Question
  | -- | A statement/declarative message
    Statement
  deriving stock (Show, Eq, Generic)

-- | Response generated by a handler.
newtype Response = Response {unResponse :: Text}
  deriving stock (Show, Eq, Generic)

-- | Serialize Response as just the inner text (not wrapped in object).
instance ToJSON Response where
  toJSON (Response t) = toJSON t

-- ============================================================================
-- Graph Definition
-- ============================================================================

-- | Message classifier graph with branching.
--
-- The classify node determines which handler to use:
-- - Greeting -> handleGreeting
-- - Question -> handleQuestion
-- - Statement -> handleStatement
--
-- Each handler returns directly to Exit with a Response.
--
-- Updated to accept GraphInput (text or photo) from TypeScript/Telegram.
-- The classify handler extracts text content and creates UserMessage for downstream handlers.
data ExampleGraph mode = ExampleGraph
  { entry :: mode :- G.EntryNode GraphInput,
    classify ::
      mode
        :- G.LogicNode
        :@ Input GraphInput
        :@ UsesEffects
             '[ Goto "handleGreeting" UserMessage,
                Goto "handleQuestion" UserMessage,
                Goto "handleStatement" UserMessage
              ],
    handleGreeting ::
      mode
        :- G.LogicNode
        :@ Input UserMessage
        :@ UsesEffects '[Goto Exit Response],
    handleQuestion ::
      mode
        :- G.LogicNode
        :@ Input UserMessage
        :@ UsesEffects '[Goto Exit Response, Goto Self UserMessage],
    handleStatement ::
      mode
        :- G.LogicNode
        :@ Input UserMessage
        :@ UsesEffects '[Goto Exit Response],
    exit :: mode :- G.ExitNode Response
  }
  deriving (Generic)

-- ============================================================================
-- Classification Logic
-- ============================================================================

-- | Classify a message based on simple heuristics.
--
-- In a real system this would use an LLM, but for testing we use
-- pattern matching to ensure deterministic behavior.
classifyMessage :: Text -> Classification
classifyMessage msg
  | isGreeting = Greeting
  | isQuestion = Question
  | otherwise = Statement
  where
    lower = T.toLower msg

    isGreeting =
      any (`T.isPrefixOf` lower) ["hello", "hi ", "hi!", "hey", "good morning", "good afternoon", "good evening", "goodbye", "bye", "greetings"]
        || lower == "hi"

    isQuestion =
      "?" `T.isSuffixOf` T.strip msg
        || any (`T.isPrefixOf` lower) ["what", "who", "where", "when", "why", "how", "is ", "are ", "can ", "could ", "would ", "should ", "do ", "does ", "did "]

-- ============================================================================
-- WASM Handlers
-- ============================================================================

-- | Classify handler - determines which handler to route to.
--
-- This handler:
-- 1. Extracts text from GraphInput (text directly, or photo caption)
-- 2. Logs the incoming message
-- 3. Classifies it using heuristics
-- 4. Returns a GotoChoice pointing to the appropriate handler
--
-- Photos are treated as text via their caption. If no caption exists,
-- a default placeholder is used. Vision-based classification would be
-- a future enhancement.
classifyHandlerWasm ::
  GraphInput ->
  WasmM
    ( GotoChoice
        '[ To "handleGreeting" UserMessage,
           To "handleQuestion" UserMessage,
           To "handleStatement" UserMessage
         ]
    )
classifyHandlerWasm input = do
  -- Extract text content from GraphInput
  let (textContent, isPhoto) = case input of
        TextInput txt -> (txt, False)
        PhotoInput mCaption _imgSource ->
          let caption = fromMaybe "(photo without caption)" mCaption
           in (caption, True)

  -- Log what we received
  if isPhoto
    then logInfo $ "Received photo with caption: " <> textContent
    else logInfo $ "Classifying message: " <> textContent

  -- Create UserMessage for downstream handlers
  let msg = UserMessage textContent

  -- Classify and route
  let classification = classifyMessage textContent
  logInfo $ "Classification result: " <> T.pack (show classification)
  pure $ case classification of
    Greeting -> gotoChoice @"handleGreeting" msg
    Question -> gotoChoice @"handleQuestion" msg
    Statement -> gotoChoice @"handleStatement" msg

-- | Greeting handler - responds to greetings.
--
-- This handler:
-- 1. Logs that it's handling a greeting
-- 2. Generates a friendly response
-- 3. Returns Exit with the response
greetingHandlerWasm ::
  UserMessage ->
  WasmM (GotoChoice '[To Exit Response])
greetingHandlerWasm msg = do
  logInfo $ "Handling greeting: " <> msg.unUserMessage
  let response = Response $ "Hello! It's nice to hear from you. You said: \"" <> msg.unUserMessage <> "\""
  pure $ gotoExit response

-- | Question handler - responds to questions.
--
-- This handler demonstrates:
-- 1. More complex logic with multiple yields
-- 2. Use of llmComplete effect to generate an answer
-- 3. Self-loop capability (though not used in normal flow)
questionHandlerWasm ::
  UserMessage ->
  WasmM (GotoChoice '[To Exit Response, To Self UserMessage])
questionHandlerWasm msg = do
  logInfo $ "Handling question: " <> msg.unUserMessage

  -- Use LLM to generate a thoughtful response
  -- In tests, this will yield to TypeScript which can mock the response
  result <-
    llmComplete
      "question_handler"
      "You are a helpful assistant. Answer the user's question concisely."
      msg.unUserMessage
      Nothing -- No schema, free-form response

  -- Extract the response text from the LLM result or handle error
  let responseText = case result of
        Left err -> "Error: " <> formatWasmError err
        Right (String t) -> t
        Right _ -> "I'm thinking about that question: \"" <> msg.unUserMessage <> "\""

  logInfo "Generated answer for question"
  pure $ gotoExit (Response responseText)

-- | Statement handler - responds to statements.
--
-- This handler:
-- 1. Logs the statement
-- 2. Acknowledges it with a simple response
-- 3. Returns Exit
statementHandlerWasm ::
  UserMessage ->
  WasmM (GotoChoice '[To Exit Response])
statementHandlerWasm msg = do
  logInfo $ "Handling statement: " <> msg.unUserMessage
  let response = Response $ "I understand. You mentioned: \"" <> msg.unUserMessage <> "\""
  pure $ gotoExit response

-- ============================================================================
-- Graph Execution Entry Point
-- ============================================================================

-- | The full set of choices for the classify node.
type ClassifyTargets =
  '[ To "handleGreeting" UserMessage,
     To "handleQuestion" UserMessage,
     To "handleStatement" UserMessage
   ]

-- | The full set of choices for question handler (includes Self for retry).
type QuestionTargets =
  '[ To Exit Response,
     To Self UserMessage
   ]

-- | The full set of choices for greeting/statement handlers.
type SimpleExitTargets =
  '[To Exit Response]

-- | Run the example graph from entry to exit.
--
-- This function orchestrates the full graph execution:
-- 1. Classify the input (GraphInput: text or photo)
-- 2. Dispatch to the appropriate handler
-- 3. Return the final response
--
-- Note: The Self-loop in questionHandler is not exercised here since
-- we always exit on first pass. A more complex graph could use Self
-- for retry logic.
runExampleGraph :: GraphInput -> WasmM Response
runExampleGraph input = do
  -- Step 1: Classify
  classifyResult <- classifyHandlerWasm input

  -- Step 2: Dispatch based on classification
  dispatchClassify classifyResult
  where
    dispatchClassify :: GotoChoice ClassifyTargets -> WasmM Response
    dispatchClassify = dispatchFromOneOf

    dispatchFromOneOf :: GotoChoice ClassifyTargets -> WasmM Response
    dispatchFromOneOf (GotoChoice oneOf) = case oneOf of
      -- Here = handleGreeting
      Here payload -> do
        result <- greetingHandlerWasm payload
        dispatchSimpleExit result

      -- There (Here _) = handleQuestion
      There (Here payload) -> do
        result <- questionHandlerWasm payload
        dispatchQuestionResult result

      -- There (There (Here _)) = handleStatement
      There (There (Here payload)) -> do
        result <- statementHandlerWasm payload
        dispatchSimpleExit result

    dispatchSimpleExit :: GotoChoice SimpleExitTargets -> WasmM Response
    dispatchSimpleExit (GotoChoice (Here response)) = pure response

    dispatchQuestionResult :: GotoChoice QuestionTargets -> WasmM Response
    dispatchQuestionResult (GotoChoice oneOf) = case oneOf of
      Here response -> pure response
      There (Here payload) -> do
        -- Self-loop: retry with the same message
        logInfo "Question handler requested retry (Self-loop)"
        result <- questionHandlerWasm payload
        dispatchQuestionResult result
