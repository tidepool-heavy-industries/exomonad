{-# LANGUAGE OverloadedStrings #-}

-- | TypeScript package codegen for ExoMonad graphs.
--
-- This module provides pure functions for generating TypeScript source files
-- from graph specifications. The generated package is a self-contained npm
-- package that can be consumed by deploy/ or any other TypeScript project.
--
-- = Generated Files
--
-- * @graphs.ts@ - GraphId union type and graphRegistry with metadata
-- * @exports.ts@ - GraphWasmExports interface matching WASM FFI
-- * @dispatcher.ts@ - Type-safe getGraphFns() dispatcher
-- * @index.ts@ - Re-exports for clean public API
-- * @package.json@ - npm package manifest
-- * @tsconfig.json@ - TypeScript configuration
--
-- = Usage
--
-- > cabal run generate-ts-package -- ./output
--
-- This generates a complete npm package in ./output that can be:
--
-- 1. Linked locally: @npm link ../exomonad-generated-ts/output@
-- 2. Published to npm: @cd output && npm publish@
-- 3. Used as file dependency: @"exomonad-generated-ts": "file:../output"@
module ExoMonad.Generated.Codegen
  ( -- * Graph Specification
    GraphSpec(..)

    -- * Effect Specification
  , EffectSpec(..)

    -- * TypeScript Generation
  , generateGraphsTs
  , generateExportsTs
  , generateDispatcherTs
  , generateRoutingTs
  , generateHandlersTs
  , generateIndexTs

    -- * Package Configuration
  , generatePackageJson
  , generateTsConfig
  ) where

import Data.Text (Text)
import qualified Data.Text as T


-- ============================================================================
-- Graph Specification
-- ============================================================================

-- | Runtime graph metadata for codegen (mirrors GraphFFISpec without TH Names).
data GraphSpec = GraphSpec
  { gsId    :: Text              -- ^ Short ID (e.g., "test", "example", "habitica")
  , gsName  :: Text              -- ^ Full graph name (e.g., "TestGraph")
  , gsNodes :: [Text]            -- ^ Node names
  , gsEdges :: [(Text, Text)]    -- ^ Edges as (from, to) pairs
  }
  deriving (Show, Eq)


-- ============================================================================
-- Effect Specification
-- ============================================================================

-- | Effect metadata for routing codegen.
--
-- Defines how each effect type should be routed:
-- - Internal effects are handled by StateMachineDO (LLM, Habitica, Log)
-- - Yielded effects are sent back to the caller (Telegram effects)
data EffectSpec = EffectSpec
  { esType      :: Text          -- ^ Effect type name (e.g., "LogInfo", "LlmComplete")
  , esCategory  :: Text          -- ^ "internal" | "yielded"
  , esSemantics :: Text          -- ^ "fire_and_forget" | "blocking"
  }
  deriving (Show, Eq)


-- ============================================================================
-- TypeScript Generation - graphs.ts
-- ============================================================================

-- | Generate graphs.ts with GraphId type and graphRegistry.
--
-- Output:
--
-- > export type GraphId = "test" | "example" | "habitica";
-- >
-- > export interface GraphEdge { from: string; to: string; }
-- >
-- > export interface GraphInfo {
-- >   id: GraphId;
-- >   name: string;
-- >   nodes: string[];
-- >   edges: GraphEdge[];
-- > }
-- >
-- > export const graphRegistry: Record<GraphId, GraphInfo> = { ... };
generateGraphsTs :: [GraphSpec] -> Text
generateGraphsTs specs = T.unlines
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "export type GraphId = " <> graphIdUnion specs <> ";"
  , ""
  , "export interface GraphEdge {"
  , "  from: string;"
  , "  to: string;"
  , "}"
  , ""
  , "export interface GraphInfo {"
  , "  id: GraphId;"
  , "  name: string;"
  , "  nodes: string[];"
  , "  edges: GraphEdge[];"
  , "}"
  , ""
  , "export const graphRegistry: Record<GraphId, GraphInfo> = {"
  , T.intercalate ",\n" (map graphRegistryEntry specs)
  , "};"
  ]

-- | Generate GraphId union type: "test" | "example" | "habitica"
graphIdUnion :: [GraphSpec] -> Text
graphIdUnion specs = T.intercalate " | " $ map (\s -> "\"" <> s.gsId <> "\"") specs

-- | Generate a single graph registry entry.
graphRegistryEntry :: GraphSpec -> Text
graphRegistryEntry spec = T.unlines
  [ "  " <> quote spec.gsId <> ": {"
  , "    id: " <> quote spec.gsId <> ","
  , "    name: " <> quote spec.gsName <> ","
  , "    nodes: [" <> T.intercalate ", " (map quote spec.gsNodes) <> "],"
  , "    edges: [" <> T.intercalate ", " (map edgeObj spec.gsEdges) <> "]"
  , "  }"
  ]
  where
    edgeObj (from, to) = "{ from: " <> quote from <> ", to: " <> quote to <> " }"


-- ============================================================================
-- TypeScript Generation - exports.ts
-- ============================================================================

-- | Generate exports.ts with GraphWasmExports interface.
--
-- Output:
--
-- > export interface GraphWasmExports {
-- >   initialize_test: (json: string) => string;
-- >   step_test: (json: string) => string;
-- >   getGraphInfo_test: () => string;
-- >   getGraphState_test: () => string;
-- >   // ... for each graph
-- > }
generateExportsTs :: [GraphSpec] -> Text
generateExportsTs _specs = T.unlines
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "// Unified WASM FFI interface - 4 exports that take graphId as parameter"
  , "// This replaces the previous 4N exports (4 per graph)"
  , "export interface GraphWasmExports {"
  , "  // Unified FFI (new)"
  , "  initialize: (graphId: string, json: string) => string;"
  , "  step: (graphId: string, json: string) => string;"
  , "  getGraphInfo: (graphId: string) => string;"
  , "  getGraphState: (graphId: string) => string;"
  , "}"
  ]


-- ============================================================================
-- TypeScript Generation - dispatcher.ts
-- ============================================================================

-- | Generate dispatcher.ts with getGraphFns function.
--
-- Output:
--
-- > import type { GraphId } from './graphs.js';
-- > import type { GraphWasmExports } from './exports.js';
-- >
-- > export interface GraphFns {
-- >   initialize: (json: string) => string;
-- >   step: (json: string) => string;
-- >   getGraphInfo: () => string;
-- >   getGraphState: () => string;
-- > }
-- >
-- > export function getGraphFns(graphId: GraphId, exports: GraphWasmExports): GraphFns {
-- >   switch (graphId) { ... }
-- > }
generateDispatcherTs :: [GraphSpec] -> Text
generateDispatcherTs _specs = T.unlines
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "import type { GraphId } from './graphs.js';"
  , "import type { GraphWasmExports } from './exports.js';"
  , ""
  , "export interface GraphFns {"
  , "  initialize: (json: string) => string;"
  , "  step: (json: string) => string;"
  , "  getGraphInfo: () => string;"
  , "  getGraphState: () => string;"
  , "}"
  , ""
  , "/**"
  , " * Get type-safe graph functions for a specific graph."
  , " *"
  , " * Uses unified FFI - graphId is baked in, caller just passes data."
  , " * No more switch statement needed - all graphs use same 4 exports."
  , " */"
  , "export function getGraphFns(graphId: GraphId, exports: GraphWasmExports): GraphFns {"
  , "  return {"
  , "    initialize: (json: string) => exports.initialize(graphId, json),"
  , "    step: (json: string) => exports.step(graphId, json),"
  , "    getGraphInfo: () => exports.getGraphInfo(graphId),"
  , "    getGraphState: () => exports.getGraphState(graphId),"
  , "  };"
  , "}"
  ]


-- ============================================================================
-- TypeScript Generation - routing.ts
-- ============================================================================

-- | Generate routing.ts with effect category/semantics functions.
--
-- Output:
--
-- > import type { SerializableEffect } from './protocol.js';
-- >
-- > export type EffectCategory = 'internal' | 'yielded';
-- > export type EffectSemantics = 'fire_and_forget' | 'blocking';
-- >
-- > export function getEffectCategory(effect: SerializableEffect): EffectCategory { ... }
-- > export function isYieldedEffect(effect: SerializableEffect): boolean { ... }
generateRoutingTs :: [EffectSpec] -> Text
generateRoutingTs specs = T.unlines $
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "import type { SerializableEffect } from './protocol.js';"
  , ""
  , "export type EffectCategory = 'internal' | 'yielded';"
  , "export type EffectSemantics = 'fire_and_forget' | 'blocking';"
  , ""
  , "export function getEffectCategory(effect: SerializableEffect): EffectCategory {"
  , "  switch (effect.type) {"
  ] ++ map categoryCase specs ++
  [ "    default:"
  , "      // Exhaustiveness check: unknown effects default to internal"
  , "      return 'internal';"
  , "  }"
  , "}"
  , ""
  , "export function getEffectSemantics(effect: SerializableEffect): EffectSemantics {"
  , "  switch (effect.type) {"
  ] ++ map semanticsCase specs ++
  [ "    default:"
  , "      // Exhaustiveness check: unknown effects default to blocking"
  , "      return 'blocking';"
  , "  }"
  , "}"
  , ""
  , "export function isYieldedEffect(effect: SerializableEffect): boolean {"
  , "  return getEffectCategory(effect) === 'yielded';"
  , "}"
  , ""
  , "export function isInternalEffect(effect: SerializableEffect): boolean {"
  , "  return getEffectCategory(effect) === 'internal';"
  , "}"
  , ""
  , "export function isBlockingEffect(effect: SerializableEffect): boolean {"
  , "  return getEffectSemantics(effect) === 'blocking';"
  , "}"
  ]


-- ============================================================================
-- TypeScript Generation - handlers.generated.ts
-- ============================================================================

-- | Generate handlers.generated.ts with effect handler interface and dispatcher.
--
-- Output:
--
-- > import type { SerializableEffect, EffectResult } from './protocol.js';
-- >
-- > export type InternalEffectType = "LogInfo" | "LogError" | "LlmComplete" | "Habitica";
-- >
-- > export interface InternalEffectHandlers<TEnv> {
-- >   LogInfo: (effect: Extract<SerializableEffect, { type: "LogInfo" }>, env: TEnv) => Promise<EffectResult>;
-- >   // ... for each internal effect
-- > }
-- >
-- > export function dispatchInternalEffect<TEnv>(
-- >   effect: SerializableEffect,
-- >   handlers: InternalEffectHandlers<TEnv>,
-- >   env: TEnv
-- > ): Promise<EffectResult> { ... }
generateHandlersTs :: [EffectSpec] -> Text
generateHandlersTs specs = T.unlines $
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "import type { SerializableEffect, EffectResult } from './protocol.js';"
  , "import { errorResult } from './protocol.js';"
  , ""
  , "// Internal effect types (handled by StateMachineDO, not yielded to caller)"
  , "export type InternalEffectType = " <> internalUnion <> ";"
  , ""
  , "/**"
  , " * Handler interface for internal effects."
  , " *"
  , " * TEnv is the environment type (e.g., Cloudflare Worker Env)."
  , " * Each handler receives the specific effect type and environment."
  , " */"
  , "export interface InternalEffectHandlers<TEnv> {"
  ] ++ map handlerField internalSpecs ++
  [ "}"
  , ""
  , "/**"
  , " * Dispatch an internal effect to the appropriate handler."
  , " *"
  , " * @param effect - The effect to execute"
  , " * @param handlers - Registry of handler functions"
  , " * @param env - Environment with bindings"
  , " * @returns Promise resolving to success/error result"
  , " */"
  , "export function dispatchInternalEffect<TEnv>("
  , "  effect: SerializableEffect,"
  , "  handlers: InternalEffectHandlers<TEnv>,"
  , "  env: TEnv"
  , "): Promise<EffectResult> {"
  , "  switch (effect.type) {"
  ] ++ map dispatchInternalCase internalSpecs ++
  [ "    default:"
  , "      return Promise.resolve(errorResult("
  , "        `Unknown internal effect type: ${(effect as { type: string }).type}`"
  , "      ));"
  , "  }"
  , "}"
  ]
  where
    internalSpecs = filter (\s -> s.esCategory == "internal") specs
    internalUnion
      | null internalSpecs = "never"
      | otherwise = T.intercalate " | " $ map (quote . (.esType)) internalSpecs

-- | Generate a handler field in the interface.
handlerField :: EffectSpec -> Text
handlerField spec =
  "  " <> spec.esType <> ": (effect: Extract<SerializableEffect, { type: "
    <> quote spec.esType <> " }>, env: TEnv) => Promise<EffectResult>;"

-- | Generate a dispatch case for an internal effect.
dispatchInternalCase :: EffectSpec -> Text
dispatchInternalCase spec = T.unlines
  [ "    case " <> quote spec.esType <> ":"
  , "      return handlers." <> spec.esType <> "("
  , "        effect as Extract<SerializableEffect, { type: " <> quote spec.esType <> " }>,"
  , "        env"
  , "      );"
  ]

categoryCase :: EffectSpec -> Text
categoryCase spec = "    case " <> quote spec.esType <> ": return " <> quote spec.esCategory <> ";"

-- | Generate a semantics switch case.
semanticsCase :: EffectSpec -> Text
semanticsCase spec = "    case " <> quote spec.esType <> ": return " <> quote spec.esSemantics <> ";"


-- ============================================================================
-- TypeScript Generation - index.ts
-- ============================================================================

-- | Generate index.ts that re-exports public API.
generateIndexTs :: Text
generateIndexTs = T.unlines
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "// Graph metadata"
  , "export type { GraphId, GraphInfo, GraphEdge } from './graphs.js';"
  , "export { graphRegistry } from './graphs.js';"
  , ""
  , "// WASM exports interface"
  , "export type { GraphWasmExports } from './exports.js';"
  , ""
  , "// Type-safe dispatcher"
  , "export type { GraphFns } from './dispatcher.js';"
  , "export { getGraphFns } from './dispatcher.js';"
  , ""
  , "// Effect routing"
  , "export type { EffectCategory, EffectSemantics } from './routing.js';"
  , "export { getEffectCategory, getEffectSemantics, isYieldedEffect, isInternalEffect, isBlockingEffect } from './routing.js';"
  , ""
  , "// Effect handler dispatch"
  , "export type { InternalEffectType, InternalEffectHandlers } from './handlers.generated.js';"
  , "export { dispatchInternalEffect } from './handlers.generated.js';"
  , ""
  , "// Protocol types"
  , "export * from './protocol.js';"
  , ""
  , "// GHC WASM JSFFI"
  , "export { createJsFFI } from './jsffi.js';"
  , "export type { WasmExports } from './jsffi.js';"
  , ""
  , "// WASM loader"
  , "export * from './loader.js';"
  ]


-- ============================================================================
-- Package Configuration - package.json
-- ============================================================================

-- | Generate package.json for the npm package.
generatePackageJson :: Text -> Text -> Text
generatePackageJson name version = T.unlines
  [ "{"
  , "  \"name\": " <> quote name <> ","
  , "  \"version\": " <> quote version <> ","
  , "  \"description\": \"Generated TypeScript bindings for ExoMonad WASM graphs\","
  , "  \"type\": \"module\","
  , "  \"main\": \"dist/index.js\","
  , "  \"types\": \"dist/index.d.ts\","
  , "  \"exports\": {"
  , "    \".\": {"
  , "      \"types\": \"./dist/index.d.ts\","
  , "      \"import\": \"./dist/index.js\""
  , "    }"
  , "  },"
  , "  \"files\": ["
  , "    \"dist\","
  , "    \"src\","
  , "    \"wasm\""
  , "  ],"
  , "  \"scripts\": {"
  , "    \"build\": \"tsc\","
  , "    \"typecheck\": \"tsc --noEmit\""
  , "  },"
  , "  \"dependencies\": {"
  , "    \"@anthropic-ai/sdk\": \"^0.39.0\","
  , "    \"@bjorn3/browser_wasi_shim\": \"^0.3.0\""
  , "  },"
  , "  \"devDependencies\": {"
  , "    \"@cloudflare/workers-types\": \"^4.20241230.0\","
  , "    \"typescript\": \"^5.0.0\""
  , "  },"
  , "  \"keywords\": [\"exomonad\", \"wasm\", \"llm\", \"agents\"],"
  , "  \"license\": \"MIT\""
  , "}"
  ]


-- ============================================================================
-- Package Configuration - tsconfig.json
-- ============================================================================

-- | Generate tsconfig.json for TypeScript compilation.
generateTsConfig :: Text
generateTsConfig = T.unlines
  [ "{"
  , "  \"compilerOptions\": {"
  , "    \"target\": \"ES2022\","
  , "    \"module\": \"ESNext\","
  , "    \"lib\": [\"ES2022\"],"
  , "    \"moduleResolution\": \"bundler\","
  , "    \"declaration\": true,"
  , "    \"declarationMap\": true,"
  , "    \"sourceMap\": true,"
  , "    \"outDir\": \"dist\","
  , "    \"rootDir\": \"src\","
  , "    \"strict\": true,"
  , "    \"noImplicitAny\": false,"
  , "    \"esModuleInterop\": true,"
  , "    \"skipLibCheck\": true,"
  , "    \"forceConsistentCasingInFileNames\": true,"
  , "    \"types\": [\"@cloudflare/workers-types\"]"
  , "  },"
  , "  \"include\": [\"src/**/*\"],"
  , "  \"exclude\": [\"node_modules\", \"dist\"]"
  , "}"
  ]


-- ============================================================================
-- Helpers
-- ============================================================================

-- | Quote a text value for JavaScript/JSON.
quote :: Text -> Text
quote t = "\"" <> t <> "\""
