# Task: Circuit Breaker for Stop Hook Retries

## Context

The stop hook workflow can loop infinitely if:
- Build keeps failing (agent fixes same error incorrectly)
- Tests keep failing (agent doesn't understand failure)
- Agent loses context (forgets what iteration it's on)

**Fail-safe requirement:** Prevent infinite loops even if agent loses memory.

## Goal

Implement circuit breaker in control-server that:
1. Tracks stop hook iterations globally and per-stage
2. Limits retries (5 per stage, 15 global max)
3. Detects "already running" race conditions
4. Handles session restarts (reset counters on new session)
5. Detects stale state (agent crashed, state is old)

## Design

### State Storage

**In-memory (control-server):**
```haskell
type SessionId = Text  -- UUID generated on first stop

data CircuitBreakerState = CircuitBreakerState
  { cbSessionId :: SessionId
  , cbGlobalStops :: Int
  , cbStageRetries :: Map Text Int  -- "fix-build-errors" -> 3
  , cbLastStopTime :: UTCTime
  , cbStopHookActive :: Bool  -- Flag to prevent concurrent execution
  }

-- Global state in control-server
circuitBreakerState :: TVar (Map SessionId CircuitBreakerState)
```

**Why in-memory:**
- Each control-server instance is single-agent (no cross-agent state needed)
- Lost on restart → resets counters (acceptable, new session)
- Fast access (no file I/O)

### Session ID Tracking

**Generate on first stop:**
```haskell
getOrCreateSession :: HookInput -> IO SessionId
getOrCreateSession input = do
  case extractSessionId input of
    Just sid -> pure sid
    Nothing -> do
      -- Generate new session ID
      uuid <- nextRandom
      let sessionId = toText uuid
      -- Store in agent's conversation via hook response
      pure sessionId
```

**Session ID flow:**
1. First stop: control-server generates UUID
2. Hook response includes: `"session_id": "abc-123"`
3. mantle-agent stores in `.claude/session-state.json`
4. Future stops: include session_id in HookInput
5. Session restart (Claude restarts): new UUID → counters reset

### Staleness Detection

**Problem:** Agent crashes, state says "stop hook active" but actually not running.

**Solution:** Timestamp + timeout
```haskell
checkStaleState :: CircuitBreakerState -> IO Bool
checkStaleState cbs = do
  now <- getCurrentTime
  let elapsed = diffUTCTime now (cbLastStopTime cbs)
  pure $ elapsed > 300  -- 5 minutes = stale
```

**Logic:**
```haskell
handleStopHook :: HookInput -> IO StopHookResult
handleStopHook input = do
  sessionId <- getOrCreateSession input

  atomically $ modifyTVar circuitBreakerState $ \states ->
    case Map.lookup sessionId states of
      Nothing -> initNewSession sessionId
      Just cbs
        | cbStopHookActive cbs -> do
            isStale <- checkStaleState cbs
            if isStale
              then resetAndRun sessionId
              else rejectConcurrent sessionId
        | otherwise -> runStopHook sessionId cbs
```

### Counter Limits

**Global limit (15 stops):**
```haskell
checkGlobalLimit :: CircuitBreakerState -> Either Text ()
checkGlobalLimit cbs
  | cbGlobalStops cbs >= 15 = Left "Global stop limit reached (15)"
  | otherwise = Right ()
```

**Per-stage limit (5 retries):**
```haskell
checkStageLimit :: Text -> CircuitBreakerState -> Either Text ()
checkStageLimit stage cbs =
  case Map.lookup stage (cbStageRetries cbs) of
    Just count | count >= 5 -> Left $ "Stage limit reached for " <> stage
    _ -> Right ()
```

**Template selection on limit:**
```haskell
routeBuild :: BuildResult -> Eff '[State CircuitBreakerState] (GotoChoice '[...])
routeBuild (BuildErrors ctx) = do
  cbs <- get
  case checkStageLimit "fix-build-errors" cbs of
    Left msg -> do
      -- Skip this stage, escalate
      gotoChoice @"selectTemplate" "max-loops-reached"
    Right () -> do
      -- Continue with fix-build-errors
      incrementStageCounter "fix-build-errors"
      gotoChoice @"selectTemplate" "fix-build-errors"
```

### Concurrent Execution Protection

**Problem:** Multiple stop hooks fire simultaneously (user presses stop rapidly, or timeout + manual stop).

**Solution:** `cbStopHookActive` flag
```haskell
acquireStopHookLock :: SessionId -> IO (Either Text ())
acquireStopHookLock sessionId = atomically $ do
  states <- readTVar circuitBreakerState
  case Map.lookup sessionId states of
    Nothing -> pure $ Left "Session not found"
    Just cbs
      | cbStopHookActive cbs -> pure $ Left "Stop hook already running"
      | otherwise -> do
          writeTVar circuitBreakerState $
            Map.adjust (\s -> s { cbStopHookActive = True }) sessionId states
          pure $ Right ()

releaseStopHookLock :: SessionId -> IO ()
releaseStopHookLock sessionId = atomically $
  modifyTVar circuitBreakerState $
    Map.adjust (\s -> s { cbStopHookActive = False }) sessionId
```

**Usage:**
```haskell
handleStopHook input = do
  sessionId <- getOrCreateSession input

  acquireStopHookLock sessionId >>= \case
    Left err -> pure $ StopHookResult True err
    Right () -> do
      result <- try $ runStopHookGraph input
      releaseStopHookLock sessionId
      either (throwIO) pure result
```

## Implementation

### Location
`haskell/control-server/src/Tidepool/Control/Hook/CircuitBreaker.hs`

### Module Structure

```haskell
module Tidepool.Control.Hook.CircuitBreaker
  ( CircuitBreakerState(..)
  , SessionId
  , initCircuitBreaker
  , withCircuitBreaker
  , checkLimits
  , incrementStage
  ) where

import Data.Map.Strict (Map)
import qualified Data.Map.Strict as Map
import Data.Time.Clock
import Control.Concurrent.STM

-- State type (already defined above)

-- Initialize global state
initCircuitBreaker :: IO (TVar (Map SessionId CircuitBreakerState))
initCircuitBreaker = newTVarIO Map.empty

-- Acquire lock, run action, release lock (with limits check)
withCircuitBreaker
  :: TVar (Map SessionId CircuitBreakerState)
  -> SessionId
  -> IO a
  -> IO (Either Text a)
withCircuitBreaker stateVar sessionId action = do
  -- Check limits
  limits <- atomically $ do
    states <- readTVar stateVar
    case Map.lookup sessionId states of
      Nothing -> pure $ Right ()  -- First run
      Just cbs -> do
        -- Check global limit
        case checkGlobalLimit cbs of
          Left err -> pure $ Left err
          Right () -> pure $ Right ()

  case limits of
    Left err -> pure $ Left err
    Right () -> do
      -- Acquire lock
      acquireStopHookLock stateVar sessionId >>= \case
        Left err -> pure $ Left err
        Right () -> do
          -- Run action
          result <- try action
          releaseStopHookLock stateVar sessionId
          pure $ either (Left . show) Right result

-- Increment stage counter (used by graph handlers)
incrementStage :: Text -> Eff '[State CircuitBreakerState] ()
incrementStage stage = modify $ \cbs -> cbs
  { cbGlobalStops = cbGlobalStops cbs + 1
  , cbStageRetries = Map.insertWith (+) stage 1 (cbStageRetries cbs)
  , cbLastStopTime = getCurrentTime  -- NOTE: needs IO, use unsafe for now
  }
```

### Integration with Stop Hook Handler

**File:** `haskell/control-server/src/Tidepool/Control/Handler/Hook.hs`

```haskell
import Tidepool.Control.Hook.CircuitBreaker

handleHook :: HookInput -> IO HookResponse
handleHook input@(HookInput _ (Stop _)) = do
  sessionId <- getOrCreateSession input

  withCircuitBreaker circuitBreakerState sessionId (stopHookLogic input) >>= \case
    Left err -> pure $ HookResponse
      { hrPermissionDecision = "continue"
      , hrMessage = Just $ "Circuit breaker: " <> err
      , hrContext = object ["session_id" .= sessionId, "error" .= err]
      }

    Right result -> pure $ HookResponse
      { hrPermissionDecision = "continue"
      , hrMessage = Just $ formatStopHookResult result
      , hrContext = object ["session_id" .= sessionId]
      }
```

## Configuration

### Environment Variables
- `CIRCUIT_BREAKER_GLOBAL_MAX`: Max global stops (default: 15)
- `CIRCUIT_BREAKER_STAGE_MAX`: Max per-stage retries (default: 5)
- `CIRCUIT_BREAKER_STALE_TIMEOUT`: Staleness timeout in seconds (default: 300)

### Runtime Config File
Optional `.tidepool/circuit-breaker.json`:
```json
{
  "global_max": 15,
  "stage_max": 5,
  "stale_timeout_secs": 300,
  "reset_on_restart": true
}
```

## Testing

### Unit Tests
```haskell
testGlobalLimit :: IO ()
testGlobalLimit = do
  stateVar <- initCircuitBreaker
  sessionId <- pure "test-session"

  -- Run 15 times (should succeed)
  replicateM_ 15 $ do
    result <- withCircuitBreaker stateVar sessionId (pure ())
    result `shouldBe` Right ()

  -- 16th time should fail
  result <- withCircuitBreaker stateVar sessionId (pure ())
  result `shouldSatisfy` isLeft

testStageLimit :: IO ()
testStageLimit = do
  cbs <- pure $ CircuitBreakerState
    { cbSessionId = "test"
    , cbGlobalStops = 3
    , cbStageRetries = Map.fromList [("fix-build-errors", 5)]
    , cbLastStopTime = getCurrentTime
    , cbStopHookActive = False
    }

  checkStageLimit "fix-build-errors" cbs `shouldBe` Left "Stage limit reached"
```

### Integration Tests
Simulate stop hook loop:
```haskell
testStopHookLoop :: IO ()
testStopHookLoop = do
  -- Simulate agent repeatedly failing to fix build
  results <- replicateM 20 $ handleHook (mockStopHookInput)

  -- First 15 should succeed with templates
  take 15 results `shouldSatisfy` all isSuccess

  -- 16th should return circuit breaker error
  (results !! 15) `shouldSatisfy` hasCircuitBreakerError
```

## Acceptance Criteria

- [ ] `CircuitBreakerState` type defined
- [ ] Global stop counter enforced (15 max)
- [ ] Per-stage counter enforced (5 max per stage)
- [ ] Session ID generation on first stop
- [ ] Staleness detection (5 min timeout)
- [ ] Concurrent execution protection (flag-based locking)
- [ ] Unit tests pass (limit enforcement)
- [ ] Integration test simulates loop, hits circuit breaker
- [ ] Configuration via env vars works
- [ ] Documentation in control-server/CLAUDE.md updated

## Related Work

- `ssh-exec-effect`: Provides Cabal/Git effects used in stop hook
- `ssh-proxy`: Executes commands remotely
- Stop hook graph DSL: Uses circuit breaker state

## Resources

- [STM Tutorial](https://wiki.haskell.org/Software_transactional_memory)
- [Concurrent Haskell](https://wiki.haskell.org/Concurrency)
