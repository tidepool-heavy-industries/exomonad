# Work Stream C: Haskell WASM Guest

**Branch**: `wasm/haskell-guest`
**Duration**: ~3 days
**Dependencies**: Stream A (for generated types)

## Context

Read `wasm-plan/00-overview.md` for the full vision. This stream compiles Haskell to WASM as an Extism plugin with the **reactor model**.

## Goal

Create `wasm-guest` package that:
- Compiles to WASM via `wasm32-wasi-ghc`
- Uses reactor model (not command)
- Exports entry points for MCP and hooks
- Calls host functions for IO effects

## Critical: Reactor Model

Default GHC WASM produces "command" modules that run main() and exit. We need "reactor" modules that export functions and stay alive.

Required GHC flags:
```
-no-hs-main
-optl-mexec-model=reactor
-optl-Wl,--export=hs_init
-optl-Wl,--export=handle_mcp_call
-optl-Wl,--allow-undefined
```

## Tasks

- [x] 1. Create `haskell/wasm-guest/` package
- [x] 2. Configure `wasm-guest.cabal`:
   ```cabal
   executable wasm-guest
     if arch(wasm32)
       ghc-options:
         -no-hs-main
         -optl-mexec-model=reactor
         -optl-Wl,--export=hs_init
         -optl-Wl,--export=handle_mcp_call
         -optl-Wl,--export=handle_pre_tool_use
         -optl-Wl,--allow-undefined
   ```
- [x] 3. Add dependencies:
   - `extism-pdk`
   - `freer-simple`
   - `aeson`
- [x] 4. Implement `Main.hs` with foreign exports:
   ```haskell
   foreign export ccall handle_mcp_call :: IO Int32
   foreign export ccall handle_pre_tool_use :: IO Int32
   ```
- [x] 5. Implement host call FFI in `ExoMonad/Guest/HostCall.hs`:
   ```haskell
   foreign import ccall "git_get_branch" host_git_get_branch :: Word64 -> IO Word64
   ```
- [x] 6. Implement freer-simple interpreter that calls host functions
- [ ] 7. Verify compilation: `wasm32-wasi-cabal build wasm-guest` (Skipped: Disk space limit on environment)
- [ ] 8. Verify exports: `wasm-objdump -x plugin.wasm | grep Export` (Skipped: Build failed)

## Reference

- `wasm-plan/03-haskell-guest.md` - Full guest architecture
- `haskell/control-server/src/ExoMonad/Control/Handler/` - Logic to adapt

## Acceptance Criteria

- [ ] `wasm32-wasi-cabal build` succeeds
- [ ] Output is reactor (exports visible, no _start)
- [ ] Exports include: `hs_init`, `handle_mcp_call`, `handle_pre_tool_use`
- [ ] WASM can be loaded by Extism (even with missing host functions)
- [ ] freer-simple effects compile

## GHC WASM Toolchain

**Don't use standard ghcup** - use `ghc-wasm-meta`:
- Nix: Add their cache, use `nix develop`
- Docker: `ghc-wasm-meta:master` image
- Target GHC 9.10+ for best RTS support

If host functions are missing at runtime, that's expected - Stream B provides them.

## Critical Gotchas

### 1. Host Function Call Pattern
```haskell
foreign import ccall "git_get_branch" raw_git_get_branch :: Word64 -> IO Word64

callHost :: (ToJSON req, FromJSON resp) => (Word64 -> IO Word64) -> req -> IO (Either String resp)
callHost rawFn request = do
  reqOffset <- alloc (toStrict $ encode request)
  respOffset <- rawFn (unMemoryOffset reqOffset)
  respResult <- load (MemoryOffset respOffset)
  free reqOffset  -- We allocated, we free
  -- decode respResult...
```

### 2. Error Handling at Export Boundary
Wrap exports in catch to return structured errors:
```haskell
handle_mcp_call :: IO Int32
handle_mcp_call = do
  result <- try @SomeException $ do
    input <- inputJSON
    -- ... logic ...
    outputJSON response
  case result of
    Right () -> pure 0
    Left err -> do
      outputJSON $ McpError (pack $ show err)
      pure 1
```

### 3. Binary Size
Haskell WASM is large (10MB+). After build:
```bash
wasm-opt -O3 plugin.wasm -o plugin-opt.wasm  # Cuts ~50%
```

See `wasm-plan/07-implementation-details.md` for full research findings.
