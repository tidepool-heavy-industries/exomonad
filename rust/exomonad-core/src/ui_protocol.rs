//! UI protocol and types for ExoMonad TUI integration.
//!
//! This crate defines the communication protocol between the ExoMonad host/plugin
//! and the TUI sidebar/coordinator. It includes message types for:
//!
//! - **Popup UI**: Rendered via Zellij WASM plugins
//! - **Telemetry**: Real-time progress and logs
//! - **Control**: Commands for agent lifecycle management

use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::collections::HashMap;
use std::fmt;

// ============================================================================
// Transport Constants
// ============================================================================

/// Pipe names for service-plugin communication via Zellij pipes.
pub mod transport {
    /// Pipe name for popup requests (used with zellij pipe --plugin)
    pub const POPUP_PIPE: &str = "exomonad:popup";

    /// Pipe name for injecting text input into a target pane via the plugin.
    pub const INJECT_INPUT_PIPE: &str = "exomonad:inject-input";
}

// ============================================================================
// Request/Response Envelopes
// ============================================================================

/// Request envelope sent from service to plugin via Zellij pipe.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PopupRequest {
    /// Unique identifier for this popup request.
    pub request_id: String,
    /// The popup form definition.
    pub definition: PopupDefinition,
}

/// Response envelope sent from plugin to service via Zellij pipe.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PopupResponse {
    /// The request_id this response corresponds to.
    pub request_id: String,
    /// The result of the popup interaction.
    pub result: PopupResult,
}

/// Agent identifier.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(try_from = "String", into = "String")]
pub struct AgentId(String);

impl TryFrom<String> for AgentId {
    type Error = String;

    fn try_from(s: String) -> Result<Self, Self::Error> {
        if s.is_empty() {
            return Err("Agent ID cannot be empty".to_string());
        }
        Ok(Self(s))
    }
}

impl From<AgentId> for String {
    fn from(id: AgentId) -> String {
        id.0
    }
}

impl fmt::Display for AgentId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

/// Events broadcast by agent sidecars via Zellij pipes
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type")]
pub enum AgentEvent {
    #[serde(rename = "agent:started")]
    AgentStarted {
        agent_id: AgentId,
        timestamp: String,
    },
    #[serde(rename = "agent:stopped")]
    AgentStopped {
        agent_id: AgentId,
        timestamp: String,
    },
    #[serde(rename = "stop_hook:blocked")]
    StopHookBlocked {
        agent_id: AgentId,
        reason: String,
        timestamp: String,
    },
    #[serde(rename = "hook:received")]
    HookReceived {
        agent_id: AgentId,
        hook_type: String,
        timestamp: String,
    },
    #[serde(rename = "pr:filed")]
    PrFiled {
        agent_id: AgentId,
        pr_number: u64,
        timestamp: String,
    },
    #[serde(rename = "copilot:reviewed")]
    CopilotReviewed {
        agent_id: AgentId,
        comment_count: u32,
        timestamp: String,
    },
    #[serde(rename = "agent:stuck")]
    AgentStuck {
        agent_id: AgentId,
        failed_stop_count: u32,
        timestamp: String,
    },
}

/// A popup form definition.
///
/// Defines the structure of an interactive popup form with a title and components.
/// Generated by Haskell WASM (RequestInput effect) and rendered by the Zellij plugin.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PopupDefinition {
    /// Title displayed at the top of the popup.
    pub title: String,

    /// List of UI components in the form (text, slider, checkbox, etc.).
    pub components: Vec<Component>,
}

/// Component deserialized from Haskell ToJSON format.
/// Haskell uses flat structure with "type" field, not nested "spec" object.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type")]
pub enum Component {
    #[serde(rename = "text")]
    Text {
        id: String,
        content: String,
        #[serde(default)]
        visible_when: Option<VisibilityRule>,
    },
    #[serde(rename = "slider")]
    Slider {
        id: String,
        label: String,
        min: f32,
        max: f32,
        default: f32,
        #[serde(default)]
        visible_when: Option<VisibilityRule>,
    },
    #[serde(rename = "checkbox")]
    Checkbox {
        id: String,
        label: String,
        default: bool,
        #[serde(default)]
        visible_when: Option<VisibilityRule>,
    },
    #[serde(rename = "textbox")]
    Textbox {
        id: String,
        label: String,
        placeholder: Option<String>,
        rows: Option<u32>,
        #[serde(default)]
        visible_when: Option<VisibilityRule>,
    },
    #[serde(rename = "choice")]
    Choice {
        id: String,
        label: String,
        options: Vec<String>,
        default: Option<usize>,
        #[serde(default)]
        visible_when: Option<VisibilityRule>,
    },
    #[serde(rename = "multiselect")]
    Multiselect {
        id: String,
        label: String,
        options: Vec<String>,
        default: Option<usize>, // Keeping for backward compat, though unused in logic
        #[serde(default)]
        visible_when: Option<VisibilityRule>,
    },
    #[serde(rename = "group")]
    Group {
        id: String,
        label: String,
        #[serde(default)]
        visible_when: Option<VisibilityRule>,
    },
}

impl Component {
    /// Get the component ID.
    pub fn id(&self) -> &str {
        match self {
            Component::Text { id, .. } => id,
            Component::Slider { id, .. } => id,
            Component::Checkbox { id, .. } => id,
            Component::Textbox { id, .. } => id,
            Component::Choice { id, .. } => id,
            Component::Multiselect { id, .. } => id,
            Component::Group { id, .. } => id,
        }
    }

    /// Get the visibility rule.
    pub fn visible_when(&self) -> Option<&VisibilityRule> {
        match self {
            Component::Text { visible_when, .. } => visible_when.as_ref(),
            Component::Slider { visible_when, .. } => visible_when.as_ref(),
            Component::Checkbox { visible_when, .. } => visible_when.as_ref(),
            Component::Textbox { visible_when, .. } => visible_when.as_ref(),
            Component::Choice { visible_when, .. } => visible_when.as_ref(),
            Component::Multiselect { visible_when, .. } => visible_when.as_ref(),
            Component::Group { visible_when, .. } => visible_when.as_ref(),
        }
    }
}

/// Visibility rules from Haskell TUI.hs.
/// Uses serde untagged since Haskell encodes these as simple objects.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum VisibilityRule {
    /// Show if checkbox with ID is checked. {"visible_when": "checkbox-id"}
    Checked(String),
    /// Show if choice equals value. {"visible_when": {"choice-id": "value"}}
    Equals(HashMap<String, String>),
    /// Show if a numeric component's value is greater than or equal to `min_value`.
    /// Haskell: GreaterThan { id, min_value }
    GreaterThan { id: String, min_value: f32 },
    /// Show if a numeric component's value is less than or equal to `max_value`.
    /// Haskell: LessThan { id, max_value }
    LessThan { id: String, max_value: f32 },
    /// Show if the count for a component (e.g., multiselect) equals `exact_count`.
    /// Haskell: CountEquals { id, exact_count }
    CountEquals { id: String, exact_count: u32 },
    /// Show if the count for a component is greater than or equal to `min_count`.
    /// Haskell: CountGreaterThan { id, min_count }
    CountGreaterThan { id: String, min_count: u32 },
}

/// Runtime state of a popup form.
///
/// Tracks the current values of all form components and which button was clicked.
/// Created from a [`PopupDefinition`] with default values, then updated as user interacts.
#[derive(Debug, Clone)]
pub struct PopupState {
    /// Current value for each component (keyed by component ID).
    pub values: HashMap<String, ElementValue>,

    /// Which button was clicked to submit/cancel (if any).
    pub button_clicked: Option<String>,
}

/// Typed value for a form component.
///
/// Each component type stores its value in a specific variant:
/// - **Slider** → `Number(f32)`
/// - **Checkbox** → `Boolean(bool)`
/// - **Textbox** → `Text(String)`
/// - **Choice** → `Choice(usize)` (selected option index)
/// - **Multiselect** → `MultiChoice(Vec<bool>)` (one bool per option)
#[derive(Debug, Clone, PartialEq)]
pub enum ElementValue {
    /// Slider value (f32).
    Number(f32),

    /// Checkbox value (bool).
    Boolean(bool),

    /// Textbox value (String).
    Text(String),

    /// Choice selected index (usize).
    Choice(usize),

    /// Multiselect selection bitmask (`Vec<bool>`).
    MultiChoice(Vec<bool>),
}

impl PopupState {
    pub fn new(definition: &PopupDefinition) -> Self {
        let mut values = HashMap::new();
        for component in &definition.components {
            match component {
                Component::Slider { id, default, .. } => {
                    values.insert(id.clone(), ElementValue::Number(*default));
                }
                Component::Checkbox { id, default, .. } => {
                    values.insert(id.clone(), ElementValue::Boolean(*default));
                }
                Component::Textbox { id, .. } => {
                    values.insert(id.clone(), ElementValue::Text(String::new()));
                }
                Component::Choice { id, default, .. } => {
                    values.insert(id.clone(), ElementValue::Choice(default.unwrap_or(0)));
                }
                Component::Multiselect { id, options, .. } => {
                    values.insert(
                        id.clone(),
                        ElementValue::MultiChoice(vec![false; options.len()]),
                    );
                }
                _ => {}
            }
        }
        Self {
            values,
            button_clicked: None,
        }
    }

    // Helper to extract plain JSON values for submission
    pub fn to_json_values(&self) -> Value {
        let mut map = serde_json::Map::new();
        for (k, v) in &self.values {
            let json_val = match v {
                ElementValue::Number(n) => serde_json::json!(n),
                ElementValue::Boolean(b) => serde_json::json!(b),
                ElementValue::Text(s) => serde_json::json!(s),
                ElementValue::Choice(i) => serde_json::json!(i),
                ElementValue::MultiChoice(vec) => serde_json::json!(vec),
            };
            map.insert(k.clone(), json_val);
        }
        Value::Object(map)
    }

    pub fn get_number(&self, id: &str) -> Option<f32> {
        match self.values.get(id) {
            Some(ElementValue::Number(n)) => Some(*n),
            _ => None,
        }
    }

    pub fn get_boolean(&self, id: &str) -> Option<bool> {
        match self.values.get(id) {
            Some(ElementValue::Boolean(b)) => Some(*b),
            _ => None,
        }
    }

    pub fn get_text(&self, id: &str) -> Option<&str> {
        match self.values.get(id) {
            Some(ElementValue::Text(t)) => Some(t),
            _ => None,
        }
    }

    pub fn get_choice(&self, id: &str) -> Option<usize> {
        match self.values.get(id) {
            Some(ElementValue::Choice(c)) => Some(*c),
            _ => None,
        }
    }

    pub fn get_multichoice(&self, id: &str) -> Option<&[bool]> {
        match self.values.get(id) {
            Some(ElementValue::MultiChoice(v)) => Some(v),
            _ => None,
        }
    }

    pub fn set_number(&mut self, id: &str, value: f32) {
        self.values
            .insert(id.to_string(), ElementValue::Number(value));
    }

    pub fn set_boolean(&mut self, id: &str, value: bool) {
        self.values
            .insert(id.to_string(), ElementValue::Boolean(value));
    }

    pub fn set_text(&mut self, id: &str, value: String) {
        self.values
            .insert(id.to_string(), ElementValue::Text(value));
    }

    pub fn set_choice(&mut self, id: &str, value: usize) {
        self.values
            .insert(id.to_string(), ElementValue::Choice(value));
    }

    pub fn set_multichoice(&mut self, id: &str, value: Vec<bool>) {
        self.values
            .insert(id.to_string(), ElementValue::MultiChoice(value));
    }

    /// Evaluate a visibility rule against current form state.
    pub fn evaluate_visibility(&self, rule: &VisibilityRule) -> bool {
        match rule {
            VisibilityRule::Checked(id) => self.get_boolean(id).unwrap_or(false),
            VisibilityRule::Equals(map) => map.iter().all(|(id, expected)| {
                if let Some(ElementValue::Choice(idx)) = self.values.get(id) {
                    idx.to_string() == *expected
                } else {
                    false
                }
            }),
            VisibilityRule::GreaterThan { id, min_value } => {
                self.get_number(id).is_some_and(|v| v >= *min_value)
            }
            VisibilityRule::LessThan { id, max_value } => {
                self.get_number(id).is_some_and(|v| v <= *max_value)
            }
            VisibilityRule::CountEquals { id, exact_count } => self
                .get_multichoice(id)
                .is_some_and(|v| v.iter().filter(|&&b| b).count() == *exact_count as usize),
            VisibilityRule::CountGreaterThan { id, min_count } => self
                .get_multichoice(id)
                .is_some_and(|v| v.iter().filter(|&&b| b).count() >= *min_count as usize),
        }
    }

    /// Evaluate visibility for a component. Components without visibility rules are always visible.
    pub fn is_visible(&self, component: &Component) -> bool {
        match component.visible_when() {
            None => true,
            Some(rule) => self.evaluate_visibility(rule),
        }
    }

    /// Get the selected option label for a Choice component.
    pub fn get_choice_label(&self, id: &str, components: &[Component]) -> Option<String> {
        let idx = self.get_choice(id)?;
        components.iter().find_map(|c| match c {
            Component::Choice {
                id: cid, options, ..
            } if cid == id => options.get(idx).cloned(),
            _ => None,
        })
    }
}

/// JSON result containing all form values
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct PopupResult {
    pub button: String, // "submit" or "decline"
    pub values: Value,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub time_spent_seconds: Option<f64>, // Time user spent interacting with popup
}

// ============================================================================
// Wizard Types
// ============================================================================

/// A multi-pane wizard definition. Sent as JSON via the popup pipe.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct WizardDefinition {
    pub title: String,
    pub panes: HashMap<String, WizardPane>,
    pub start: String,
}

/// A single pane in a wizard.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct WizardPane {
    pub title: String,
    pub elements: Vec<Component>,
    #[serde(default)]
    pub then_transition: Option<Transition>,
}

/// Transition rule for wizard pane navigation.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(untagged)]
pub enum Transition {
    /// Unconditional: always go to this pane.
    Goto(String),
    /// Conditional: branch based on a field's value.
    /// Outer key = field_id, inner key = option value, inner value = target pane.
    Branch(HashMap<String, HashMap<String, String>>),
}

/// Result of a wizard interaction.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct WizardResult {
    pub button: String,
    pub values: HashMap<String, serde_json::Value>,
    pub panes_visited: Vec<String>,
}

/// Request envelope for wizard popups sent from service to plugin via Zellij pipe.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct WizardRequest {
    pub request_id: String,
    pub wizard: WizardDefinition,
}

// ============================================================================
// Coordinator State Updates
// ============================================================================

/// Agent lifecycle status from the coordinator plugin.
///
/// Pushed from coordinator -> UI plugin via pipe_message_to_plugin.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "phase")]
pub enum CoordinatorAgentStatus {
    /// Effector running setup (worktree + config).
    #[serde(rename = "setting_up")]
    SettingUp,
    /// Command pane opening.
    #[serde(rename = "pane_opening")]
    PaneOpening,
    /// Agent running in pane.
    #[serde(rename = "running")]
    Running { pane_id: u32 },
    /// Cleanup in progress.
    #[serde(rename = "cleaning")]
    Cleaning,
    /// Agent exited.
    #[serde(rename = "completed")]
    Completed { exit_code: i32 },
    /// Setup or execution failed.
    #[serde(rename = "failed")]
    Failed { error: String },
}

/// Agent state from the coordinator.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub struct CoordinatorAgentState {
    pub id: String,
    pub worktree_path: String,
    pub branch: String,
    pub agent_type: String,
    pub status: CoordinatorAgentStatus,
}

/// State update pushed from coordinator to UI plugin.
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
#[serde(tag = "type")]
pub enum StateUpdate {
    /// Full state snapshot (all agents).
    #[serde(rename = "coordinator:state")]
    FullState { agents: Vec<CoordinatorAgentState> },
}

#[cfg(test)]
mod tests {
    use super::*;

    // === Component deserialization tests ===

    #[test]
    fn test_text_component_deser() {
        let json = r#"{
            "id": "info",
            "type": "text",
            "content": "This is informational text"
        }"#;
        let parsed: Component = serde_json::from_str(json).unwrap();
        match parsed {
            Component::Text {
                id,
                content,
                visible_when,
            } => {
                assert_eq!(id, "info");
                assert_eq!(content, "This is informational text");
                assert!(visible_when.is_none());
            }
            _ => panic!("Expected Text component"),
        }
    }

    #[test]
    fn test_slider_component_deser() {
        let json = r#"{
            "id": "confidence",
            "type": "slider",
            "label": "Confidence Level",
            "min": 0.0,
            "max": 100.0,
            "default": 75.5
        }"#;
        let parsed: Component = serde_json::from_str(json).unwrap();
        match parsed {
            Component::Slider {
                id,
                label,
                min,
                max,
                default,
                visible_when,
            } => {
                assert_eq!(id, "confidence");
                assert_eq!(label, "Confidence Level");
                assert_eq!(min, 0.0);
                assert_eq!(max, 100.0);
                assert_eq!(default, 75.5);
                assert!(visible_when.is_none());
            }
            _ => panic!("Expected Slider component"),
        }
    }

    #[test]
    fn test_checkbox_component_deser() {
        let json = r#"{
            "id": "agree",
            "type": "checkbox",
            "label": "I agree to the terms",
            "default": false
        }"#;
        let parsed: Component = serde_json::from_str(json).unwrap();
        match parsed {
            Component::Checkbox {
                id,
                label,
                default,
                visible_when,
            } => {
                assert_eq!(id, "agree");
                assert_eq!(label, "I agree to the terms");
                assert!(!default);
                assert!(visible_when.is_none());
            }
            _ => panic!("Expected Checkbox component"),
        }
    }

    #[test]
    fn test_textbox_component_deser() {
        let json = r#"{
            "id": "notes",
            "type": "textbox",
            "label": "Additional Notes",
            "placeholder": "Enter notes here...",
            "rows": 3
        }"#;
        let parsed: Component = serde_json::from_str(json).unwrap();
        match parsed {
            Component::Textbox {
                id,
                label,
                placeholder,
                rows,
                visible_when,
            } => {
                assert_eq!(id, "notes");
                assert_eq!(label, "Additional Notes");
                assert_eq!(placeholder, Some("Enter notes here...".to_string()));
                assert_eq!(rows, Some(3));
                assert!(visible_when.is_none());
            }
            _ => panic!("Expected Textbox component"),
        }
    }

    #[test]
    fn test_choice_component_deser() {
        let json = r#"{
            "id": "color",
            "type": "choice",
            "label": "Choose a color",
            "options": ["Red", "Green", "Blue"],
            "default": 1
        }"#;
        let parsed: Component = serde_json::from_str(json).unwrap();
        match parsed {
            Component::Choice {
                id,
                label,
                options,
                default,
                visible_when,
            } => {
                assert_eq!(id, "color");
                assert_eq!(label, "Choose a color");
                assert_eq!(options, vec!["Red", "Green", "Blue"]);
                assert_eq!(default, Some(1));
                assert!(visible_when.is_none());
            }
            _ => panic!("Expected Choice component"),
        }
    }

    #[test]
    fn test_multiselect_component_deser() {
        let json = r#"{
            "id": "features",
            "type": "multiselect",
            "label": "Select features",
            "options": ["Feature A", "Feature B", "Feature C"]
        }"#;
        let parsed: Component = serde_json::from_str(json).unwrap();
        match parsed {
            Component::Multiselect {
                id,
                label,
                options,
                default,
                visible_when,
            } => {
                assert_eq!(id, "features");
                assert_eq!(label, "Select features");
                assert_eq!(options, vec!["Feature A", "Feature B", "Feature C"]);
                assert!(default.is_none());
                assert!(visible_when.is_none());
            }
            _ => panic!("Expected Multiselect component"),
        }
    }

    #[test]
    fn test_group_component_deser() {
        let json = r#"{
            "id": "advanced",
            "type": "group",
            "label": "Advanced Settings"
        }"#;
        let parsed: Component = serde_json::from_str(json).unwrap();
        match parsed {
            Component::Group {
                id,
                label,
                visible_when,
            } => {
                assert_eq!(id, "advanced");
                assert_eq!(label, "Advanced Settings");
                assert!(visible_when.is_none());
            }
            _ => panic!("Expected Group component"),
        }
    }

    // === Visibility rule tests ===

    #[test]
    fn test_component_with_visibility_deserialization() {
        let json = r#"{
            "id": "slider1",
            "type": "slider",
            "label": "My Slider",
            "min": 0.0,
            "max": 100.0,
            "default": 50.0,
            "visible_when": "checkbox1"
        }"#;

        let parsed: Component = serde_json::from_str(json).unwrap();
        match parsed {
            Component::Slider {
                id, visible_when, ..
            } => {
                assert_eq!(id, "slider1");
                assert_eq!(
                    visible_when,
                    Some(VisibilityRule::Checked("checkbox1".to_string()))
                );
            }
            _ => panic!("Expected Slider component"),
        }
    }

    #[test]
    fn test_visibility_rule_variants() {
        // GreaterThan (untagged, matches by structure)
        let json = r#"{"id": "s1", "min_value": 10.0}"#;
        let rule: VisibilityRule = serde_json::from_str(json).unwrap();
        match rule {
            VisibilityRule::GreaterThan { id, min_value } => {
                assert_eq!(id, "s1");
                assert_eq!(min_value, 10.0);
            }
            _ => panic!("Expected GreaterThan"),
        }

        // CountEquals (untagged)
        let json = r#"{"id": "m1", "exact_count": 2}"#;
        let rule: VisibilityRule = serde_json::from_str(json).unwrap();
        match rule {
            VisibilityRule::CountEquals { id, exact_count } => {
                assert_eq!(id, "m1");
                assert_eq!(exact_count, 2);
            }
            _ => panic!("Expected CountEquals"),
        }
    }

    #[test]
    fn test_visibility_rule_less_than() {
        let json = r#"{"id": "s1", "max_value": 50.0}"#;
        let rule: VisibilityRule = serde_json::from_str(json).unwrap();
        match rule {
            VisibilityRule::LessThan { id, max_value } => {
                assert_eq!(id, "s1");
                assert_eq!(max_value, 50.0);
            }
            _ => panic!("Expected LessThan"),
        }
    }

    #[test]
    fn test_visibility_rule_count_greater_than() {
        let json = r#"{"id": "m1", "min_count": 1}"#;
        let rule: VisibilityRule = serde_json::from_str(json).unwrap();
        match rule {
            VisibilityRule::CountGreaterThan { id, min_count } => {
                assert_eq!(id, "m1");
                assert_eq!(min_count, 1);
            }
            _ => panic!("Expected CountGreaterThan"),
        }
    }

    // === PopupState initialization tests ===

    #[test]
    fn test_popup_state_slider_default() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Slider {
                id: "slider1".to_string(),
                label: "Test Slider".to_string(),
                min: 0.0,
                max: 100.0,
                default: 42.5,
                visible_when: None,
            }],
        };
        let state = PopupState::new(&definition);
        assert_eq!(state.get_number("slider1"), Some(42.5));
    }

    #[test]
    fn test_popup_state_checkbox_default() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Checkbox {
                id: "check1".to_string(),
                label: "Test Checkbox".to_string(),
                default: true,
                visible_when: None,
            }],
        };
        let state = PopupState::new(&definition);
        assert_eq!(state.get_boolean("check1"), Some(true));
    }

    #[test]
    fn test_popup_state_textbox_empty() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Textbox {
                id: "text1".to_string(),
                label: "Test Textbox".to_string(),
                placeholder: Some("Enter text...".to_string()),
                rows: None,
                visible_when: None,
            }],
        };
        let state = PopupState::new(&definition);
        assert_eq!(state.get_text("text1"), Some(""));
    }

    #[test]
    fn test_popup_state_choice_default() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Choice {
                id: "choice1".to_string(),
                label: "Test Choice".to_string(),
                options: vec!["A".to_string(), "B".to_string(), "C".to_string()],
                default: Some(2),
                visible_when: None,
            }],
        };
        let state = PopupState::new(&definition);
        assert_eq!(state.get_choice("choice1"), Some(2));
    }

    #[test]
    fn test_popup_state_choice_no_default() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Choice {
                id: "choice1".to_string(),
                label: "Test Choice".to_string(),
                options: vec!["A".to_string(), "B".to_string()],
                default: None,
                visible_when: None,
            }],
        };
        let state = PopupState::new(&definition);
        assert_eq!(state.get_choice("choice1"), Some(0)); // Defaults to 0 when None
    }

    #[test]
    fn test_popup_state_multiselect_init() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Multiselect {
                id: "multi1".to_string(),
                label: "Test Multi".to_string(),
                options: vec!["X".to_string(), "Y".to_string(), "Z".to_string()],
                default: None,
                visible_when: None,
            }],
        };
        let state = PopupState::new(&definition);
        assert_eq!(
            state.get_multichoice("multi1"),
            Some(&[false, false, false][..])
        );
    }

    // === Getter/setter tests ===

    #[test]
    fn test_get_set_number() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Slider {
                id: "num".to_string(),
                label: "Number".to_string(),
                min: 0.0,
                max: 100.0,
                default: 0.0,
                visible_when: None,
            }],
        };
        let mut state = PopupState::new(&definition);
        assert_eq!(state.get_number("num"), Some(0.0));

        state.set_number("num", 99.9);
        assert_eq!(state.get_number("num"), Some(99.9));
    }

    #[test]
    fn test_get_set_boolean() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Checkbox {
                id: "flag".to_string(),
                label: "Flag".to_string(),
                default: false,
                visible_when: None,
            }],
        };
        let mut state = PopupState::new(&definition);
        assert_eq!(state.get_boolean("flag"), Some(false));

        state.set_boolean("flag", true);
        assert_eq!(state.get_boolean("flag"), Some(true));
    }

    #[test]
    fn test_get_set_text() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Textbox {
                id: "txt".to_string(),
                label: "Text".to_string(),
                placeholder: None,
                rows: None,
                visible_when: None,
            }],
        };
        let mut state = PopupState::new(&definition);
        assert_eq!(state.get_text("txt"), Some(""));

        state.set_text("txt", "Hello World".to_string());
        assert_eq!(state.get_text("txt"), Some("Hello World"));
    }

    #[test]
    fn test_get_set_choice() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Choice {
                id: "sel".to_string(),
                label: "Selection".to_string(),
                options: vec!["A".to_string(), "B".to_string(), "C".to_string()],
                default: Some(0),
                visible_when: None,
            }],
        };
        let mut state = PopupState::new(&definition);
        assert_eq!(state.get_choice("sel"), Some(0));

        state.set_choice("sel", 2);
        assert_eq!(state.get_choice("sel"), Some(2));
    }

    #[test]
    fn test_get_set_multichoice() {
        let definition = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Multiselect {
                id: "opts".to_string(),
                label: "Options".to_string(),
                options: vec!["1".to_string(), "2".to_string(), "3".to_string()],
                default: None,
                visible_when: None,
            }],
        };
        let mut state = PopupState::new(&definition);
        assert_eq!(
            state.get_multichoice("opts"),
            Some(&[false, false, false][..])
        );

        state.set_multichoice("opts", vec![true, false, true]);
        assert_eq!(
            state.get_multichoice("opts"),
            Some(&[true, false, true][..])
        );
    }

    // === Component helper method tests ===

    #[test]
    fn test_component_id_method() {
        let text = Component::Text {
            id: "t1".to_string(),
            content: "Hello".to_string(),
            visible_when: None,
        };
        assert_eq!(text.id(), "t1");

        let slider = Component::Slider {
            id: "s1".to_string(),
            label: "Slider".to_string(),
            min: 0.0,
            max: 100.0,
            default: 50.0,
            visible_when: None,
        };
        assert_eq!(slider.id(), "s1");
    }

    #[test]
    fn test_component_visible_when_method() {
        let component = Component::Checkbox {
            id: "cb".to_string(),
            label: "Check".to_string(),
            default: false,
            visible_when: Some(VisibilityRule::Checked("other".to_string())),
        };
        assert_eq!(
            component.visible_when(),
            Some(&VisibilityRule::Checked("other".to_string()))
        );

        let no_rule = Component::Text {
            id: "t".to_string(),
            content: "x".to_string(),
            visible_when: None,
        };
        assert!(no_rule.visible_when().is_none());
    }

    // === JSON value serialization ===

    #[test]
    fn test_to_json_values() {
        let mut values = HashMap::new();
        values.insert("num".to_string(), ElementValue::Number(42.0));
        values.insert("bool".to_string(), ElementValue::Boolean(true));
        values.insert("text".to_string(), ElementValue::Text("hello".to_string()));
        values.insert("choice".to_string(), ElementValue::Choice(1));
        values.insert(
            "multi".to_string(),
            ElementValue::MultiChoice(vec![true, false]),
        );

        let state = PopupState {
            values,
            button_clicked: None,
        };

        let json = state.to_json_values();
        let obj = json.as_object().unwrap();

        assert_eq!(obj["num"], 42.0);
        assert_eq!(obj["bool"], true);
        assert_eq!(obj["text"], "hello");
        assert_eq!(obj["choice"], 1);
        assert_eq!(obj["multi"][0], true);
        assert_eq!(obj["multi"][1], false);
    }

    // === AgentId tests ===

    #[test]
    fn test_agent_id_valid() {
        let id: Result<AgentId, _> = "agent-123".to_string().try_into();
        assert!(id.is_ok());
        assert_eq!(id.unwrap().to_string(), "agent-123");
    }

    #[test]
    fn test_agent_id_empty_rejected() {
        let id: Result<AgentId, _> = "".to_string().try_into();
        assert!(id.is_err());
        assert!(id.unwrap_err().contains("empty"));
    }

    #[test]
    fn test_agent_id_serialization_roundtrip() {
        let id: AgentId = "test-agent".to_string().try_into().unwrap();
        let json = serde_json::to_string(&id).unwrap();
        assert_eq!(json, "\"test-agent\"");

        let deserialized: AgentId = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.to_string(), "test-agent");
    }

    // === AgentEvent tests ===

    #[test]
    fn test_agent_event_serialization() {
        let event = AgentEvent::AgentStarted {
            agent_id: "agent-1".to_string().try_into().unwrap(),
            timestamp: "2024-01-01T00:00:00Z".to_string(),
        };
        let json = serde_json::to_string(&event).unwrap();
        assert!(json.contains("\"type\":\"agent:started\""));
        assert!(json.contains("\"agent_id\":\"agent-1\""));
    }

    // === PopupResult tests ===

    #[test]
    fn test_popup_result_serialization() {
        let result = PopupResult {
            button: "submit".to_string(),
            values: serde_json::json!({"name": "test"}),
            time_spent_seconds: Some(5.5),
        };
        let json = serde_json::to_string(&result).unwrap();
        assert!(json.contains("\"button\":\"submit\""));
        assert!(json.contains("\"time_spent_seconds\":5.5"));

        let deserialized: PopupResult = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.button, "submit");
    }

    // === Transport types tests ===

    #[test]
    fn test_popup_request_serialization() {
        let request = super::PopupRequest {
            request_id: "req-123".to_string(),
            definition: PopupDefinition {
                title: "Test Form".to_string(),
                components: vec![Component::Text {
                    id: "msg".to_string(),
                    content: "Hello".to_string(),
                    visible_when: None,
                }],
            },
        };

        let json = serde_json::to_string(&request).unwrap();
        assert!(json.contains("\"request_id\":\"req-123\""));
        assert!(json.contains("\"title\":\"Test Form\""));

        let deserialized: super::PopupRequest = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.request_id, "req-123");
        assert_eq!(deserialized.definition.title, "Test Form");
    }

    #[test]
    fn test_popup_response_serialization() {
        let response = super::PopupResponse {
            request_id: "req-456".to_string(),
            result: PopupResult {
                button: "submit".to_string(),
                values: serde_json::json!({"name": "test"}),
                time_spent_seconds: Some(10.0),
            },
        };

        let json = serde_json::to_string(&response).unwrap();
        assert!(json.contains("\"request_id\":\"req-456\""));
        assert!(json.contains("\"button\":\"submit\""));

        let deserialized: super::PopupResponse = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.request_id, "req-456");
        assert_eq!(deserialized.result.button, "submit");
    }

    #[test]
    fn test_transport_constants() {
        assert_eq!(super::transport::POPUP_PIPE, "exomonad:popup");
    }

    // === Wizard type tests ===

    #[test]
    fn test_wizard_definition_deser() {
        let json = r#"{
            "title": "Test Wizard",
            "panes": {
                "start": {
                    "title": "First Pane",
                    "elements": [
                        {"type": "choice", "id": "q1", "label": "Pick one", "options": ["A", "B"]}
                    ],
                    "then_transition": "end"
                },
                "end": {
                    "title": "Done",
                    "elements": [
                        {"type": "text", "id": "msg", "content": "All done!"}
                    ]
                }
            },
            "start": "start"
        }"#;
        let wizard: WizardDefinition = serde_json::from_str(json).unwrap();
        assert_eq!(wizard.title, "Test Wizard");
        assert_eq!(wizard.start, "start");
        assert_eq!(wizard.panes.len(), 2);
        assert!(wizard.panes.get("start").unwrap().then_transition.is_some());
        assert!(wizard.panes.get("end").unwrap().then_transition.is_none());
    }

    #[test]
    fn test_transition_goto_deser() {
        let json = r#""next_pane""#;
        let t: Transition = serde_json::from_str(json).unwrap();
        match t {
            Transition::Goto(target) => assert_eq!(target, "next_pane"),
            _ => panic!("Expected Goto"),
        }
    }

    #[test]
    fn test_transition_branch_deser() {
        let json = r#"{"strategy": {"Simple": "confirm", "Complex": "details"}}"#;
        let t: Transition = serde_json::from_str(json).unwrap();
        match t {
            Transition::Branch(map) => {
                let strategy = map.get("strategy").unwrap();
                assert_eq!(strategy.get("Simple").unwrap(), "confirm");
                assert_eq!(strategy.get("Complex").unwrap(), "details");
            }
            _ => panic!("Expected Branch"),
        }
    }

    #[test]
    fn test_wizard_result_serialization() {
        let result = WizardResult {
            button: "submit".to_string(),
            values: {
                let mut m = HashMap::new();
                m.insert("pane1".to_string(), serde_json::json!({"q1": "A"}));
                m
            },
            panes_visited: vec!["start".to_string(), "end".to_string()],
        };
        let json = serde_json::to_string(&result).unwrap();
        let deser: WizardResult = serde_json::from_str(&json).unwrap();
        assert_eq!(deser.button, "submit");
        assert_eq!(deser.panes_visited.len(), 2);
    }

    // === evaluate_visibility tests ===

    #[test]
    fn test_evaluate_visibility_checked() {
        let def = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Checkbox {
                id: "cb".to_string(),
                label: "Check".to_string(),
                default: false,
                visible_when: None,
            }],
        };
        let mut state = PopupState::new(&def);
        assert!(!state.evaluate_visibility(&VisibilityRule::Checked("cb".to_string())));
        state.set_boolean("cb", true);
        assert!(state.evaluate_visibility(&VisibilityRule::Checked("cb".to_string())));
    }

    #[test]
    fn test_evaluate_visibility_greater_than() {
        let def = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Slider {
                id: "s".to_string(),
                label: "S".to_string(),
                min: 0.0,
                max: 100.0,
                default: 5.0,
                visible_when: None,
            }],
        };
        let state = PopupState::new(&def);
        assert!(!state.evaluate_visibility(&VisibilityRule::GreaterThan {
            id: "s".to_string(),
            min_value: 10.0
        }));
        assert!(state.evaluate_visibility(&VisibilityRule::GreaterThan {
            id: "s".to_string(),
            min_value: 5.0
        }));
    }

    #[test]
    fn test_evaluate_visibility_count_equals() {
        let def = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Multiselect {
                id: "m".to_string(),
                label: "M".to_string(),
                options: vec!["A".to_string(), "B".to_string(), "C".to_string()],
                default: None,
                visible_when: None,
            }],
        };
        let mut state = PopupState::new(&def);
        assert!(!state.evaluate_visibility(&VisibilityRule::CountEquals {
            id: "m".to_string(),
            exact_count: 2
        }));
        state.set_multichoice("m", vec![true, true, false]);
        assert!(state.evaluate_visibility(&VisibilityRule::CountEquals {
            id: "m".to_string(),
            exact_count: 2
        }));
    }

    #[test]
    fn test_is_visible_no_rule() {
        let component = Component::Text {
            id: "t".to_string(),
            content: "hi".to_string(),
            visible_when: None,
        };
        let state = PopupState {
            values: HashMap::new(),
            button_clicked: None,
        };
        assert!(state.is_visible(&component));
    }

    #[test]
    fn test_is_visible_with_rule() {
        let component = Component::Slider {
            id: "s".to_string(),
            label: "S".to_string(),
            min: 0.0,
            max: 10.0,
            default: 5.0,
            visible_when: Some(VisibilityRule::Checked("cb".to_string())),
        };
        let def = PopupDefinition {
            title: "Test".to_string(),
            components: vec![Component::Checkbox {
                id: "cb".to_string(),
                label: "CB".to_string(),
                default: false,
                visible_when: None,
            }],
        };
        let mut state = PopupState::new(&def);
        assert!(!state.is_visible(&component));
        state.set_boolean("cb", true);
        assert!(state.is_visible(&component));
    }

    #[test]
    fn test_get_choice_label() {
        let components = vec![Component::Choice {
            id: "c".to_string(),
            label: "C".to_string(),
            options: vec!["Red".to_string(), "Blue".to_string()],
            default: Some(0),
            visible_when: None,
        }];
        let def = PopupDefinition {
            title: "Test".to_string(),
            components: components.clone(),
        };
        let mut state = PopupState::new(&def);
        assert_eq!(
            state.get_choice_label("c", &components),
            Some("Red".to_string())
        );
        state.set_choice("c", 1);
        assert_eq!(
            state.get_choice_label("c", &components),
            Some("Blue".to_string())
        );
    }
}

#[cfg(test)]
mod proptest_tests {
    use super::*;
    use proptest::prelude::*;

    fn any_string() -> impl Strategy<Value = String> {
        "[a-zA-Z0-9_]+".prop_map(|s| s)
    }

    fn any_f32() -> impl Strategy<Value = f32> {
        any::<i32>().prop_map(|n| n as f32)
    }

    fn any_f64() -> impl Strategy<Value = f64> {
        any::<i32>().prop_map(|n| n as f64)
    }

    fn any_agent_id() -> impl Strategy<Value = AgentId> {
        any_string().prop_map(|s| AgentId::try_from(s).expect("regex ensures non-empty"))
    }

    fn any_agent_event() -> impl Strategy<Value = AgentEvent> {
        prop_oneof![
            (any_agent_id(), any_string()).prop_map(|(agent_id, timestamp)| AgentEvent::AgentStarted { agent_id, timestamp }),
            (any_agent_id(), any_string()).prop_map(|(agent_id, timestamp)| AgentEvent::AgentStopped { agent_id, timestamp }),
            (any_agent_id(), any_string(), any_string()).prop_map(|(agent_id, reason, timestamp)| AgentEvent::StopHookBlocked { agent_id, reason, timestamp }),
            (any_agent_id(), any_string(), any_string()).prop_map(|(agent_id, hook_type, timestamp)| AgentEvent::HookReceived { agent_id, hook_type, timestamp }),
            (any_agent_id(), any::<u64>(), any_string()).prop_map(|(agent_id, pr_number, timestamp)| AgentEvent::PrFiled { agent_id, pr_number, timestamp }),
            (any_agent_id(), any::<u32>(), any_string()).prop_map(|(agent_id, comment_count, timestamp)| AgentEvent::CopilotReviewed { agent_id, comment_count, timestamp }),
            (any_agent_id(), any::<u32>(), any_string()).prop_map(|(agent_id, failed_stop_count, timestamp)| AgentEvent::AgentStuck { agent_id, failed_stop_count, timestamp }),
        ]
    }

    fn any_visibility_rule() -> impl Strategy<Value = VisibilityRule> {
        prop_oneof![
            any_string().prop_map(VisibilityRule::Checked),
            prop::collection::hash_map(any_string(), any_string(), 0..5).prop_map(VisibilityRule::Equals),
            (any_string(), any_f32()).prop_map(|(id, min_value)| VisibilityRule::GreaterThan { id, min_value }),
            (any_string(), any_f32()).prop_map(|(id, max_value)| VisibilityRule::LessThan { id, max_value }),
            (any_string(), any::<u32>()).prop_map(|(id, exact_count)| VisibilityRule::CountEquals { id, exact_count }),
            (any_string(), any::<u32>()).prop_map(|(id, min_count)| VisibilityRule::CountGreaterThan { id, min_count }),
        ]
    }

    fn any_visibility_option() -> impl Strategy<Value = Option<VisibilityRule>> {
        prop::option::weighted(0.2, any_visibility_rule())
    }

    fn any_component() -> impl Strategy<Value = Component> {
        prop_oneof![
            (any_string(), any_string(), any_visibility_option()).prop_map(|(id, content, v)| Component::Text { id, content, visible_when: v }),
            (any_string(), any_string(), any_f32(), any_f32(), any_f32(), any_visibility_option()).prop_map(|(id, label, min, max, default, v)| Component::Slider { id, label, min, max, default, visible_when: v }),
            (any_string(), any_string(), any::<bool>(), any_visibility_option()).prop_map(|(id, label, default, v)| Component::Checkbox { id, label, default, visible_when: v }),
            (any_string(), any_string(), prop::option::of(any_string()), prop::option::of(any::<u32>()), any_visibility_option()).prop_map(|(id, label, placeholder, rows, v)| Component::Textbox { id, label, placeholder, rows, visible_when: v }),
            (any_string(), any_string(), prop::collection::vec(any_string(), 0..5), prop::option::of(any::<usize>()), any_visibility_option()).prop_map(|(id, label, options, default, v)| Component::Choice { id, label, options, default, visible_when: v }),
            (any_string(), any_string(), prop::collection::vec(any_string(), 0..5), prop::option::of(any::<usize>()), any_visibility_option()).prop_map(|(id, label, options, default, v)| Component::Multiselect { id, label, options, default, visible_when: v }),
            (any_string(), any_string(), any_visibility_option()).prop_map(|(id, label, v)| Component::Group { id, label, visible_when: v }),
        ]
    }

    fn any_popup_definition() -> impl Strategy<Value = PopupDefinition> {
        (any_string(), prop::collection::vec(any_component(), 0..5)).prop_map(|(title, components)| PopupDefinition { title, components })
    }

    fn any_json_value() -> impl Strategy<Value = serde_json::Value> {
        prop_oneof![
            any::<bool>().prop_map(serde_json::Value::Bool),
            any::<i64>().prop_map(|i| serde_json::Value::Number(i.into())),
            any_f64().prop_map(|f| {
                serde_json::Number::from_f64(f)
                    .map(serde_json::Value::Number)
                    .unwrap_or(serde_json::Value::Null)
            }),
            any_string().prop_map(serde_json::Value::String),
        ]
    }

    fn any_popup_result() -> impl Strategy<Value = PopupResult> {
        (any_string(), any_json_value(), prop::option::of(any_f64())).prop_map(|(button, values, time)| PopupResult {
            button,
            values,
            time_spent_seconds: time,
        })
    }

    fn any_coordinator_status() -> impl Strategy<Value = CoordinatorAgentStatus> {
        prop_oneof![
            Just(CoordinatorAgentStatus::SettingUp),
            Just(CoordinatorAgentStatus::PaneOpening),
            any::<u32>().prop_map(|pane_id| CoordinatorAgentStatus::Running { pane_id }),
            Just(CoordinatorAgentStatus::Cleaning),
            any::<i32>().prop_map(|exit_code| CoordinatorAgentStatus::Completed { exit_code }),
            any_string().prop_map(|error| CoordinatorAgentStatus::Failed { error }),
        ]
    }

    fn any_coordinator_agent_state() -> impl Strategy<Value = CoordinatorAgentState> {
        (any_string(), any_string(), any_string(), any_string(), any_coordinator_status()).prop_map(|(id, worktree_path, branch, agent_type, status)| CoordinatorAgentState {
            id,
            worktree_path,
            branch,
            agent_type,
            status,
        })
    }

    fn any_popup_request() -> impl Strategy<Value = PopupRequest> {
        (any_string(), any_popup_definition()).prop_map(|(request_id, definition)| PopupRequest {
            request_id,
            definition,
        })
    }

    fn any_popup_response() -> impl Strategy<Value = PopupResponse> {
        (any_string(), any_popup_result()).prop_map(|(request_id, result)| PopupResponse {
            request_id,
            result,
        })
    }

    fn any_transition() -> impl Strategy<Value = Transition> {
        prop_oneof![
            any_string().prop_map(Transition::Goto),
            prop::collection::hash_map(
                any_string(),
                prop::collection::hash_map(any_string(), any_string(), 1..3),
                1..3
            ).prop_map(Transition::Branch),
        ]
    }

    fn any_wizard_pane() -> impl Strategy<Value = WizardPane> {
        (any_string(), prop::collection::vec(any_component(), 0..5), prop::option::of(any_transition()))
            .prop_map(|(title, elements, then_transition)| WizardPane { title, elements, then_transition })
    }

    fn any_wizard_definition() -> impl Strategy<Value = WizardDefinition> {
        (any_string(), prop::collection::hash_map(any_string(), any_wizard_pane(), 1..3), any_string())
            .prop_map(|(title, panes, start)| WizardDefinition { title, panes, start })
    }

    fn any_wizard_request() -> impl Strategy<Value = WizardRequest> {
        (any_string(), any_wizard_definition()).prop_map(|(request_id, wizard)| WizardRequest { request_id, wizard })
    }

    fn any_wizard_result() -> impl Strategy<Value = WizardResult> {
        (any_string(), prop::collection::hash_map(any_string(), any_json_value(), 0..5), prop::collection::vec(any_string(), 0..5))
            .prop_map(|(button, values, panes_visited)| WizardResult { button, values, panes_visited })
    }

    fn any_state_update() -> impl Strategy<Value = StateUpdate> {
        prop::collection::vec(any_coordinator_agent_state(), 0..5).prop_map(|agents| StateUpdate::FullState { agents })
    }

    #[test]
    fn test_agent_id_roundtrip() {
        proptest!(|(id in any_agent_id())| {
            let json = serde_json::to_string(&id).unwrap();
            let deserialized: AgentId = serde_json::from_str(&json).unwrap();
            assert_eq!(id, deserialized);
        });
    }

    #[test]
    fn test_agent_event_roundtrip() {
        proptest!(|(event in any_agent_event())| {
            let json = serde_json::to_string(&event).unwrap();
            let deserialized: AgentEvent = serde_json::from_str(&json).unwrap();
            assert_eq!(event, deserialized);
        });
    }

    #[test]
    fn test_popup_definition_roundtrip() {
        proptest!(|(def in any_popup_definition())| {
            let json = serde_json::to_string(&def).unwrap();
            let deserialized: PopupDefinition = serde_json::from_str(&json).unwrap();
            assert_eq!(def, deserialized);
        });
    }

    #[test]
    fn test_popup_result_roundtrip() {
        proptest!(|(result in any_popup_result())| {
            let json = serde_json::to_string(&result).unwrap();
            let deserialized: PopupResult = serde_json::from_str(&json).unwrap();
            assert_eq!(result, deserialized);
        });
    }

    #[test]
    fn test_coordinator_status_roundtrip() {
        proptest!(|(status in any_coordinator_status())| {
            let json = serde_json::to_string(&status).unwrap();
            let deserialized: CoordinatorAgentStatus = serde_json::from_str(&json).unwrap();
            assert_eq!(status, deserialized);
        });
    }

    #[test]
    fn test_coordinator_agent_state_roundtrip() {
        proptest!(|(state in any_coordinator_agent_state())| {
            let json = serde_json::to_string(&state).unwrap();
            let deserialized: CoordinatorAgentState = serde_json::from_str(&json).unwrap();
            assert_eq!(state, deserialized);
        });
    }

    #[test]
    fn test_popup_request_roundtrip() {
        proptest!(|(req in any_popup_request())| {
            let json = serde_json::to_string(&req).unwrap();
            let deserialized: PopupRequest = serde_json::from_str(&json).unwrap();
            assert_eq!(req, deserialized);
        });
    }

    #[test]
    fn test_popup_response_roundtrip() {
        proptest!(|(res in any_popup_response())| {
            let json = serde_json::to_string(&res).unwrap();
            let deserialized: PopupResponse = serde_json::from_str(&json).unwrap();
            assert_eq!(res, deserialized);
        });
    }

    #[test]
    fn test_wizard_request_roundtrip() {
        proptest!(|(req in any_wizard_request())| {
            let json = serde_json::to_string(&req).unwrap();
            let deserialized: WizardRequest = serde_json::from_str(&json).unwrap();
            assert_eq!(req, deserialized);
        });
    }

    #[test]
    fn test_wizard_result_roundtrip() {
        proptest!(|(res in any_wizard_result())| {
            let json = serde_json::to_string(&res).unwrap();
            let deserialized: WizardResult = serde_json::from_str(&json).unwrap();
            assert_eq!(res, deserialized);
        });
    }

    #[test]
    fn test_state_update_roundtrip() {
        proptest!(|(update in any_state_update())| {
            let json = serde_json::to_string(&update).unwrap();
            let deserialized: StateUpdate = serde_json::from_str(&json).unwrap();
            assert_eq!(update, deserialized);
        });
    }

    #[test]
    fn test_transport_pipe_names_well_formed() {
        assert!(!transport::POPUP_PIPE.is_empty());
        assert!(transport::POPUP_PIPE.contains("exomonad:"));
        assert!(!transport::INJECT_INPUT_PIPE.is_empty());
        assert!(transport::INJECT_INPUT_PIPE.contains("exomonad:"));
    }
}
