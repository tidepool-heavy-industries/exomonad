# Configuration and Filesystem Audit

This document details the configuration files, filesystem paths, and loading mechanisms used by the ExoMonad system (Rust sidecar, Haskell runtime, and CLI tools).

**Audit Date:** 2026-02-03
**Scope:** Config files, secrets, sockets, worktrees, and log locations.

## 1. Configuration Files

### 1.1 Project Configuration (`.exo/config.toml`)

*   **Location:** Project root (`$PROJECT_ROOT/.exo/config.toml`)
*   **Purpose:** Defines the agent role and project context. Used by the Rust sidecar to determine which WASM plugin to load.
*   **Loaded By:** `rust/exomonad/src/config.rs`
*   **Schema:**
    ```toml
    # Role for hook/serve behavior (unified WASM handles all roles)
    role = "dev" | "tl" | "pm"

    # Base project directory for git operations (default: ".")
    project_dir = "..." 
    ```
*   **Validation:**
    *   Checks if `project_dir` exists and is a directory.
    *   Warns if `project_dir` is not a git repository.
    *   Validates that the corresponding WASM plugin exists at `.exo/wasm/`.

### 1.2 Secrets (`~/.exo/secrets`)

*   **Location:** User home (`~/.exo/secrets`)
*   **Purpose:** Stores sensitive API keys and tokens.
*   **Format:** KEY=VALUE (like `.env`)
*   **Loaded By:** `rust/exomonad-core/src/services/secrets.rs`
*   **Keys:**
    *   `GITHUB_TOKEN`: GitHub API token.
    *   `ANTHROPIC_API_KEY`: Anthropic API key.
*   **Precedence:** Environment variables override values in this file.
*   **Security:** **No file permission checks are currently performed.**

### 1.3 MCP Configuration

*   **Purpose:** Configures the Model Context Protocol (MCP) server for Claude Code / Gemini CLI.
*   **Managed By:** CLI-native config commands. Do not hand-edit `.mcp.json`.
*   **Setup:**
    ```bash
    # Claude Code
    claude mcp add exomonad -- exomonad mcp-stdio

    # Gemini CLI (HTTP mode only)
    gemini mcp add --transport http exomonad http://localhost:7432/mcp
    ```
*   Spawned agents get MCP config auto-generated by `write_agent_mcp_config()` pointing to the HTTP server.

### 1.4 Tool Hooks (`.claude/settings.local.json` / `.gemini/settings.json`)

*   **Location:** 
    *   Claude: `.claude/settings.local.json`
    *   Gemini: `.gemini/settings.json`
*   **Purpose:** Configures CLI hooks (e.g., `PreToolUse`, `SubagentStop`, `AfterAgent`).
*   **Managed By:** `rust/exomonad-core/src/services/agent_control.rs` writes these when spawning sub-agents.

## 2. Filesystem Paths

### 2.1 Runtime State (`.exo/`)

Located in the project root (or worktree root).

*   `sockets/`: Unix domain sockets.
    *   `control.sock`: Main control server (Haskell/Rust bridge).
    *   `tui.sock`: TUI sidebar connection.
    *   `service.sock`: (Legacy/Alternative) Sometimes referenced for LLM services.
*   `worktrees/`: Default location for spawned sub-agent worktrees.
    *   Format: `gh-{issue_id}-{slug}-{agent_type}/`
*   `sidecar.pid`: PID file for the running sidecar process.

### 2.2 Global State (`~/.exo/`)

Located in the user's home directory.

*   `secrets`: Global secrets file.
*   `wasm/`: Compiled WASM guest plugin.
    *   `wasm-guest-unified.wasm`
*   `logs/`: Log files.
    *   `sidecar-YYYY-MM-DD...log`

## 3. Configuration Loading Mechanisms

### 3.1 Rust (Sidecar & Runtime)

*   **Pattern:** Robust, centralized loading.
*   **Implementation:**
    *   `config.rs`: Loads `config.toml` using `serde` and `toml`.
    *   `secrets.rs`: Loads `secrets` file into a `HashMap`, with environment variable fallback.
*   **Validation:** Strong validation for `config.toml` (existence, directory checks). Weak validation for `secrets` (simple parsing).

### 3.2 Haskell (DSL & Effects)

*   **Pattern:** Injection / Environment-dependent.
*   **Implementation:**
    *   **No central config loading.**
    *   `ExoMonad.Env.Interpreter`: Direct wrapper around `System.Environment`.
    *   `ExoMonad.GitHub.Interpreter`: Config is passed in via `GitHubConfig` type. Defaults to hardcoded relative socket path `.exo/sockets/control.sock`.
    *   `ExoMonad.LLM.Interpreter`: Config passed via `LLMSocketConfig`.
*   **Secrets:** Haskell relies on the Rust sidecar to handle auth (via socket) OR expects secrets to be injected/present in ENV (if running in a context where it makes direct calls, though most calls go through sockets now).

## 4. Findings & Recommendations

### 4.1 Missing Validation
*   **Critical:** `~/.exo/secrets` is read without checking file permissions (e.g., ensuring 600).
*   **Config:** `config.toml` parsing failures might panic or bubble up ungracefully in some edge cases (though `anyhow` context is used).

### 4.2 Inconsistencies
*   **Rust vs Haskell:** Rust has a defined "Config" concept. Haskell treats config as "parameters passed to interpreters".
*   **Socket Paths:** Most Haskell interpreters default to `.exo/sockets/control.sock` relative to CWD. If the CWD is not the project root (e.g., inside a deep subdirectory), this will fail unless `EXOMONAD_CONTROL_SOCKET` env var is set.
*   **Hardcoded Fallbacks:**
    *   `rust/exomonad/src/main.rs`: defaults to `.exo/sockets/control.sock`.

### 4.3 Hardcoded Paths to Configurable
*   The default worktree directory `.exo/worktrees` is hardcoded in `agent_control.rs` (though customizable via API).
*   The WASM directory `.exo/wasm` is hardcoded in `config.rs`.

### 4.4 Recommendations
1.  **Implement Permission Check:** Add a check in `secrets.rs` to warn or fail if `~/.exo/secrets` is world-readable.
2.  **Standardize Socket Resolution:** Create a shared library (or consistent logic) for resolving socket paths that handles `ENV > Absolute Path > Relative to Git Root` (finding the git root instead of just CWD).
3.  **Haskell Config Module:** Consider creating a `ExoMonad.Config` module in Haskell that standardizes how environment variables and defaults are resolved, mirroring the Rust `config.rs` logic where applicable.
