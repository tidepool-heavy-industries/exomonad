# syntax=docker/dockerfile:1.4
# Haskell Build with BuildKit Cache Mounts
#
# Cache strategy:
#   - BuildKit cache mounts are GLOBAL to the builder (not per-stage)
#   - Same mount declared in multiple stages shares the same persistent volume
#   - Even if cabal files change, already-built deps are reused
#   - dist-newstyle cached for incremental builds of our own code

FROM haskell:9.12.2-slim-bookworm AS builder

RUN apt-get update && apt-get install -y \
    libgmp-dev \
    libffi-dev \
    zlib1g-dev \
    pkg-config \
    git \
    curl \
    && rm -rf /var/lib/apt/lists/*

WORKDIR /app

# Copy all source
COPY cabal.project ./
COPY haskell/ ./haskell/

# Remove Nix-specific zlib configuration (paths don't exist in Docker)
RUN sed -i '/package zlib/,+2d' cabal.project

# Version embedding
ARG GIT_SHA
ENV EXOMONAD_GIT_SHA=${GIT_SHA}

# Build with persistent cache mounts:
# - /root/.local/state/cabal/store: Compiled dependency store (most important)
# - /root/.cache/cabal: Package index and downloaded tarballs
# - /app/dist-newstyle: Local build artifacts (incremental compilation)
# sharing=locked prevents corruption during parallel builds
RUN --mount=type=cache,target=/root/.local/state/cabal/store,sharing=locked \
    --mount=type=cache,target=/root/.cache/cabal,sharing=locked \
    --mount=type=cache,target=/app/dist-newstyle,sharing=locked \
    cabal update && cabal build all -j --ghc-options=-O1

# Copy binary to known location (must happen outside cache mount)
RUN --mount=type=cache,target=/app/dist-newstyle,sharing=locked \
    mkdir -p /out && \
    binary=$(find dist-newstyle -name exomonad-control-server -type f -perm /111 | head -1) && \
    echo "Found binary at: $binary" && \
    test -n "$binary" && cp "$binary" /out/exomonad-control-server && \
    ls -la /out/
