syntax = "proto3";
package exomonad.effects.agent;

import "exomonad/common.proto";

// Agent control effects for spawning, monitoring, and cleanup.

// ============================================================================
// Common types
// ============================================================================

// Type of LLM agent.
enum AgentType {
  AGENT_TYPE_UNSPECIFIED = 0;
  AGENT_TYPE_CLAUDE = 1;
  AGENT_TYPE_GEMINI = 2;
}

// Agent execution status.
enum AgentStatus {
  AGENT_STATUS_UNSPECIFIED = 0;
  AGENT_STATUS_RUNNING = 1;
  AGENT_STATUS_STOPPED = 2;
  AGENT_STATUS_FAILED = 3;
  AGENT_STATUS_WAITING = 4;
}

// Topology of the workspace.
enum WorkspaceTopology {
  WORKSPACE_TOPOLOGY_UNSPECIFIED = 0;
  WORKSPACE_TOPOLOGY_WORKTREE_PER_AGENT = 1;
  WORKSPACE_TOPOLOGY_SHARED_DIR = 2;
}

// Information about a spawned agent.
message AgentInfo {
  // Unique identifier (issue number + agent type).
  string id = 1;
  // Issue number this agent is working on.
  string issue = 2;
  // Path to git worktree.
  string worktree_path = 3;
  // Git branch name.
  string branch_name = 4;
  // Agent type (Claude/Gemini).
  AgentType agent_type = 5;
  // Agent role (dev/tl/pm).
  exomonad.common.Role role = 6;
  // Current status.
  AgentStatus status = 7;
  // Zellij tab name (if running).
  string zellij_tab = 8;
  // Error message (if failed).
  string error = 9;
  // PR number if one was filed.
  int32 pr_number = 10;
  // PR URL if one was filed.
  string pr_url = 11;
  // Workspace topology.
  WorkspaceTopology topology = 12;
}

// ============================================================================
// Spawn - Spawn a single agent
// ============================================================================

message SpawnRequest {
  // GitHub issue number (e.g., "123").
  string issue = 1;
  // Repository owner.
  string owner = 2;
  // Repository name.
  string repo = 3;
  // Agent type (default: Claude).
  AgentType agent_type = 4;
  // Agent role (default: dev).
  exomonad.common.Role role = 5;
  // Base directory for worktrees (default: .exo/worktrees).
  string worktree_dir = 6;
  // Sub-repository path relative to project_dir (e.g., "urchin/").
  // When set, git worktree operations target this directory instead of project_dir.
  string subrepo = 7;
  // Workspace topology.
  WorkspaceTopology topology = 8;
  // Branch to create worktree from (default: main).
  string base_branch = 9;
  // Inline prompt context (alternative to issue body).
  string context = 10;
}

message SpawnResponse {
  AgentInfo agent = 1;
}

// ============================================================================
// SpawnBatch - Spawn multiple agents
// ============================================================================

message SpawnBatchRequest {
  // Issue numbers to spawn agents for.
  repeated string issues = 1;
  // Repository owner.
  string owner = 2;
  // Repository name.
  string repo = 3;
  // Agent type (default: Claude).
  AgentType agent_type = 4;
  // Agent role (default: dev).
  exomonad.common.Role role = 5;
  // Base directory for worktrees.
  string worktree_dir = 6;
  // Sub-repository path relative to project_dir (e.g., "urchin/").
  // When set, git worktree operations target this directory instead of project_dir.
  string subrepo = 7;
  // Workspace topology.
  WorkspaceTopology topology = 8;
}

message SpawnBatchResponse {
  // Successfully spawned agents.
  repeated AgentInfo agents = 1;
  // Errors for failed spawns (parallel to issues list).
  repeated string errors = 2;
}

// ============================================================================
// SpawnGeminiTeammate - Spawn a named Gemini teammate with a direct prompt (no GitHub issue)
// ============================================================================

message SpawnGeminiTeammateRequest {
  // Human-readable name (e.g., "mcp-hardener").
  string name = 1;
  // Initial prompt/instructions for the agent.
  string prompt = 2;
  // Agent type (default: Gemini).
  AgentType agent_type = 3;
  // Sub-repository path relative to project_dir (e.g., "urchin/").
  string subrepo = 4;
  reserved 5;
  reserved "team_name";
  // Workspace topology.
  WorkspaceTopology topology = 6;
  // Branch to create worktree from (default: current branch).
  string base_branch = 7;
}

message SpawnGeminiTeammateResponse {
  AgentInfo agent = 1;
}

// ============================================================================
// Cleanup - Clean up a single agent
// ============================================================================

message CleanupRequest {
  // Issue identifier to clean up.
  string issue = 1;
  // Force cleanup even with uncommitted changes.
  bool force = 2;
  // Sub-repository path relative to project_dir.
  string subrepo = 3;
}

message CleanupResponse {
  // True if cleanup succeeded.
  bool success = 1;
  // Error message if cleanup failed.
  string error = 2;
}

// ============================================================================
// CleanupBatch - Clean up multiple agents
// ============================================================================

message CleanupBatchRequest {
  // Issue identifiers to clean up.
  repeated string issues = 1;
  // Force cleanup even with uncommitted changes.
  bool force = 2;
  // Sub-repository path relative to project_dir.
  string subrepo = 3;
}

message CleanupBatchResponse {
  // Successfully cleaned up issue IDs.
  repeated string cleaned = 1;
  // Failed issue IDs.
  repeated string failed = 2;
  // Error messages (parallel to failed list).
  repeated string errors = 3;
}

// ============================================================================
// CleanupMerged - Clean up agents whose branches are merged
// ============================================================================

message CleanupMergedRequest {
  // Optional: only check specific issues.
  repeated string issues = 1;
  // Sub-repository path relative to project_dir.
  string subrepo = 2;
}

message CleanupMergedResponse {
  // Cleaned up issue IDs.
  repeated string cleaned = 1;
  // Issues that still have open branches.
  repeated string skipped = 2;
  // Error messages for failures.
  repeated string errors = 3;
}

// ============================================================================
// List - List active agents
// ============================================================================

message ListRequest {
  // Filter by status (optional).
  AgentStatus filter_status = 1;
  // Filter by role (optional).
  exomonad.common.Role filter_role = 2;
  // Sub-repository path relative to project_dir.
  string subrepo = 3;
}

message ListResponse {
  repeated AgentInfo agents = 1;
}

// ============================================================================
// SpawnWorker - Spawn a worker agent in the current worktree (no branch/worktree)
// ============================================================================

message SpawnWorkerRequest {
  // Human-readable name for the worker.
  string name = 1;
  // Implementation instructions for the agent.
  string prompt = 2;
  // Permission mode for the agent. Empty = --dangerously-skip-permissions.
  string permission_mode = 3;
  // Tool patterns to allow. Empty = no restriction.
  repeated string allowed_tools = 4;
  // Tool patterns to disallow. Empty = no restriction.
  repeated string disallowed_tools = 5;
}

message SpawnWorkerResponse {
  AgentInfo agent = 1;
}

message Permissions {
  repeated string allow = 1;
  repeated string deny = 2;
}

// ============================================================================
// SpawnSubtree - Spawn a subtree agent (Claude-only) in a new git worktree
// ============================================================================

message SpawnSubtreeRequest {
  // Full prompt/instructions (collapsed task+context).
  string task = 1;
  // Branch name suffix (e.g., "feature-a").
  string branch_name = 2;
  // Parent Claude session ID for --resume --fork-session context inheritance.
  string parent_session_id = 3;
  // Whether to fork the parent's Claude session context into the child.
  // Default false â€” child starts fresh. Set true to inherit conversation context.
  bool fork_session = 4;
  string role = 5;        // Optional role override (default: "tl")
  AgentType agent_type = 6; // Optional agent type override
  // Permission mode for Claude (e.g., "plan", "default"). Empty = --dangerously-skip-permissions.
  string permission_mode = 7;
  // Tool patterns to allow (e.g., "Read", "Grep"). Empty = no restriction.
  repeated string allowed_tools = 8;
  // Tool patterns to disallow (e.g., "Bash"). Empty = no restriction.
  repeated string disallowed_tools = 9;
  reserved 10, 11;
  reserved "secure_mode", "allowed_read_paths";
  string working_dir = 12;
  Permissions permissions = 13;
  // When true, creates a standalone git repo instead of a worktree.
  // The agent's .git boundary prevents traversal to the parent repository.
  bool standalone_repo = 14;
}

message SpawnSubtreeResponse {
  AgentInfo agent = 1;
}

// ============================================================================
// SpawnLeafSubtree - Spawn a Gemini leaf agent in a new git worktree
// ============================================================================

message SpawnLeafSubtreeRequest {
  // Full prompt/instructions (collapsed task+context).
  string task = 1;
  // Branch name suffix (e.g., "feature-a").
  string branch_name = 2;
  string role = 3;        // Optional role override (default: "dev")
  AgentType agent_type = 4; // Optional agent type override
  // Permission mode for the agent. Empty = --dangerously-skip-permissions.
  string permission_mode = 5;
  // Tool patterns to allow. Empty = no restriction.
  repeated string allowed_tools = 6;
  // Tool patterns to disallow. Empty = no restriction.
  repeated string disallowed_tools = 7;
  reserved 8, 9;
  reserved "secure_mode", "allowed_read_paths";
  // When true, creates a standalone git repo instead of a worktree.
  bool standalone_repo = 10;
}

message SpawnLeafSubtreeResponse {
  AgentInfo agent = 1;
}

// ============================================================================
// SpawnAcp - Spawn a Gemini agent via ACP (headless, no Zellij)
// ============================================================================

message SpawnAcpRequest {
  // Human-readable name for the agent.
  string name = 1;
  // Initial prompt/instructions for the agent.
  string prompt = 2;
  // Permission mode for the agent. Empty = --dangerously-skip-permissions.
  string permission_mode = 3;
  // Tool patterns to allow. Empty = no restriction.
  repeated string allowed_tools = 4;
  // Tool patterns to disallow. Empty = no restriction.
  repeated string disallowed_tools = 5;
}

message SpawnAcpResponse {
  AgentInfo agent = 1;
}

// ============================================================================
// Service definition
// ============================================================================

service AgentEffects {
  rpc Spawn(SpawnRequest) returns (SpawnResponse);
  rpc SpawnBatch(SpawnBatchRequest) returns (SpawnBatchResponse);
  rpc SpawnGeminiTeammate(SpawnGeminiTeammateRequest) returns (SpawnGeminiTeammateResponse);
  rpc SpawnWorker(SpawnWorkerRequest) returns (SpawnWorkerResponse);
  rpc SpawnSubtree(SpawnSubtreeRequest) returns (SpawnSubtreeResponse);
  rpc SpawnLeafSubtree(SpawnLeafSubtreeRequest) returns (SpawnLeafSubtreeResponse);
  rpc SpawnAcp(SpawnAcpRequest) returns (SpawnAcpResponse);
  rpc Cleanup(CleanupRequest) returns (CleanupResponse);
  rpc CleanupBatch(CleanupBatchRequest) returns (CleanupBatchResponse);
  rpc CleanupMerged(CleanupMergedRequest) returns (CleanupMergedResponse);
  rpc List(ListRequest) returns (ListResponse);
}
