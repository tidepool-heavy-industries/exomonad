You are writing integration tests for a Haskell Servant webserver.

## Your Task

Implement all property tests in the test skeleton using servant-client.

## Module: {{ moduleName }}

## Data Type Definition

```haskell
{{ dataType }}
```

## Available Client Functions

The test skeleton includes generated client functions:
{% for sig in signatures %}
- `{{ sig.name | replace("Handler", "Client") }}` - calls {{ sig.description | lower }}
{% endfor %}

## Instructions

1. **Find the test file**: Look for `test/Main.hs`

2. **Implement each `spec_*` function**:
   - Replace `pendingWith "..."` with actual test logic
   - Use `runClient env (clientFunction args)` to make HTTP calls
   - Use HSpec expectations: `shouldBe`, `shouldSatisfy`, `shouldReturn`

3. **Test patterns**:
   ```haskell
   -- Basic roundtrip test
   spec_roundtrip env = do
     shortUrl <- runClient env (shortenClient (ShortenRequest "https://example.com"))
     expanded <- runClient env (expandClient (suCode shortUrl))
     erUrl expanded `shouldBe` "https://example.com"

   -- Error case test (expect failure)
   spec_not_found env = do
     result <- runClientM (expandClient "invalid-code") env
     result `shouldSatisfy` isLeft

   -- Property with QuickCheck
   spec_idempotent env = property $ \url -> ioProperty $ do
     r1 <- runClient env (shortenClient (ShortenRequest url))
     r2 <- runClient env (shortenClient (ShortenRequest url))
     pure (suCode r1 == suCode r2)
   ```

4. **Build and verify**: Run `cabal build test-suite` and `cabal test`

## Acceptance Criteria to Test

{% for priority in testPriorities %}
- **{{ priority.name }}**: {{ priority.description }}
{% endfor %}

## Output Format

After implementing, report your results with per-function rubrics.

**Important:** Do NOT report build status - the handler verifies that mechanically.

### Required Fields

- `trFunctionRubrics`: One rubric per function you tested (see below)
- `trCommitMessage`: Descriptive commit message for your changes
- `trTestingStrategy`: Brief notes on testing approach
- `trBlocker`: Structured blocker info or null

### Per-Function Test Rubric

For EACH function tested, provide:
- `tfrFunctionName`: Which function this is for
- `tfrPropertiesWritten`: Descriptions of what each property tests (list of strings)
- `tfrApproach`: Testing approach used (property-based | example-based | integration | golden | mixed)
- `tfrScenariosNotTested`: What scenarios did you consciously NOT test? (list, or empty)
- `tfrAssumptionsMade`: What did you assume about the implementation? (list, or empty)

### Blocker Structure (if blocked)

- `blCategory`: "dependency" | "tooling" | "spec-unclear" | "type-system" | "environment" | "other"
- `blDescription`: What's the blocker?
- `blAttemptedSolutions`: What did you try? (list of strings)
- `blWouldUnblock`: What would resolve this?
