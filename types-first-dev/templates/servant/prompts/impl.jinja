You are implementing a Haskell Servant webserver.

## Your Task

Implement all handler functions in the server skeleton.

## Module: {{ moduleName }}

## Data Type Definition

```haskell
{{ dataType }}
```

## Handler Signatures to Implement

{% for sig in signatures %}
- `{{ sig.name }} :: IORef AppState -> {{ sig.signature }}`
  - {{ sig.description }}
{% endfor %}

## Instructions

1. **Find the skeleton file**: Look for `src/{{ moduleName | replace(".", "/") }}.hs`

2. **Implement each handler**: Replace `undefined` with working code
   - Each handler has access to `IORef AppState` for state management
   - Use `liftIO` to run IO actions inside Handler
   - Use `throwError` to return HTTP errors (e.g., `err404`)

3. **Common patterns**:
   ```haskell
   -- Read state
   state <- liftIO $ readIORef ref

   -- Modify state
   liftIO $ modifyIORef' ref $ \s -> s { asUrls = Map.insert code url (asUrls s) }

   -- Return 404
   case Map.lookup code (asUrls state) of
     Nothing -> throwError err404
     Just url -> pure url
   ```

4. **Build and verify**: Run `cabal build` to ensure it compiles

## Output Format

After implementing, report your results with per-function rubrics.

**Important:** Do NOT report build status - the handler verifies that mechanically.

### Required Fields

- `irFunctionRubrics`: One rubric per function you implemented (see below)
- `irCommitMessage`: Descriptive commit message for your changes
- `irDesignNotes`: Brief notes on implementation choices
- `irBlocker`: Structured blocker info or null

### Per-Function Rubric

For EACH function, provide:
- `frFunctionName`: Which function this is for
- `frApproach`: How did you implement it? (recursion | fold | unfold | pattern-match | library | lens | state-monad | other)
- `frOpenQuestions`: What are you unsure about? (list each, or empty array if confident)
- `frUnhandledCases`: What inputs/scenarios does this NOT handle? (list each, or empty if complete)
- `frBoundaryReasoning`: For edge cases you considered (array of objects):
  - `bnCase`: Which boundary (empty-input, invalid-url, missing-key, concurrent-access, etc.)
  - `bnIntendedBehavior`: What should happen and why

### Blocker Structure (if blocked)

- `blCategory`: "dependency" | "tooling" | "spec-unclear" | "type-system" | "environment" | "other"
- `blDescription`: What's the blocker?
- `blAttemptedSolutions`: What did you try? (list of strings)
- `blWouldUnblock`: What would resolve this?
