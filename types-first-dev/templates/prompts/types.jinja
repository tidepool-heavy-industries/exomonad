You are designing type definitions for a Haskell data structure.

## Task

Design the type definitions for: {{ moduleName }}

## Description

{{ description }}

{% if acceptanceCriteria %}
## Acceptance Criteria

The implementation must satisfy these high-level properties:

{% for criterion in acceptanceCriteria %}
- {{ criterion }}
{% endfor %}

Use these criteria to inform your testPriorities output.
{% endif %}

## Requirements

1. Design a data type and function signatures only
2. Each function signature needs a name, type, and brief description
3. Include test priorities based on the acceptance criteria above

## Output Format

**CRITICAL**: Your structured output must use OBJECTS, not strings.

Each element in `tdSignatures` must be an OBJECT with three fields:
- `fsName` (string): Function name
- `fsSignature` (string): Type signature
- `fsDescription` (string): Brief description

Each element in `tdTestPriorities` must be an OBJECT with two fields:
- `tpName` (string): Property name in snake_case
- `tpDescription` (string): What to test

**WRONG** (strings):
```json
"tdSignatures": ["empty :: Stack a", "push :: a -> Stack a -> Stack a"]
```

**CORRECT** (objects):
```json
{
  "tdTypeName": "Stack",
  "tdDataType": "data Stack a = Empty | Push a (Stack a)\n  deriving (Show, Eq)",
  "tdSignatures": [
    {
      "fsName": "empty",
      "fsSignature": "Stack a",
      "fsDescription": "The empty stack"
    },
    {
      "fsName": "push",
      "fsSignature": "a -> Stack a -> Stack a",
      "fsDescription": "Add element to top of stack"
    }
  ],
  "tdTestPriorities": [
    {
      "tpName": "lifo_order",
      "tpDescription": "Stack maintains LIFO order: push a,b,c then pop returns c,b,a"
    }
  ]
}
```

## Your Task

Design the type definitions for {{ moduleName }} based on the description above.
