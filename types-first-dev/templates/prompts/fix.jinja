You are fixing a Haskell implementation that has failing tests.

## Module: {{ moduleName }}

## Current Implementation

Read the implementation at: `{{ implPath }}`

Your task is to analyze the test failures below and modify the implementation to make the tests pass.

## Test Failures

{% for failure in failures %}
### {{ failure.tfPropertyName }} FAILED

**Message:** {{ failure.tfMessage }}

{% if failure.tfCounterexample %}
**Counterexample:**
```
{{ failure.tfCounterexample }}
```
{% endif %}

{% if failure.tfSeed %}
**QuickCheck seed:** {{ failure.tfSeed }} (use `--seed {{ failure.tfSeed }}` to reproduce)
{% endif %}

{% if failure.tfLocation %}
**Location:** {{ failure.tfLocation }}
{% endif %}

---
{% endfor %}

## Your Task

1. **Read** the implementation file at `{{ implPath }}`
2. **Analyze** each test failure above:
   - What is the test checking?
   - Why is the implementation failing?
   - What needs to change?
3. **Edit** the implementation file to fix the issues
4. **Run** `cabal build` to verify your changes compile
5. **Return** your result in structured output

## Important Notes

- Focus on the **specific failures** listed above
- Each counterexample shows an input where your implementation produces wrong output
- Make minimal changes needed to fix the tests
- DO NOT change the test file - only modify the implementation
- DO NOT change function signatures or data types

## Attempt {{ attempt }}

{% if attempt > 1 %}
This is attempt {{ attempt }} of fixing the implementation.

Previous fix attempts did not resolve all failures. The failures above are what remain.

**Strategy tips for retry:**
- Re-read the failing test properties carefully
- Consider edge cases in the counterexamples
- Check if you're handling base cases correctly
- Verify recursion terminates properly
{% endif %}

## Structured Output

You report what you did; the controller decides if it's good enough.

**Important:** Do NOT report build status - the handler verifies that mechanically.

### Required Fields

- `fixFunctionRubrics`: One rubric per function you fixed (see below)
- `fixChangesMade`: Array of strings - what you changed (brief descriptions)
- `fixCommitMessage`: Git commit message (50 chars max, imperative mood)
- `fixBlocker`: If blocked, provide structured info (null if successful)

### Per-Function Rubric

For EACH function you modified, provide a rubric with:
- `frFunctionName`: Which function this is for
- `frApproach`: How did you implement it? (recursion | fold | unfold | pattern-match | library | lens | state-monad | other)
- `frOpenQuestions`: What are you unsure about? (list each, or empty array if confident)
- `frUnhandledCases`: What inputs/scenarios does this NOT handle? (list each, or empty if complete)
- `frBoundaryReasoning`: For edge cases you considered (array of objects):
  - `bnCase`: Which boundary (empty-input, single-element, negative, overflow, etc.)
  - `bnIntendedBehavior`: What should happen and why

### Blocker Structure (if blocked)

- `blCategory`: "dependency" | "tooling" | "spec-unclear" | "type-system" | "environment" | "other"
- `blDescription`: What's the blocker?
- `blAttemptedSolutions`: What did you try? (list of strings)
- `blWouldUnblock`: What would resolve this?
