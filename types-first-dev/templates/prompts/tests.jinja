You are writing QuickCheck property tests for a Haskell data structure.

## Task

Create property tests for: {{ moduleName }}

A skeleton test file already exists at `test/Main.hs` with placeholder stubs.
Your job is to **edit that file** and replace the placeholders with real QuickCheck properties.

## Type Definitions

The data type to test:

```haskell
{{ dataType }}
```

The function signatures to test:

{% for sig in signatures %}
- `{{ sig.name }} :: {{ sig.signature }}` â€” {{ sig.description }}
{% endfor %}

## Instructions

1. **Read** the skeleton file at `test/Main.hs`
   (You do NOT need to read the implementation - all type info is above)
2. **Edit** the file to replace placeholder properties with real QuickCheck tests
3. **Verify** the test suite compiles: `cabal build test-repo-test`
   (Do NOT use `cabal build all` - it doesn't build tests by default)
4. Return result metadata in structured output (NOT the code - it's already in the file)

## Requirements

- Write QuickCheck property tests for all functions
- Use meaningful property names (prop_*)
- Define Arbitrary instances if needed
- Focus on algebraic properties (identity, associativity, LIFO order, etc.)
- Include a main function that runs all properties
- **Type annotations**: When using polymorphic values like `empty`, add explicit types: `(empty :: Stack Int)` to avoid ambiguous type errors

## Example Properties

For a Stack type, good properties might be:

- `prop_pushPop`: push x then pop returns x
- `prop_emptyIsEmpty`: isEmpty empty == True
- `prop_pushNotEmpty`: isEmpty (push x s) == False
- `prop_peekAfterPush`: peek (push x s) == Just x

## Structured Output

Your structured output describes your work - the handler will commit your file edits.
You report what you did; the controller decides if it's good enough.

**Important:** Do NOT report build status - the handler verifies that mechanically.

### Required Fields

- `trFunctionRubrics`: One rubric per function you wrote tests for (see below)
- `trCommitMessage`: Short commit message (50 chars, imperative mood)
- `trTestingStrategy`: Explain your testing approach and properties written
- `trBlocker`: If blocked, provide structured info (null if successful)

### Per-Function Test Rubric

For EACH function you tested, provide a rubric with:
- `tfrFunctionName`: Which function this is for
- `tfrPropertiesWritten`: Descriptions of what each property tests (list of strings)
- `tfrApproach`: Testing approach used (property-based | example-based | integration | golden | mixed)
- `tfrScenariosNotTested`: What scenarios did you consciously NOT test? (list, or empty)
- `tfrAssumptionsMade`: What did you assume about the implementation? (list, or empty)

### Blocker Structure (if blocked)

- `blCategory`: "dependency" | "tooling" | "spec-unclear" | "type-system" | "environment" | "other"
- `blDescription`: What's the blocker?
- `blAttemptedSolutions`: What did you try? (list of strings)
- `blWouldUnblock`: What would resolve this?

## Your Task

Edit `test/Main.hs` to create comprehensive property tests for {{ moduleName }}.
