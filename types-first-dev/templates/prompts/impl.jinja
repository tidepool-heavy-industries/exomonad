You are implementing a Haskell data structure.

## Task

Implement the functions for: {{ moduleName }}

A skeleton file already exists at `src/{{ moduleName | replace(".", "/") }}.hs` with `undefined` stubs.
Your job is to **edit that file** and replace the `undefined` stubs with real implementations.

## Type Definitions

The data type:

```haskell
{{ dataType }}
```

The function signatures to implement:

{% for sig in signatures %}
- `{{ sig.name }} :: {{ sig.signature }}` â€” {{ sig.description }}
{% endfor %}

## Instructions

1. **Read** the skeleton file at `src/{{ moduleName | replace(".", "/") }}.hs`
2. **Edit** the file to replace each `undefined` with a working implementation
3. **Verify** the library compiles: `cabal build test-repo`
4. Return result metadata in structured output (NOT the code - it's already in the file)

## Requirements

- Each function MUST match its type signature exactly
- Use idiomatic Haskell patterns
- Keep implementations simple and correct
- Do NOT change the module header or exports

## Structured Output

Your structured output describes your work - the handler will commit your file edits.
You report what you did; the controller decides if it's good enough.

**Important:** Do NOT report build status - the handler verifies that mechanically.

### Required Fields

- `irFunctionRubrics`: One rubric per function you implemented (see below)
- `irCommitMessage`: Short commit message (50 chars, imperative mood)
- `irDesignNotes`: Explain your design choices and tradeoffs
- `irBlocker`: If blocked, provide structured info (null if successful)

### Per-Function Rubric

For EACH function, provide a rubric with:
- `frFunctionName`: Which function this is for
- `frApproach`: How did you implement it? (recursion | fold | unfold | pattern-match | library | lens | state-monad | other)
- `frOpenQuestions`: What are you unsure about? (list each, or empty array if confident)
- `frUnhandledCases`: What inputs/scenarios does this NOT handle? (list each, or empty if complete)
- `frBoundaryReasoning`: For edge cases you considered (array of objects):
  - `bnCase`: Which boundary (empty-input, single-element, negative, overflow, etc.)
  - `bnIntendedBehavior`: What should happen and why

### Blocker Structure (if blocked)

- `blCategory`: "dependency" | "tooling" | "spec-unclear" | "type-system" | "environment" | "other"
- `blDescription`: What's the blocker?
- `blAttemptedSolutions`: What did you try? (list of strings)
- `blWouldUnblock`: What would resolve this?

## Your Task

Edit `src/{{ moduleName | replace(".", "/") }}.hs` to implement all functions for {{ moduleName }}.
