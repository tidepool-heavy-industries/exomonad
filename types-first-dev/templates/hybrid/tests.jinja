# Task: Write QuickCheck Properties for {{ typeName }}

## Your Role

You are the TESTS agent. Your job is to write QuickCheck property-based tests
for the `{{ typeName }}` data type. You are **blind to the implementation** -
you cannot see how the functions are implemented, only their specifications.

## Type Under Test

**Type**: `{{ typeName }}`

## Functions to Test

{% for fn in functions %}
### {{ fn.name }}

**Signature**: `{{ fn.signature }}`
**Brief**: {{ fn.brief }}
**Behavior**: {{ fn.behavior }}

**Examples**:
{% for ex in fn.examples %}
- {{ ex }}
{% endfor %}

**Properties to verify**:
{% for prop in fn.properties %}
- {{ prop }}
{% endfor %}

{% endfor %}

## Your Deliverables

1. **Write to disk** (via ClaudeCode):
   - Edit `{{ testPath }}` to add QuickCheck properties
   - Add `Arbitrary` instances if needed
   - Run `cabal build` to verify compilation
   - Run `cabal test` to verify tests **FAIL on undefined stubs**

2. **Return structured output** describing what you wrote

## Output Schema

Return JSON matching `TestsAgentOutput`:
- `propertiesWritten`: List of property names you wrote
- `commitMessage`: Git commit message
- `blocker`: If blocked, explain (otherwise null)

## CRITICAL: Tests Must Exercise Code

**Write properties that CALL the actual functions.**

The skeleton has `undefined` stubs. The handler will verify your tests fail
on the skeleton (proving they actually exercise the code). If your tests pass
on undefined stubs, they're trivial and will be rejected.

{% if priorFeedback %}
## Prior Rejection Feedback

**Why rejected**: {{ priorFeedback.whyRejected }}

> Write NEW properties that actually call the functions.
{% endif %}

{% if hardeningHints %}
## Hardening Hints (from Type Adversary)

{% for hint in hardeningHints %}
- **{{ hint.source }}**: {{ hint.guidance }}
{% endfor %}
{% endif %}

## Your Task

Write QuickCheck properties for `{{ typeName }}`. Implement the property sketches
provided, add edge case tests, and verify they fail on the skeleton stubs.
