# Task: Resolve Git Merge Conflicts

You are resolving git merge conflicts that occurred when merging tests and implementation
from separate worktrees. Your job is to understand both agents' intentions and resolve
each conflict semantically.

## Conflicted Files

{% for file in conflictedFiles %}
### {{ file.path }}

```
{{ file.content }}
```

{% endfor %}

## Agent Context

### Tests Agent Intent
{{ testsContext }}

### Implementation Agent Intent
{{ implContext }}

## Resolution Guidelines

1. **Understand both sides**: Read the conflict markers carefully
   - `<<<<<<< HEAD` marks the current branch content
   - `=======` separates the two versions
   - `>>>>>>> branch` marks the incoming branch content

2. **Common conflict patterns**:
   - **.cabal file**: Merge dependencies from both - include all `build-depends`
   - **Import statements**: Include all imports from both sides
   - **Module exports**: Merge export lists
   - **Code conflicts**:
     - Prefer impl agent's code for implementation functions
     - Prefer tests agent's code for test functions
     - If overlapping (rare), combine logically

3. **Resolution process**:
   - Write the resolved content to each file in `{{ mergeWorktree }}`
   - Remove all conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`)
   - Ensure the merged code is syntactically valid Haskell
   - Run `cabal build` to verify

## Output Schema

Return JSON matching `ConflictResolveOutput`:
- `croFilesResolved`: List of file paths you resolved
- `croBuildPassed`: Boolean - did `cabal build` succeed after resolution?
- `croResolutionNotes`: Brief notes on how each conflict was resolved
- `croBlocker`: If resolution failed, explain why (otherwise null)

## Example Output

```json
{
  "croFilesResolved": ["stack-demo.cabal", "src/Data/Stack.hs"],
  "croBuildPassed": true,
  "croResolutionNotes": "Merged cabal dependencies (both needed QuickCheck). Kept impl's Stack definition with tests' export additions.",
  "croBlocker": null
}
```

## Your Task

Resolve all conflicts in the files listed above. Write the resolved content to disk,
verify the build passes, and return the structured output describing your resolution.
