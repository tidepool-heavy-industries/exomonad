{-# LANGUAGE DataKinds #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE TypeOperators #-}

-- | Example graph demonstrating multi-node branching with effects.
--
-- This graph implements a message classifier that:
-- 1. Takes a user message
-- 2. Classifies it into Greeting, Question, or Statement
-- 3. Routes to the appropriate handler
-- 4. Each handler generates a response
--
-- Structure:
--   Entry(UserMessage) -> classify -> handleGreeting -+
--                                  |                  |
--                                  +-> handleQuestion +-> Exit(Response)
--                                  |                  |
--                                  +-> handleStatement+
--
-- This exercises:
-- - Branching via GotoChoice with 3+ targets
-- - Multiple logic nodes with real implementations
-- - Effect yields (Log, LlmComplete) at different points
-- - Newtypes for domain concepts
module Tidepool.Wasm.ExampleGraph
  ( -- * Domain Types
    UserMessage(..)
  , Classification(..)
  , Response(..)

    -- * Graph Type
  , ExampleGraph(..)

    -- * WASM Handlers
  , classifyHandlerWasm
  , greetingHandlerWasm
  , questionHandlerWasm
  , statementHandlerWasm

    -- * Entry Point
  , runExampleGraph
  ) where

import Data.Aeson (Value(..))
import qualified Data.Text as T
import Data.Text (Text)
import GHC.Generics (Generic)

import Tidepool.Graph.Types (type (:@), Needs, UsesEffects, Exit, Self)
import Tidepool.Graph.Generic (GraphMode(..), type (:-))
import qualified Tidepool.Graph.Generic as G (Entry, Exit, LogicNode)
import Tidepool.Graph.Goto (Goto, GotoChoice(..), OneOf(..), To, gotoChoice, gotoExit, gotoSelf)

import Tidepool.Wasm.Effect (WasmM, logInfo, logError, llmComplete)


-- ============================================================================
-- Domain Types (newtypes for type safety)
-- ============================================================================

-- | A message from the user to be classified.
newtype UserMessage = UserMessage { unUserMessage :: Text }
  deriving stock (Show, Eq, Generic)

-- | Classification result from the classifier.
data Classification
  = Greeting      -- ^ A hello/goodbye/greeting message
  | Question      -- ^ A question (ends with ? or starts with interrogative)
  | Statement     -- ^ A statement/declarative message
  deriving stock (Show, Eq, Generic)

-- | Response generated by a handler.
newtype Response = Response { unResponse :: Text }
  deriving stock (Show, Eq, Generic)


-- ============================================================================
-- Graph Definition
-- ============================================================================

-- | Message classifier graph with branching.
--
-- The classify node determines which handler to use:
-- - Greeting -> handleGreeting
-- - Question -> handleQuestion
-- - Statement -> handleStatement
--
-- Each handler returns directly to Exit with a Response.
data ExampleGraph mode = ExampleGraph
  { entry           :: mode :- G.Entry UserMessage
  , classify        :: mode :- G.LogicNode
                           :@ Needs '[UserMessage]
                           :@ UsesEffects '[Goto "handleGreeting" UserMessage
                                          , Goto "handleQuestion" UserMessage
                                          , Goto "handleStatement" UserMessage]
  , handleGreeting  :: mode :- G.LogicNode
                           :@ Needs '[UserMessage]
                           :@ UsesEffects '[Goto Exit Response]
  , handleQuestion  :: mode :- G.LogicNode
                           :@ Needs '[UserMessage]
                           :@ UsesEffects '[Goto Exit Response, Goto Self UserMessage]
  , handleStatement :: mode :- G.LogicNode
                           :@ Needs '[UserMessage]
                           :@ UsesEffects '[Goto Exit Response]
  , exit            :: mode :- G.Exit Response
  }
  deriving Generic


-- ============================================================================
-- Classification Logic
-- ============================================================================

-- | Classify a message based on simple heuristics.
--
-- In a real system this would use an LLM, but for testing we use
-- pattern matching to ensure deterministic behavior.
classifyMessage :: Text -> Classification
classifyMessage msg
  | isGreeting = Greeting
  | isQuestion = Question
  | otherwise  = Statement
  where
    lower = T.toLower msg

    isGreeting =
      any (`T.isPrefixOf` lower) ["hello", "hi ", "hi!", "hey", "good morning", "good afternoon", "good evening", "goodbye", "bye", "greetings"]
      || lower == "hi"

    isQuestion =
      "?" `T.isSuffixOf` T.strip msg
      || any (`T.isPrefixOf` lower) ["what", "who", "where", "when", "why", "how", "is ", "are ", "can ", "could ", "would ", "should ", "do ", "does ", "did "]


-- ============================================================================
-- WASM Handlers
-- ============================================================================

-- | Classify handler - determines which handler to route to.
--
-- This handler:
-- 1. Logs the incoming message
-- 2. Classifies it using heuristics
-- 3. Returns a GotoChoice pointing to the appropriate handler
classifyHandlerWasm
  :: UserMessage
  -> WasmM (GotoChoice '[To "handleGreeting" UserMessage
                       , To "handleQuestion" UserMessage
                       , To "handleStatement" UserMessage])
classifyHandlerWasm msg = do
  logInfo $ "Classifying message: " <> msg.unUserMessage
  let classification = classifyMessage msg.unUserMessage
  logInfo $ "Classification result: " <> T.pack (show classification)
  pure $ case classification of
    Greeting  -> gotoChoice @"handleGreeting" msg
    Question  -> gotoChoice @"handleQuestion" msg
    Statement -> gotoChoice @"handleStatement" msg


-- | Greeting handler - responds to greetings.
--
-- This handler:
-- 1. Logs that it's handling a greeting
-- 2. Generates a friendly response
-- 3. Returns Exit with the response
greetingHandlerWasm
  :: UserMessage
  -> WasmM (GotoChoice '[To Exit Response])
greetingHandlerWasm msg = do
  logInfo $ "Handling greeting: " <> msg.unUserMessage
  let response = Response $ "Hello! It's nice to hear from you. You said: \"" <> msg.unUserMessage <> "\""
  pure $ gotoExit response


-- | Question handler - responds to questions.
--
-- This handler demonstrates:
-- 1. More complex logic with multiple yields
-- 2. Use of llmComplete effect to generate an answer
-- 3. Self-loop capability (though not used in normal flow)
questionHandlerWasm
  :: UserMessage
  -> WasmM (GotoChoice '[To Exit Response, To Self UserMessage])
questionHandlerWasm msg = do
  logInfo $ "Handling question: " <> msg.unUserMessage

  -- Use LLM to generate a thoughtful response
  -- In tests, this will yield to TypeScript which can mock the response
  llmResult <- llmComplete
    "question_handler"
    "You are a helpful assistant. Answer the user's question concisely."
    msg.unUserMessage
    Nothing  -- No schema, free-form response

  -- Extract the response text from the LLM result
  let responseText = case llmResult of
        String t -> t
        _        -> "I'm thinking about that question: \"" <> msg.unUserMessage <> "\""

  logInfo $ "Generated answer for question"
  pure $ gotoExit (Response responseText)


-- | Statement handler - responds to statements.
--
-- This handler:
-- 1. Logs the statement
-- 2. Acknowledges it with a simple response
-- 3. Returns Exit
statementHandlerWasm
  :: UserMessage
  -> WasmM (GotoChoice '[To Exit Response])
statementHandlerWasm msg = do
  logInfo $ "Handling statement: " <> msg.unUserMessage
  let response = Response $ "I understand. You mentioned: \"" <> msg.unUserMessage <> "\""
  pure $ gotoExit response


-- ============================================================================
-- Graph Execution Entry Point
-- ============================================================================

-- | The full set of choices for the classify node.
type ClassifyTargets =
  '[To "handleGreeting" UserMessage
  , To "handleQuestion" UserMessage
  , To "handleStatement" UserMessage]

-- | The full set of choices for question handler (includes Self for retry).
type QuestionTargets =
  '[To Exit Response
  , To Self UserMessage]

-- | The full set of choices for greeting/statement handlers.
type SimpleExitTargets =
  '[To Exit Response]

-- | Run the example graph from entry to exit.
--
-- This function orchestrates the full graph execution:
-- 1. Classify the input message
-- 2. Dispatch to the appropriate handler
-- 3. Return the final response
--
-- Note: The Self-loop in questionHandler is not exercised here since
-- we always exit on first pass. A more complex graph could use Self
-- for retry logic.
runExampleGraph :: UserMessage -> WasmM Response
runExampleGraph msg = do
  -- Step 1: Classify
  classifyResult <- classifyHandlerWasm msg

  -- Step 2: Dispatch based on classification
  dispatchClassify classifyResult
  where
    dispatchClassify :: GotoChoice ClassifyTargets -> WasmM Response
    dispatchClassify = dispatchFromOneOf

    dispatchFromOneOf :: GotoChoice ClassifyTargets -> WasmM Response
    dispatchFromOneOf (GotoChoice oneOf) = case oneOf of
      -- Here = handleGreeting
      Here payload -> do
        result <- greetingHandlerWasm payload
        dispatchSimpleExit result

      -- There (Here _) = handleQuestion
      There (Here payload) -> do
        result <- questionHandlerWasm payload
        dispatchQuestionResult result

      -- There (There (Here _)) = handleStatement
      There (There (Here payload)) -> do
        result <- statementHandlerWasm payload
        dispatchSimpleExit result

    dispatchSimpleExit :: GotoChoice SimpleExitTargets -> WasmM Response
    dispatchSimpleExit (GotoChoice (Here response)) = pure response

    dispatchQuestionResult :: GotoChoice QuestionTargets -> WasmM Response
    dispatchQuestionResult (GotoChoice oneOf) = case oneOf of
      Here response -> pure response
      There (Here payload) -> do
        -- Self-loop: retry with the same message
        logInfo "Question handler requested retry (Self-loop)"
        result <- questionHandlerWasm payload
        dispatchQuestionResult result
