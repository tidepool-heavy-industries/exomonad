{-# LANGUAGE OverloadedStrings #-}

-- | TypeScript package codegen for Tidepool graphs.
--
-- This module provides pure functions for generating TypeScript source files
-- from graph specifications. The generated package is a self-contained npm
-- package that can be consumed by deploy/ or any other TypeScript project.
--
-- = Generated Files
--
-- * @graphs.ts@ - GraphId union type and graphRegistry with metadata
-- * @exports.ts@ - GraphWasmExports interface matching WASM FFI
-- * @dispatcher.ts@ - Type-safe getGraphFns() dispatcher
-- * @index.ts@ - Re-exports for clean public API
-- * @package.json@ - npm package manifest
-- * @tsconfig.json@ - TypeScript configuration
--
-- = Usage
--
-- > cabal run generate-ts-package -- ./output
--
-- This generates a complete npm package in ./output that can be:
--
-- 1. Linked locally: @npm link ../tidepool-generated-ts/output@
-- 2. Published to npm: @cd output && npm publish@
-- 3. Used as file dependency: @"tidepool-generated-ts": "file:../output"@
module Tidepool.Generated.Codegen
  ( -- * Graph Specification
    GraphSpec(..)

    -- * Effect Specification
  , EffectSpec(..)

    -- * TypeScript Generation
  , generateGraphsTs
  , generateExportsTs
  , generateDispatcherTs
  , generateRoutingTs
  , generateIndexTs

    -- * Package Configuration
  , generatePackageJson
  , generateTsConfig
  ) where

import Data.Text (Text)
import qualified Data.Text as T


-- ============================================================================
-- Graph Specification
-- ============================================================================

-- | Runtime graph metadata for codegen (mirrors GraphFFISpec without TH Names).
data GraphSpec = GraphSpec
  { gsId    :: Text              -- ^ Short ID (e.g., "test", "example", "habitica")
  , gsName  :: Text              -- ^ Full graph name (e.g., "TestGraph")
  , gsNodes :: [Text]            -- ^ Node names
  , gsEdges :: [(Text, Text)]    -- ^ Edges as (from, to) pairs
  }
  deriving (Show, Eq)


-- ============================================================================
-- Effect Specification
-- ============================================================================

-- | Effect metadata for routing codegen.
--
-- Defines how each effect type should be routed:
-- - Internal effects are handled by StateMachineDO (LLM, Habitica, Log)
-- - Yielded effects are sent back to the caller (Telegram effects)
data EffectSpec = EffectSpec
  { esType      :: Text          -- ^ Effect type name (e.g., "LogInfo", "LlmComplete")
  , esCategory  :: Text          -- ^ "internal" | "yielded"
  , esSemantics :: Text          -- ^ "fire_and_forget" | "blocking"
  }
  deriving (Show, Eq)


-- ============================================================================
-- TypeScript Generation - graphs.ts
-- ============================================================================

-- | Generate graphs.ts with GraphId type and graphRegistry.
--
-- Output:
--
-- > export type GraphId = "test" | "example" | "habitica";
-- >
-- > export interface GraphEdge { from: string; to: string; }
-- >
-- > export interface GraphInfo {
-- >   id: GraphId;
-- >   name: string;
-- >   nodes: string[];
-- >   edges: GraphEdge[];
-- > }
-- >
-- > export const graphRegistry: Record<GraphId, GraphInfo> = { ... };
generateGraphsTs :: [GraphSpec] -> Text
generateGraphsTs specs = T.unlines
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "export type GraphId = " <> graphIdUnion specs <> ";"
  , ""
  , "export interface GraphEdge {"
  , "  from: string;"
  , "  to: string;"
  , "}"
  , ""
  , "export interface GraphInfo {"
  , "  id: GraphId;"
  , "  name: string;"
  , "  nodes: string[];"
  , "  edges: GraphEdge[];"
  , "}"
  , ""
  , "export const graphRegistry: Record<GraphId, GraphInfo> = {"
  , T.intercalate ",\n" (map graphRegistryEntry specs)
  , "};"
  ]

-- | Generate GraphId union type: "test" | "example" | "habitica"
graphIdUnion :: [GraphSpec] -> Text
graphIdUnion specs = T.intercalate " | " $ map (\s -> "\"" <> s.gsId <> "\"") specs

-- | Generate a single graph registry entry.
graphRegistryEntry :: GraphSpec -> Text
graphRegistryEntry spec = T.unlines
  [ "  " <> quote spec.gsId <> ": {"
  , "    id: " <> quote spec.gsId <> ","
  , "    name: " <> quote spec.gsName <> ","
  , "    nodes: [" <> T.intercalate ", " (map quote spec.gsNodes) <> "],"
  , "    edges: [" <> T.intercalate ", " (map edgeObj spec.gsEdges) <> "]"
  , "  }"
  ]
  where
    edgeObj (from, to) = "{ from: " <> quote from <> ", to: " <> quote to <> " }"


-- ============================================================================
-- TypeScript Generation - exports.ts
-- ============================================================================

-- | Generate exports.ts with GraphWasmExports interface.
--
-- Output:
--
-- > export interface GraphWasmExports {
-- >   initialize_test: (json: string) => string;
-- >   step_test: (json: string) => string;
-- >   getGraphInfo_test: () => string;
-- >   getGraphState_test: () => string;
-- >   // ... for each graph
-- > }
generateExportsTs :: [GraphSpec] -> Text
generateExportsTs specs = T.unlines $
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "export interface GraphWasmExports {"
  ] ++ concatMap graphExports specs ++
  [ "}"
  ]

-- | Generate export declarations for a single graph.
graphExports :: GraphSpec -> [Text]
graphExports spec =
  [ "  // " <> spec.gsName
  , "  initialize_" <> gid <> ": (json: string) => string;"
  , "  step_" <> gid <> ": (json: string) => string;"
  , "  getGraphInfo_" <> gid <> ": () => string;"
  , "  getGraphState_" <> gid <> ": () => string;"
  ]
  where
    gid = spec.gsId


-- ============================================================================
-- TypeScript Generation - dispatcher.ts
-- ============================================================================

-- | Generate dispatcher.ts with getGraphFns function.
--
-- Output:
--
-- > import type { GraphId } from './graphs.js';
-- > import type { GraphWasmExports } from './exports.js';
-- >
-- > export interface GraphFns {
-- >   initialize: (json: string) => string;
-- >   step: (json: string) => string;
-- >   getGraphInfo: () => string;
-- >   getGraphState: () => string;
-- > }
-- >
-- > export function getGraphFns(graphId: GraphId, exports: GraphWasmExports): GraphFns {
-- >   switch (graphId) { ... }
-- > }
generateDispatcherTs :: [GraphSpec] -> Text
generateDispatcherTs specs = T.unlines $
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "import type { GraphId } from './graphs.js';"
  , "import type { GraphWasmExports } from './exports.js';"
  , ""
  , "export interface GraphFns {"
  , "  initialize: (json: string) => string;"
  , "  step: (json: string) => string;"
  , "  getGraphInfo: () => string;"
  , "  getGraphState: () => string;"
  , "}"
  , ""
  , "export function getGraphFns(graphId: GraphId, exports: GraphWasmExports): GraphFns {"
  , "  switch (graphId) {"
  ] ++ concatMap dispatchCase specs ++
  [ "  }"
  , "}"
  ]

-- | Generate a single case in the dispatcher switch.
dispatchCase :: GraphSpec -> [Text]
dispatchCase spec =
  [ "    case " <> quote gid <> ":"
  , "      return {"
  , "        initialize: exports.initialize_" <> gid <> ","
  , "        step: exports.step_" <> gid <> ","
  , "        getGraphInfo: exports.getGraphInfo_" <> gid <> ","
  , "        getGraphState: exports.getGraphState_" <> gid <> ","
  , "      };"
  ]
  where
    gid = spec.gsId


-- ============================================================================
-- TypeScript Generation - routing.ts
-- ============================================================================

-- | Generate routing.ts with effect category/semantics functions.
--
-- Output:
--
-- > import type { SerializableEffect } from './protocol.js';
-- >
-- > export type EffectCategory = 'internal' | 'yielded';
-- > export type EffectSemantics = 'fire_and_forget' | 'blocking';
-- >
-- > export function getEffectCategory(effect: SerializableEffect): EffectCategory { ... }
-- > export function isYieldedEffect(effect: SerializableEffect): boolean { ... }
generateRoutingTs :: [EffectSpec] -> Text
generateRoutingTs specs = T.unlines $
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "import type { SerializableEffect } from './protocol.js';"
  , ""
  , "export type EffectCategory = 'internal' | 'yielded';"
  , "export type EffectSemantics = 'fire_and_forget' | 'blocking';"
  , ""
  , "export function getEffectCategory(effect: SerializableEffect): EffectCategory {"
  , "  switch (effect.type) {"
  ] ++ map categoryCase specs ++
  [ "    default:"
  , "      // Exhaustiveness check: unknown effects default to internal"
  , "      return 'internal';"
  , "  }"
  , "}"
  , ""
  , "export function getEffectSemantics(effect: SerializableEffect): EffectSemantics {"
  , "  switch (effect.type) {"
  ] ++ map semanticsCase specs ++
  [ "    default:"
  , "      // Exhaustiveness check: unknown effects default to blocking"
  , "      return 'blocking';"
  , "  }"
  , "}"
  , ""
  , "export function isYieldedEffect(effect: SerializableEffect): boolean {"
  , "  return getEffectCategory(effect) === 'yielded';"
  , "}"
  , ""
  , "export function isInternalEffect(effect: SerializableEffect): boolean {"
  , "  return getEffectCategory(effect) === 'internal';"
  , "}"
  , ""
  , "export function isBlockingEffect(effect: SerializableEffect): boolean {"
  , "  return getEffectSemantics(effect) === 'blocking';"
  , "}"
  ]

-- | Generate a category switch case.
categoryCase :: EffectSpec -> Text
categoryCase spec = "    case " <> quote spec.esType <> ": return " <> quote spec.esCategory <> ";"

-- | Generate a semantics switch case.
semanticsCase :: EffectSpec -> Text
semanticsCase spec = "    case " <> quote spec.esType <> ": return " <> quote spec.esSemantics <> ";"


-- ============================================================================
-- TypeScript Generation - index.ts
-- ============================================================================

-- | Generate index.ts that re-exports public API.
generateIndexTs :: Text
generateIndexTs = T.unlines
  [ "// Auto-generated by generate-ts-package - DO NOT EDIT"
  , ""
  , "// Graph metadata"
  , "export type { GraphId, GraphInfo, GraphEdge } from './graphs.js';"
  , "export { graphRegistry } from './graphs.js';"
  , ""
  , "// WASM exports interface"
  , "export type { GraphWasmExports } from './exports.js';"
  , ""
  , "// Type-safe dispatcher"
  , "export type { GraphFns } from './dispatcher.js';"
  , "export { getGraphFns } from './dispatcher.js';"
  , ""
  , "// Effect routing"
  , "export type { EffectCategory, EffectSemantics } from './routing.js';"
  , "export { getEffectCategory, getEffectSemantics, isYieldedEffect, isInternalEffect, isBlockingEffect } from './routing.js';"
  , ""
  , "// Protocol types"
  , "export * from './protocol.js';"
  , ""
  , "// GHC WASM JSFFI"
  , "export { createJsFFI } from './jsffi.js';"
  , "export type { WasmExports } from './jsffi.js';"
  , ""
  , "// WASM loader"
  , "export * from './loader.js';"
  ]


-- ============================================================================
-- Package Configuration - package.json
-- ============================================================================

-- | Generate package.json for the npm package.
generatePackageJson :: Text -> Text -> Text
generatePackageJson name version = T.unlines
  [ "{"
  , "  \"name\": " <> quote name <> ","
  , "  \"version\": " <> quote version <> ","
  , "  \"description\": \"Generated TypeScript bindings for Tidepool WASM graphs\","
  , "  \"type\": \"module\","
  , "  \"main\": \"dist/index.js\","
  , "  \"types\": \"dist/index.d.ts\","
  , "  \"exports\": {"
  , "    \".\": {"
  , "      \"types\": \"./dist/index.d.ts\","
  , "      \"import\": \"./dist/index.js\""
  , "    }"
  , "  },"
  , "  \"files\": ["
  , "    \"dist\","
  , "    \"src\","
  , "    \"wasm\""
  , "  ],"
  , "  \"scripts\": {"
  , "    \"build\": \"tsc\","
  , "    \"typecheck\": \"tsc --noEmit\""
  , "  },"
  , "  \"dependencies\": {"
  , "    \"@anthropic-ai/sdk\": \"^0.39.0\","
  , "    \"@bjorn3/browser_wasi_shim\": \"^0.3.0\""
  , "  },"
  , "  \"devDependencies\": {"
  , "    \"@cloudflare/workers-types\": \"^4.20241230.0\","
  , "    \"typescript\": \"^5.0.0\""
  , "  },"
  , "  \"keywords\": [\"tidepool\", \"wasm\", \"llm\", \"agents\"],"
  , "  \"license\": \"MIT\""
  , "}"
  ]


-- ============================================================================
-- Package Configuration - tsconfig.json
-- ============================================================================

-- | Generate tsconfig.json for TypeScript compilation.
generateTsConfig :: Text
generateTsConfig = T.unlines
  [ "{"
  , "  \"compilerOptions\": {"
  , "    \"target\": \"ES2022\","
  , "    \"module\": \"ESNext\","
  , "    \"lib\": [\"ES2022\"],"
  , "    \"moduleResolution\": \"bundler\","
  , "    \"declaration\": true,"
  , "    \"declarationMap\": true,"
  , "    \"sourceMap\": true,"
  , "    \"outDir\": \"dist\","
  , "    \"rootDir\": \"src\","
  , "    \"strict\": true,"
  , "    \"noImplicitAny\": false,"
  , "    \"esModuleInterop\": true,"
  , "    \"skipLibCheck\": true,"
  , "    \"forceConsistentCasingInFileNames\": true,"
  , "    \"types\": [\"@cloudflare/workers-types\"]"
  , "  },"
  , "  \"include\": [\"src/**/*\"],"
  , "  \"exclude\": [\"node_modules\", \"dist\"]"
  , "}"
  ]


-- ============================================================================
-- Helpers
-- ============================================================================

-- | Quote a text value for JavaScript/JSON.
quote :: Text -> Text
quote t = "\"" <> t <> "\""
