<?xml version="1.0" encoding="UTF-8" ?><pmd-cpd>
      <duplication lines="12">
            <file path="haskell/effects/llm-executor/src/Tidepool/LLM/API/Anthropic.hs" line="26">
              <codefragment><![CDATA[-- * Re-exports
  , module Tidepool.Effects.LLMProvider
  ) where

import Data.Aeson (ToJSON(..), FromJSON(..), Value(..), object, (.=), withObject, (.:), (.:?))
import Data.Proxy (Proxy(..))
import Data.Text (Text)
import GHC.Generics (Generic)
import Servant.API
import Servant.Client (ClientM, client)

-- Response types from the effect module
import Tidepool.Effects.LLMProvider (AnthropicResponse]]></codefragment>
            </file>
            <file path="haskell/effects/llm-executor/src/Tidepool/LLM/API/OpenAI.hs" line="26">
              <codefragment><![CDATA[-- * Re-exports
  , module Tidepool.Effects.LLMProvider
  ) where

import Data.Aeson (ToJSON(..), FromJSON(..), Value(..), object, (.=), withObject, (.:), (.:?))
import Data.Proxy (Proxy(..))
import Data.Text (Text)
import GHC.Generics (Generic)
import Servant.API
import Servant.Client (ClientM, client)

-- Response types from the effect module
import Tidepool.Effects.LLMProvider (OpenAIResponse]]></codefragment>
            </file>
            <codefragment><![CDATA[-- * Re-exports
  , module Tidepool.Effects.LLMProvider
  ) where

import Data.Aeson (ToJSON(..), FromJSON(..), Value(..), object, (.=), withObject, (.:), (.:?))
import Data.Proxy (Proxy(..))
import Data.Text (Text)
import GHC.Generics (Generic)
import Servant.API
import Servant.Client (ClientM, client)

-- Response types from the effect module
import Tidepool.Effects.LLMProvider (AnthropicResponse]]></codefragment>
        </duplication>
      
      <duplication lines="20">
            <file path="haskell/dsl/core/src/Tidepool/Graph/Validate/ForkBarrier.hs" line="345">
              <codefragment><![CDATA[-- | Extract field names from a Generic representation.
type FieldNames :: (Type -> Type) -> [Symbol]
type family FieldNames f where
  FieldNames (M1 D _ f) = FieldNames f
  FieldNames (M1 C _ f) = FieldNames f
  FieldNames (M1 S ('MetaSel ('Just name) _ _ _) _) = '[name]
  FieldNames (M1 S ('MetaSel 'Nothing _ _ _) _) = '[]
  FieldNames (l :*: r) = Append (FieldNames l) (FieldNames r)
  FieldNames (K1 _ _) = '[]

-- | Pair field names with their node definitions.
type FieldsWithNames :: (Type -> Type) -> [(Symbol, Type)]
type family FieldsWithNames f where
  FieldsWithNames (M1 D _ f) = FieldsWithNames f
  FieldsWithNames (M1 C _ f) = FieldsWithNames f
  FieldsWithNames (M1 S ('MetaSel ('Just name) _ _ _) (K1 _ def)) = '[ '(name, def) ]
  FieldsWithNames (M1 S ('MetaSel 'Nothing _ _ _) _) = '[]
  FieldsWithNames (l :*: r) = Append (FieldsWithNames l) (FieldsWithNames r)
  FieldsWithNames _ = '[]

-- | Get fields with names from a graph type.]]></codefragment>
            </file>
            <file path="haskell/dsl/core/src/Tidepool/Graph/Validate/RecordStructure.hs" line="62">
              <codefragment><![CDATA[-- | Extract field names from a Generic representation.
type FieldNames :: (Type -> Type) -> [Symbol]
type family FieldNames f where
  FieldNames (M1 D _ f) = FieldNames f
  FieldNames (M1 C _ f) = FieldNames f
  FieldNames (M1 S ('MetaSel ('Just name) _ _ _) _) = '[name]
  FieldNames (M1 S ('MetaSel 'Nothing _ _ _) _) = '[]
  FieldNames (l :*: r) = Append (FieldNames l) (FieldNames r)
  FieldNames (K1 _ _) = '[]

-- | Pair field names with their node definitions.
type FieldsWithNames :: (Type -> Type) -> [(Symbol, Type)]
type family FieldsWithNames f where
  FieldsWithNames (M1 D _ f) = FieldsWithNames f
  FieldsWithNames (M1 C _ f) = FieldsWithNames f
  FieldsWithNames (M1 S ('MetaSel ('Just name) _ _ _) (K1 _ def)) = '[ '(name, def) ]
  FieldsWithNames (M1 S ('MetaSel 'Nothing _ _ _) _) = '[]
  FieldsWithNames (l :*: r) = Append (FieldsWithNames l) (FieldsWithNames r)
  FieldsWithNames _ = '[]

-- | Get field names from a graph type.]]></codefragment>
            </file>
            <codefragment><![CDATA[-- | Extract field names from a Generic representation.
type FieldNames :: (Type -> Type) -> [Symbol]
type family FieldNames f where
  FieldNames (M1 D _ f) = FieldNames f
  FieldNames (M1 C _ f) = FieldNames f
  FieldNames (M1 S ('MetaSel ('Just name) _ _ _) _) = '[name]
  FieldNames (M1 S ('MetaSel 'Nothing _ _ _) _) = '[]
  FieldNames (l :*: r) = Append (FieldNames l) (FieldNames r)
  FieldNames (K1 _ _) = '[]

-- | Pair field names with their node definitions.
type FieldsWithNames :: (Type -> Type) -> [(Symbol, Type)]
type family FieldsWithNames f where
  FieldsWithNames (M1 D _ f) = FieldsWithNames f
  FieldsWithNames (M1 C _ f) = FieldsWithNames f
  FieldsWithNames (M1 S ('MetaSel ('Just name) _ _ _) (K1 _ def)) = '[ '(name, def) ]
  FieldsWithNames (M1 S ('MetaSel 'Nothing _ _ _) _) = '[]
  FieldsWithNames (l :*: r) = Append (FieldsWithNames l) (FieldsWithNames r)
  FieldsWithNames _ = '[]

-- | Get fields with names from a graph type.]]></codefragment>
        </duplication>
      
      <duplication lines="9">
            <file path="haskell/runtime/wasm/src/Tidepool/Wasm/Effect.hs" line="405">
              <codefragment><![CDATA[result <- yield eff (id @EffectResult)
  pure $ case result of
    ResSuccess (Just v) -> case fromJSON v of
      Success askResult -> Right askResult
      Error err         -> Left $ parseFailed eff "TelegramAskResult" v (T.pack err)
    ResSuccess Nothing  -> Left $ emptyResult eff "Telegram user response"
    ResError msg        -> Left $ effectFailed eff msg


-- ════════════════════════════════════════════════════════════════════════════]]></codefragment>
            </file>
            <file path="haskell/runtime/wasm/src/Tidepool/Wasm/Effect.hs" line="323">
              <codefragment><![CDATA[result <- yield eff (id @EffectResult)
  pure $ case result of
    ResSuccess (Just v) -> case fromJSON v of
      Success askResult -> Right askResult
      Error err         -> Left $ parseFailed eff "TelegramAskResult" v (T.pack err)
    ResSuccess Nothing  -> Left $ emptyResult eff "Telegram user response"
    ResError msg        -> Left $ effectFailed eff msg


-- ────────────────────────────────────────────────────────────────────────────]]></codefragment>
            </file>
            <codefragment><![CDATA[result <- yield eff (id @EffectResult)
  pure $ case result of
    ResSuccess (Just v) -> case fromJSON v of
      Success askResult -> Right askResult
      Error err         -> Left $ parseFailed eff "TelegramAskResult" v (T.pack err)
    ResSuccess Nothing  -> Left $ emptyResult eff "Telegram user response"
    ResError msg        -> Left $ effectFailed eff msg


-- ════════════════════════════════════════════════════════════════════════════]]></codefragment>
        </duplication>
      
      <duplication lines="30">
            <file path="haskell/effects/ghci-executor/src/Tidepool/GHCi/Protocol.hs" line="131">
              <codefragment><![CDATA[-- | Encode length as 4 big-endian bytes.
encodeLen :: Int -> ByteString
encodeLen n = BS.pack
  [ fromIntegral (n `shiftR` 24)
  , fromIntegral (n `shiftR` 16)
  , fromIntegral (n `shiftR` 8)
  , fromIntegral n
  ]


-- | Decode 4 big-endian bytes to length.
decodeLen :: ByteString -> Int
decodeLen bs = case BS.unpack bs of
  [b0, b1, b2, b3] ->
    fromIntegral b0 * 16777216 +
    fromIntegral b1 * 65536 +
    fromIntegral b2 * 256 +
    fromIntegral b3
  _ -> 0


-- | Receive exactly n bytes from socket.
recvExact :: Socket -> Int -> IO ByteString
recvExact sock n = go n []
  where
    go 0 acc = pure $ BS.concat (reverse acc)
    go remaining acc = do
      chunk <- NBS.recv sock (min remaining 4096)
      if BS.null chunk
        then pure $ BS.concat (reverse acc)  -- Connection closed
        else go (remaining - BS.length chunk) (chunk : acc)]]></codefragment>
            </file>
            <file path="haskell/tools/ghci-oracle/src/GHCi/Oracle/Protocol.hs" line="92">
              <codefragment><![CDATA[-- | Encode length as 4 big-endian bytes.
encodeLen :: Int -> ByteString
encodeLen n = BS.pack
  [ fromIntegral (n `shiftR` 24)
  , fromIntegral (n `shiftR` 16)
  , fromIntegral (n `shiftR` 8)
  , fromIntegral n
  ]


-- | Decode 4 big-endian bytes to length.
decodeLen :: ByteString -> Int
decodeLen bs = case BS.unpack bs of
  [b0, b1, b2, b3] ->
    fromIntegral b0 * 16777216 +
    fromIntegral b1 * 65536 +
    fromIntegral b2 * 256 +
    fromIntegral b3
  _ -> 0


-- | Receive exactly n bytes from socket.
recvExact :: Socket -> Int -> IO ByteString
recvExact sock n = go n []
  where
    go 0 acc = pure $ BS.concat (reverse acc)
    go remaining acc = do
      chunk <- NBS.recv sock (min remaining 4096)
      if BS.null chunk
        then pure $ BS.concat (reverse acc)  -- Connection closed
        else go (remaining - BS.length chunk) (chunk : acc)]]></codefragment>
            </file>
            <codefragment><![CDATA[-- | Encode length as 4 big-endian bytes.
encodeLen :: Int -> ByteString
encodeLen n = BS.pack
  [ fromIntegral (n `shiftR` 24)
  , fromIntegral (n `shiftR` 16)
  , fromIntegral (n `shiftR` 8)
  , fromIntegral n
  ]


-- | Decode 4 big-endian bytes to length.
decodeLen :: ByteString -> Int
decodeLen bs = case BS.unpack bs of
  [b0, b1, b2, b3] ->
    fromIntegral b0 * 16777216 +
    fromIntegral b1 * 65536 +
    fromIntegral b2 * 256 +
    fromIntegral b3
  _ -> 0


-- | Receive exactly n bytes from socket.
recvExact :: Socket -> Int -> IO ByteString
recvExact sock n = go n []
  where
    go 0 acc = pure $ BS.concat (reverse acc)
    go remaining acc = do
      chunk <- NBS.recv sock (min remaining 4096)
      if BS.null chunk
        then pure $ BS.concat (reverse acc)  -- Connection closed
        else go (remaining - BS.length chunk) (chunk : acc)]]></codefragment>
        </duplication>
      
      <duplication lines="12">
            <file path="haskell/effects/bd-executor/src/Tidepool/BD/Executor.hs" line="279">
              <codefragment><![CDATA[]
            ++ maybe [] (\d -> ["--db", d]) config.bcBeadsDir

  result <- runBdCommand config args
  case result of
    Left _err -> pure []
    Right output ->
      case eitherDecode (LBS.fromStrict $ TE.encodeUtf8 output) of
        Right beads -> pure beads
        Left _ -> pure []


-- | List beads by type.]]></codefragment>
            </file>
            <file path="haskell/effects/bd-executor/src/Tidepool/BD/Executor.hs" line="256">
              <codefragment><![CDATA[]
            ++ maybe [] (\d -> ["--db", d]) config.bcBeadsDir

  result <- runBdCommand config args
  case result of
    Left _err -> pure []
    Right output ->
      case eitherDecode (LBS.fromStrict $ TE.encodeUtf8 output) of
        Right beads -> pure beads
        Left _ -> pure []


-- | List beads by status.]]></codefragment>
            </file>
            <codefragment><![CDATA[]
            ++ maybe [] (\d -> ["--db", d]) config.bcBeadsDir

  result <- runBdCommand config args
  case result of
    Left _err -> pure []
    Right output ->
      case eitherDecode (LBS.fromStrict $ TE.encodeUtf8 output) of
        Right beads -> pure beads
        Left _ -> pure []


-- | List beads by type.]]></codefragment>
        </duplication>
      
      <duplication lines="12">
            <file path="haskell/effects/bd-executor/src/Tidepool/BD/Executor.hs" line="306">
              <codefragment><![CDATA[]
            ++ maybe [] (\d -> ["--db", d]) config.bcBeadsDir

  result <- runBdCommand config args
  case result of
    Left _err -> pure []
    Right output ->
      case eitherDecode (LBS.fromStrict $ TE.encodeUtf8 output) of
        Right beads -> pure beads
        Left _ -> pure []


-- ════════════════════════════════════════════════════════════════════════════]]></codefragment>
            </file>
            <file path="haskell/effects/bd-executor/src/Tidepool/BD/Executor.hs" line="256">
              <codefragment><![CDATA[]
            ++ maybe [] (\d -> ["--db", d]) config.bcBeadsDir

  result <- runBdCommand config args
  case result of
    Left _err -> pure []
    Right output ->
      case eitherDecode (LBS.fromStrict $ TE.encodeUtf8 output) of
        Right beads -> pure beads
        Left _ -> pure []


-- | List beads by status.]]></codefragment>
            </file>
            <codefragment><![CDATA[]
            ++ maybe [] (\d -> ["--db", d]) config.bcBeadsDir

  result <- runBdCommand config args
  case result of
    Left _err -> pure []
    Right output ->
      case eitherDecode (LBS.fromStrict $ TE.encodeUtf8 output) of
        Right beads -> pure beads
        Left _ -> pure []


-- ════════════════════════════════════════════════════════════════════════════]]></codefragment>
        </duplication>
      
      <duplication lines="5">
            <file path="haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs" line="217">
              <codefragment><![CDATA[prefixModifier = makeStripPrefix commonPfx
        opts' = opts { soFieldLabelModifier = prefixModifier }
        fields = gProductSchema @f opts'
        required = gProductRequired @f opts'
        schema = objectSchema (map (\(k, v) -> (T.pack k, v)) fields) (map T.pack required)
    in [DecisionTool]]></codefragment>
            </file>
            <file path="haskell/dsl/core/src/Tidepool/StructuredOutput/Generic.hs" line="263">
              <codefragment><![CDATA[prefixModifier = makeStripPrefix commonPfx
        opts' = opts { soFieldLabelModifier = prefixModifier }
        fields = gProductSchema @f opts'
        required = gProductRequired @f opts'
        schema = objectSchema (map (\(k, v) -> (T.pack k, v)) fields) (map T.pack required)
    in [(]]></codefragment>
            </file>
            <codefragment><![CDATA[prefixModifier = makeStripPrefix commonPfx
        opts' = opts { soFieldLabelModifier = prefixModifier }
        fields = gProductSchema @f opts'
        required = gProductRequired @f opts'
        schema = objectSchema (map (\(k, v) -> (T.pack k, v)) fields) (map T.pack required)
    in [DecisionTool]]></codefragment>
        </duplication>
      
      <duplication lines="8">
            <file path="haskell/dsl/core/src/Tidepool/Graph/Validate.hs" line="135">
              <codefragment><![CDATA[= TypeError
  ('Text "Graph validation failed: invalid Goto target"
   ':$$: 'Text ""
   ':$$: 'Text "Node '" ':<>: 'Text srcName ':<>: 'Text "' has:"
   ':$$: 'Text "  Goto \"" ':<>: 'Text targetName ':<>: 'Text "\" ..."
   ':$$: 'Text ""
   ':$$: 'Text "But no node named \"" ':<>: 'Text targetName ':<>: 'Text "\" exists."
   ':$$: 'Text ""
   ':$$: 'Text "Available node names:"]]></codefragment>
            </file>
            <file path="haskell/dsl/core/src/Tidepool/Graph/Validate.hs" line="119">
              <codefragment><![CDATA[= TypeError
  ('Text "Graph validation failed: invalid Goto target"
   ':$$: 'Text ""
   ':$$: 'Text "Node '" ':<>: 'Text srcName ':<>: 'Text "' has:"
   ':$$: 'Text "  Goto \"" ':<>: 'Text targetName ':<>: 'Text "\" ..."
   ':$$: 'Text ""
   ':$$: 'Text "But no node named \"" ':<>: 'Text targetName ':<>: 'Text "\" exists."
   ':$$: 'Text ""
   ':$$: 'Text "Fix options:"]]></codefragment>
            </file>
            <codefragment><![CDATA[= TypeError
  ('Text "Graph validation failed: invalid Goto target"
   ':$$: 'Text ""
   ':$$: 'Text "Node '" ':<>: 'Text srcName ':<>: 'Text "' has:"
   ':$$: 'Text "  Goto \"" ':<>: 'Text targetName ':<>: 'Text "\" ..."
   ':$$: 'Text ""
   ':$$: 'Text "But no node named \"" ':<>: 'Text targetName ':<>: 'Text "\" exists."
   ':$$: 'Text ""
   ':$$: 'Text "Available node names:"]]></codefragment>
        </duplication>
      
      <duplication lines="12">
            <file path="haskell/dsl/core/src/Tidepool/Effects/Habitica.hs" line="46">
              <codefragment><![CDATA[TaskType(..)
  , Direction(..)
  , TaskId(..)
  , TodoId(..)
  , ChecklistItemId(..)
  , UserInfo(..)
  , UserStats(..)
  , HabiticaTask(..)
  , FetchedTodo(..)
  , FetchedChecklistItem(..)
  , ScoreResult(..)
  , HabiticaError(..)
  )]]></codefragment>
            </file>
            <file path="haskell/dsl/core/src/Tidepool/Effects/Habitica.hs" line="24">
              <codefragment><![CDATA[TaskType(..)
  , Direction(..)
  , TaskId(..)
  , TodoId(..)
  , ChecklistItemId(..)
  , UserInfo(..)
  , UserStats(..)
  , HabiticaTask(..)
  , FetchedTodo(..)
  , FetchedChecklistItem(..)
  , ScoreResult(..)
  , HabiticaError(..)

    -- * Runner (stub)]]></codefragment>
            </file>
            <codefragment><![CDATA[TaskType(..)
  , Direction(..)
  , TaskId(..)
  , TodoId(..)
  , ChecklistItemId(..)
  , UserInfo(..)
  , UserStats(..)
  , HabiticaTask(..)
  , FetchedTodo(..)
  , FetchedChecklistItem(..)
  , ScoreResult(..)
  , HabiticaError(..)
  )]]></codefragment>
        </duplication>
      
      <duplication lines="10">
            <file path="haskell/dsl/core/src/Tidepool/Effect/Session.hs" line="292">
              <codefragment><![CDATA[camelToSnake :: String -> String
camelToSnake = go True
  where
    go _ [] = []
    go isFirst (c:cs)
      | isUpper c =
          let lower = toLower c
          in if isFirst
             then lower : go False cs
             else '_' : lower : go False cs
      | otherwise = c : go False cs]]></codefragment>
            </file>
            <file path="haskell/dsl/core/src/Tidepool/StructuredOutput/DecisionTools.hs" line="251">
              <codefragment><![CDATA[camelToSnake :: String -> String
camelToSnake = go True
  where
    go _ [] = []
    go isFirst (c:cs)
      | isUpper c =
          let lower = toLower c
          in if isFirst
             then lower : go False cs
             else '_' : lower : go False cs
      | otherwise = c : go False cs]]></codefragment>
            </file>
            <codefragment><![CDATA[camelToSnake :: String -> String
camelToSnake = go True
  where
    go _ [] = []
    go isFirst (c:cs)
      | isUpper c =
          let lower = toLower c
          in if isFirst
             then lower : go False cs
             else '_' : lower : go False cs
      | otherwise = c : go False cs]]></codefragment>
        </duplication>
      
      <duplication lines="10">
            <file path="haskell/platform/src/Tidepool/Effect/Runners.hs" line="411">
              <codefragment><![CDATA[let userText = extractText userContent
    logDebug $ "[LLM] Prior history: " <> T.pack (show (length priorHistory)) <> " messages"
    logDebug $ "[LLM] User action: " <> userText

    let clientConfig = Client.ClientConfig
          { Client.apiKey = config.llmApiKey
          , Client.defaultModel = config.llmModel
          , Client.defaultMaxTokens = config.llmMaxTokens
          }
        outputSchema = if schema == toJSON () then Nothing else Just schema
        userMsg]]></codefragment>
            </file>
            <file path="haskell/platform/src/Tidepool/Effect/Runners.hs" line="218">
              <codefragment><![CDATA[let userText = extractText userContent
    logDebug $ "[LLM] Prior history: " <> T.pack (show (length priorHistory)) <> " messages"
    logDebug $ "[LLM] User action: " <> userText

    let clientConfig = Client.ClientConfig
          { Client.apiKey = config.llmApiKey
          , Client.defaultModel = config.llmModel
          , Client.defaultMaxTokens = config.llmMaxTokens
          }
        outputSchema = if schema == toJSON () then Nothing else Just schema
        actionMsg]]></codefragment>
            </file>
            <codefragment><![CDATA[let userText = extractText userContent
    logDebug $ "[LLM] Prior history: " <> T.pack (show (length priorHistory)) <> " messages"
    logDebug $ "[LLM] User action: " <> userText

    let clientConfig = Client.ClientConfig
          { Client.apiKey = config.llmApiKey
          , Client.defaultModel = config.llmModel
          , Client.defaultMaxTokens = config.llmMaxTokens
          }
        outputSchema = if schema == toJSON () then Nothing else Just schema
        userMsg]]></codefragment>
        </duplication>
      
      <duplication lines="8">
            <file path="haskell/dsl/core/src/Tidepool/Schema.hs" line="273">
              <codefragment><![CDATA[-> String
prettyType (ConT n) = nameBase n
prettyType (AppT (ConT n) inner)
  | nameBase n == "Maybe" = "Maybe " ++ prettyType inner
  | nameBase n == "[]"    = "[" ++ prettyType inner ++ "]"
  | otherwise             = nameBase n ++ " " ++ prettyType inner
prettyType (AppT ListT inner) = "[" ++ prettyType inner ++ "]"
prettyType (AppT l r) = prettyType l ++ " " ++ prettyType r
prettyType t = pprint t]]></codefragment>
            </file>
            <file path="haskell/dsl/core/src/Tidepool/Graph/CLI.hs" line="595">
              <codefragment><![CDATA[-> String
prettyType (ConT n) = nameBase n
prettyType (AppT (ConT n) inner)
  | nameBase n == "Maybe" = "Maybe " ++ prettyType inner
  | nameBase n == "[]"    = "[" ++ prettyType inner ++ "]"
  | otherwise             = nameBase n ++ " " ++ prettyType inner
prettyType (AppT ListT inner) = "[" ++ prettyType inner ++ "]"
prettyType (AppT l r) = prettyType l ++ " " ++ prettyType r
prettyType t = pprint t]]></codefragment>
            </file>
            <codefragment><![CDATA[-> String
prettyType (ConT n) = nameBase n
prettyType (AppT (ConT n) inner)
  | nameBase n == "Maybe" = "Maybe " ++ prettyType inner
  | nameBase n == "[]"    = "[" ++ prettyType inner ++ "]"
  | otherwise             = nameBase n ++ " " ++ prettyType inner
prettyType (AppT ListT inner) = "[" ++ prettyType inner ++ "]"
prettyType (AppT l r) = prettyType l ++ " " ++ prettyType r
prettyType t = pprint t]]></codefragment>
        </duplication>
      
      <duplication lines="7">
            <file path="haskell/runtime/wasm/test/ProtocolPropertySpec.hs" line="531">
              <codefragment><![CDATA[)
      let json = decode (encode img) :: Maybe Value
      case json of
        Just (Object obj) -> do
          KM.lookup "type" obj `shouldBe` Just (String "image")
          case KM.lookup "source" obj of
            Just (Object srcObj) -> do
              KM.lookup "type" srcObj `shouldBe` Just (String "url"]]></codefragment>
            </file>
            <file path="haskell/runtime/wasm/test/ProtocolPropertySpec.hs" line="512">
              <codefragment><![CDATA[)
      let json = decode (encode img) :: Maybe Value
      case json of
        Just (Object obj) -> do
          KM.lookup "type" obj `shouldBe` Just (String "image")
          case KM.lookup "source" obj of
            Just (Object srcObj) -> do
              KM.lookup "type" srcObj `shouldBe` Just (String "base64"]]></codefragment>
            </file>
            <codefragment><![CDATA[)
      let json = decode (encode img) :: Maybe Value
      case json of
        Just (Object obj) -> do
          KM.lookup "type" obj `shouldBe` Just (String "image")
          case KM.lookup "source" obj of
            Just (Object srcObj) -> do
              KM.lookup "type" srcObj `shouldBe` Just (String "url"]]></codefragment>
        </duplication>
      
      <duplication lines="9">
            <file path="haskell/runtime/wasm/test/ProtocolConformanceSpec.hs" line="103">
              <codefragment><![CDATA[$ do
      let result = ResSuccess (Just (Number 42))
          json = decode (encode result) :: Maybe Value
      case json of
        Just (Object obj) -> do
          KM.lookup "type" obj `shouldBe` Just (String "success")
          KM.lookup "value" obj `shouldBe` Just (Number 42)
        _ -> expectationFailure "Expected JSON object"

    it "omits value field when Nothing"]]></codefragment>
            </file>
            <file path="haskell/runtime/wasm/test/WireTypesSpec.hs" line="173">
              <codefragment><![CDATA[$ do
    let result = ResSuccess (Just (Number 42))
        json = decode (encode result) :: Maybe Value
    case json of
      Just (Object obj) -> do
        KM.lookup "type" obj `shouldBe` Just (String "success")
        KM.lookup "value" obj `shouldBe` Just (Number 42)
      _ -> expectationFailure "Expected JSON object"

  it "encodes ResError with correct JSON structure"]]></codefragment>
            </file>
            <codefragment><![CDATA[$ do
      let result = ResSuccess (Just (Number 42))
          json = decode (encode result) :: Maybe Value
      case json of
        Just (Object obj) -> do
          KM.lookup "type" obj `shouldBe` Just (String "success")
          KM.lookup "value" obj `shouldBe` Just (Number 42)
        _ -> expectationFailure "Expected JSON object"

    it "omits value field when Nothing"]]></codefragment>
        </duplication>
      
      <duplication lines="10">
            <file path="haskell/runtime/wasm/test/FfiSpec.hs" line="306">
              <codefragment><![CDATA["test" "not valid json"
    let Just output = decodeOutput result
    case output of
      Object o -> do
        KM.lookup "done" o `shouldBe` Just (Bool True)
        case KM.lookup "error" o of
          Just (String err) -> T.unpack err `shouldContain` "JSON parse error"
          _ -> expectationFailure "Expected error message"
      _ -> expectationFailure "Expected JSON object"

  it "double initialize resets state"]]></codefragment>
            </file>
            <file path="haskell/runtime/wasm/test/FfiSpec.hs" line="293">
              <codefragment><![CDATA["test" "not valid json"
    let Just output = decodeOutput result
    case output of
      Object o -> do
        KM.lookup "done" o `shouldBe` Just (Bool True)
        case KM.lookup "error" o of
          Just (String err) -> T.unpack err `shouldContain` "JSON parse error"
          _ -> expectationFailure "Expected error message"
      _ -> expectationFailure "Expected JSON object"

  it "step with invalid JSON returns error"]]></codefragment>
            </file>
            <codefragment><![CDATA["test" "not valid json"
    let Just output = decodeOutput result
    case output of
      Object o -> do
        KM.lookup "done" o `shouldBe` Just (Bool True)
        case KM.lookup "error" o of
          Just (String err) -> T.unpack err `shouldContain` "JSON parse error"
          _ -> expectationFailure "Expected error message"
      _ -> expectationFailure "Expected JSON object"

  it "double initialize resets state"]]></codefragment>
        </duplication>
      
      <duplication lines="7">
            <file path="haskell/runtime/actor/test/SubgraphSpec.hs" line="172">
              <codefragment><![CDATA[let results = [r1, r2, r3]
            isRight (Right _) = True
            isRight (Left _) = False
            rights xs = [x | Right x <- xs]
        all isRight results `shouldBe` True
        sort (rights results) `shouldBe` [2, 3, 4]

  describe "withRecursiveGraph"]]></codefragment>
            </file>
            <file path="haskell/runtime/actor/test/SubgraphSpec.hs" line="87">
              <codefragment><![CDATA[let results = [r1, r2, r3]
            isRight (Right _) = True
            isRight (Left _) = False
            rights xs = [x | Right x <- xs]
        all isRight results `shouldBe` True
        sort (rights results) `shouldBe` [2, 3, 4]

  describe "collect loop pattern"]]></codefragment>
            </file>
            <codefragment><![CDATA[let results = [r1, r2, r3]
            isRight (Right _) = True
            isRight (Left _) = False
            rights xs = [x | Right x <- xs]
        all isRight results `shouldBe` True
        sort (rights results) `shouldBe` [2, 3, 4]

  describe "withRecursiveGraph"]]></codefragment>
        </duplication>
      
      <duplication lines="35">
            <file path="haskell/protocol/generated-ts/src/protocol.ts" line="12">
              <codefragment><![CDATA[// ═══════════════════════════════════════════════════════════════════════════
// JSON SCHEMA (for LLM structured output)
// ═══════════════════════════════════════════════════════════════════════════

export interface JsonSchema {
  type?: string;
  properties?: Record<string, JsonSchema>;
  items?: JsonSchema;
  required?: string[];
  enum?: unknown[];
  description?: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// TYPE INFO (runtime representation of Haskell types)
// ═══════════════════════════════════════════════════════════════════════════

export interface TypeInfo {
  /** Simple type name, e.g., "Intent" */
  typeName: string;
  /** Module path, e.g., "Echo" */
  typeModule: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// GRAPH STRUCTURE (compile-time info, from Haskell Graph.Info)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Detailed graph metadata - matches Haskell GraphInfo with full type information.
 * Edges are derived from Needs/Schema relationships (implicit data flow)
 * and GotoTargets (explicit control flow).
 *
 * Note: The simple GraphInfo type used by the loader is in graphs.ts.
 * This detailed version is for advanced introspection features.
 */]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/protocol.ts" line="12">
              <codefragment><![CDATA[// ═══════════════════════════════════════════════════════════════════════════
// JSON SCHEMA (for LLM structured output)
// ═══════════════════════════════════════════════════════════════════════════

export interface JsonSchema {
  type?: string;
  properties?: Record<string, JsonSchema>;
  items?: JsonSchema;
  required?: string[];
  enum?: unknown[];
  description?: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// TYPE INFO (runtime representation of Haskell types)
// ═══════════════════════════════════════════════════════════════════════════

export interface TypeInfo {
  /** Simple type name, e.g., "Intent" */
  typeName: string;
  /** Module path, e.g., "Echo" */
  typeModule: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// GRAPH STRUCTURE (compile-time info, from Haskell Graph.Info)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Detailed graph metadata - matches Haskell GraphInfo with full type information.
 * Edges are derived from Input/Schema relationships (implicit data flow)
 * and GotoTargets (explicit control flow).
 *
 * Note: The simple GraphInfo type used by the loader is in graphs.ts.
 * This detailed version is for advanced introspection features.
 */]]></codefragment>
            </file>
            <codefragment><![CDATA[// ═══════════════════════════════════════════════════════════════════════════
// JSON SCHEMA (for LLM structured output)
// ═══════════════════════════════════════════════════════════════════════════

export interface JsonSchema {
  type?: string;
  properties?: Record<string, JsonSchema>;
  items?: JsonSchema;
  required?: string[];
  enum?: unknown[];
  description?: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// TYPE INFO (runtime representation of Haskell types)
// ═══════════════════════════════════════════════════════════════════════════

export interface TypeInfo {
  /** Simple type name, e.g., "Intent" */
  typeName: string;
  /** Module path, e.g., "Echo" */
  typeModule: string;
}

// ═══════════════════════════════════════════════════════════════════════════
// GRAPH STRUCTURE (compile-time info, from Haskell Graph.Info)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Detailed graph metadata - matches Haskell GraphInfo with full type information.
 * Edges are derived from Needs/Schema relationships (implicit data flow)
 * and GotoTargets (explicit control flow).
 *
 * Note: The simple GraphInfo type used by the loader is in graphs.ts.
 * This detailed version is for advanced introspection features.
 */]]></codefragment>
        </duplication>
      
      <duplication lines="38">
            <file path="haskell/protocol/generated-ts/src/protocol.ts" line="58">
              <codefragment><![CDATA[edges: EdgeInfo[];
}

export type NodeKind = "LLM" | "Logic";

/**
 * Node metadata - matches Haskell NodeInfo.
 * In Servant-style design: field name becomes node name.
 */
export interface NodeInfo {
  /** Node name (record field name in Servant-style) */
  niName: string;
  /** LLM nodes yield effects; Logic nodes run Haskell code */
  niKind: NodeKind;
  /** Input type this node needs (single type) */
  niInput: TypeInfo | null;
  /** Output type (LLM nodes only - from Schema annotation) */
  niSchema: TypeInfo | null;
  /** Possible Goto targets (Logic nodes only) */
  niGotoTargets: GotoTarget[];
}

/**
 * Edge for graph visualization.
 */
export interface EdgeInfo {
  /** Source: "Entry" or node name */
  eiFrom: string;
  /** Target: "Exit" or node name */
  eiTo: string;
  /** Type carried on this edge */
  eiPayloadType: TypeInfo;
}

/**
 * Goto target - control flow destination.
 * In Servant-style: Goto is control-flow only, no payload.
 * Target node pulls data from accumulated context via Needs.
 */]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/protocol.ts" line="58">
              <codefragment><![CDATA[edges: EdgeInfo[];
}

export type NodeKind = "LLM" | "Logic";

/**
 * Node metadata - matches Haskell NodeInfo.
 * In Servant-style design: field name becomes node name.
 */
export interface NodeInfo {
  /** Node name (record field name in Servant-style) */
  niName: string;
  /** LLM nodes yield effects; Logic nodes run Haskell code */
  niKind: NodeKind;
  /** Input type this node needs (single type) */
  niInput: TypeInfo | null;
  /** Output type (LLM nodes only - from Schema annotation) */
  niSchema: TypeInfo | null;
  /** Possible Goto targets (Logic nodes only) */
  niGotoTargets: GotoTarget[];
}

/**
 * Edge for graph visualization.
 */
export interface EdgeInfo {
  /** Source: "Entry" or node name */
  eiFrom: string;
  /** Target: "Exit" or node name */
  eiTo: string;
  /** Type carried on this edge */
  eiPayloadType: TypeInfo;
}

/**
 * Goto target - control flow destination.
 * In Servant-style: Goto is control-flow only, no payload.
 * Target node pulls data from accumulated context via Input.
 */]]></codefragment>
            </file>
            <codefragment><![CDATA[edges: EdgeInfo[];
}

export type NodeKind = "LLM" | "Logic";

/**
 * Node metadata - matches Haskell NodeInfo.
 * In Servant-style design: field name becomes node name.
 */
export interface NodeInfo {
  /** Node name (record field name in Servant-style) */
  niName: string;
  /** LLM nodes yield effects; Logic nodes run Haskell code */
  niKind: NodeKind;
  /** Input type this node needs (single type) */
  niInput: TypeInfo | null;
  /** Output type (LLM nodes only - from Schema annotation) */
  niSchema: TypeInfo | null;
  /** Possible Goto targets (Logic nodes only) */
  niGotoTargets: GotoTarget[];
}

/**
 * Edge for graph visualization.
 */
export interface EdgeInfo {
  /** Source: "Entry" or node name */
  eiFrom: string;
  /** Target: "Exit" or node name */
  eiTo: string;
  /** Type carried on this edge */
  eiPayloadType: TypeInfo;
}

/**
 * Goto target - control flow destination.
 * In Servant-style: Goto is control-flow only, no payload.
 * Target node pulls data from accumulated context via Needs.
 */]]></codefragment>
        </duplication>
      
      <duplication lines="49">
            <file path="haskell/protocol/generated-ts/src/protocol.ts" line="97">
              <codefragment><![CDATA[export interface GotoTarget {
  /** Target node name, or "Exit" */
  gtTarget: string;
  /** Type passed (for Exit transitions) */
  gtPayloadType: TypeInfo;
}

// ═══════════════════════════════════════════════════════════════════════════
// RUNTIME STATE (matches Haskell Serializable.hs)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Runtime graph state - matches Haskell GraphState.
 * Haskell maintains available values internally; TypeScript just observes.
 */
export interface GraphState {
  /** Current execution phase */
  phase: ExecutionPhase;
  /** Nodes that have completed */
  completedNodes: string[];
}

/**
 * Execution phase - matches Haskell ExecutionPhase.
 * Haskell uses ObjectWithSingleField encoding: {type: "in_node", nodeName: "classify"}
 */
export type ExecutionPhase =
  | { type: "idle" }
  | { type: "in_node"; nodeName: string }
  | { type: "transitioning"; fromNode: string; toNode: string }
  | { type: "completed"; result: unknown }
  | { type: "failed"; error: string };

// Helper to extract current node from phase (for observability)
export function getCurrentNode(phase: ExecutionPhase): string | null {
  if (phase.type === "in_node") return phase.nodeName;
  if (phase.type === "transitioning") return phase.fromNode;
  return null;
}

// ═══════════════════════════════════════════════════════════════════════════
// EFFECTS (what WASM yields to TypeScript - matches Haskell SerializableEffect)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Effect types that Haskell yields for TypeScript to execute.
 * Haskell uses flat encoding: {type: "LlmComplete", eff_node: "...", ...}
 *
 * This union must match the SerializableEffect type in WireTypes.hs exactly.
 */]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/protocol.ts" line="97">
              <codefragment><![CDATA[export interface GotoTarget {
  /** Target node name, or "Exit" */
  gtTarget: string;
  /** Type passed (for Exit transitions) */
  gtPayloadType: TypeInfo;
}

// ═══════════════════════════════════════════════════════════════════════════
// RUNTIME STATE (matches Haskell Serializable.hs)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Runtime graph state - matches Haskell GraphState.
 * Haskell maintains available values internally; TypeScript just observes.
 */
export interface GraphState {
  /** Current execution phase */
  phase: ExecutionPhase;
  /** Nodes that have completed */
  completedNodes: string[];
}

/**
 * Execution phase - matches Haskell ExecutionPhase.
 * Haskell uses ObjectWithSingleField encoding: {type: "in_node", nodeName: "classify"}
 */
export type ExecutionPhase =
  | { type: "idle" }
  | { type: "in_node"; nodeName: string }
  | { type: "transitioning"; fromNode: string; toNode: string }
  | { type: "completed"; result: unknown }
  | { type: "failed"; error: string };

// Helper to extract current node from phase (for observability)
export function getCurrentNode(phase: ExecutionPhase): string | null {
  if (phase.type === "in_node") return phase.nodeName;
  if (phase.type === "transitioning") return phase.fromNode;
  return null;
}

// ═══════════════════════════════════════════════════════════════════════════
// EFFECTS (what WASM yields to TypeScript - matches Haskell SerializableEffect)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Effect types that Haskell yields for TypeScript to execute.
 * Haskell uses flat encoding: {type: "LlmComplete", eff_node: "...", ...}
 */]]></codefragment>
            </file>
            <codefragment><![CDATA[export interface GotoTarget {
  /** Target node name, or "Exit" */
  gtTarget: string;
  /** Type passed (for Exit transitions) */
  gtPayloadType: TypeInfo;
}

// ═══════════════════════════════════════════════════════════════════════════
// RUNTIME STATE (matches Haskell Serializable.hs)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Runtime graph state - matches Haskell GraphState.
 * Haskell maintains available values internally; TypeScript just observes.
 */
export interface GraphState {
  /** Current execution phase */
  phase: ExecutionPhase;
  /** Nodes that have completed */
  completedNodes: string[];
}

/**
 * Execution phase - matches Haskell ExecutionPhase.
 * Haskell uses ObjectWithSingleField encoding: {type: "in_node", nodeName: "classify"}
 */
export type ExecutionPhase =
  | { type: "idle" }
  | { type: "in_node"; nodeName: string }
  | { type: "transitioning"; fromNode: string; toNode: string }
  | { type: "completed"; result: unknown }
  | { type: "failed"; error: string };

// Helper to extract current node from phase (for observability)
export function getCurrentNode(phase: ExecutionPhase): string | null {
  if (phase.type === "in_node") return phase.nodeName;
  if (phase.type === "transitioning") return phase.fromNode;
  return null;
}

// ═══════════════════════════════════════════════════════════════════════════
// EFFECTS (what WASM yields to TypeScript - matches Haskell SerializableEffect)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Effect types that Haskell yields for TypeScript to execute.
 * Haskell uses flat encoding: {type: "LlmComplete", eff_node: "...", ...}
 *
 * This union must match the SerializableEffect type in WireTypes.hs exactly.
 */]]></codefragment>
        </duplication>
      
      <duplication lines="38">
            <file path="haskell/protocol/generated-ts/src/protocol.ts" line="272">
              <codefragment><![CDATA[/**
 * Info log - matches Haskell EffLogInfo.
 */
export interface LogInfoEffect {
  type: "LogInfo";
  eff_message: string;
  /** Optional structured fields for queryable log data */
  eff_fields?: Record<string, unknown>;
}

/**
 * Error log - matches Haskell EffLogError.
 */
export interface LogErrorEffect {
  type: "LogError";
  eff_message: string;
  /** Optional structured fields for queryable log data */
  eff_fields?: Record<string, unknown>;
}

/**
 * Habitica API effect - matches Haskell EffHabitica.
 * Used for task management and gamification features.
 */
export interface HabiticaEffect {
  type: "Habitica";
  /** Operation name: "GetUser", "ScoreTask", "GetTasks", etc. */
  eff_hab_op: string;
  /** Operation-specific payload (JSON) */
  eff_hab_payload: unknown;
}

// ═══════════════════════════════════════════════════════════════════════════
// STATE EFFECTS (for DM and other stateful graphs)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Read state from Durable Object storage - matches Haskell EffGetState.
 */]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/protocol.ts" line="242">
              <codefragment><![CDATA[/**
 * Info log - matches Haskell EffLogInfo.
 */
export interface LogInfoEffect {
  type: "LogInfo";
  eff_message: string;
  /** Optional structured fields for queryable log data */
  eff_fields?: Record<string, unknown>;
}

/**
 * Error log - matches Haskell EffLogError.
 */
export interface LogErrorEffect {
  type: "LogError";
  eff_message: string;
  /** Optional structured fields for queryable log data */
  eff_fields?: Record<string, unknown>;
}

/**
 * Habitica API effect - matches Haskell EffHabitica.
 * Used for task management and gamification features.
 */
export interface HabiticaEffect {
  type: "Habitica";
  /** Operation name: "GetUser", "ScoreTask", "GetTasks", etc. */
  eff_hab_op: string;
  /** Operation-specific payload (JSON) */
  eff_hab_payload: unknown;
}

// ═══════════════════════════════════════════════════════════════════════════
// STATE EFFECTS (for DM and other stateful graphs)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Get state by key - matches Haskell EffGetState.
 * TypeScript reads from Durable Object storage or in-memory store.
 */]]></codefragment>
            </file>
            <codefragment><![CDATA[/**
 * Info log - matches Haskell EffLogInfo.
 */
export interface LogInfoEffect {
  type: "LogInfo";
  eff_message: string;
  /** Optional structured fields for queryable log data */
  eff_fields?: Record<string, unknown>;
}

/**
 * Error log - matches Haskell EffLogError.
 */
export interface LogErrorEffect {
  type: "LogError";
  eff_message: string;
  /** Optional structured fields for queryable log data */
  eff_fields?: Record<string, unknown>;
}

/**
 * Habitica API effect - matches Haskell EffHabitica.
 * Used for task management and gamification features.
 */
export interface HabiticaEffect {
  type: "Habitica";
  /** Operation name: "GetUser", "ScoreTask", "GetTasks", etc. */
  eff_hab_op: string;
  /** Operation-specific payload (JSON) */
  eff_hab_payload: unknown;
}

// ═══════════════════════════════════════════════════════════════════════════
// STATE EFFECTS (for DM and other stateful graphs)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Read state from Durable Object storage - matches Haskell EffGetState.
 */]]></codefragment>
        </duplication>
      
      <duplication lines="41">
            <file path="haskell/protocol/generated-ts/src/protocol.ts" line="367">
              <codefragment><![CDATA[export interface GetTimeEffect {
  type: "GetTime";
}

// ═══════════════════════════════════════════════════════════════════════════
// TELEGRAM EFFECT TYPES (from tidepool-telegram-ts)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Outgoing messages that can be sent to the user.
 * Mirrors Haskell: Tidepool.Telegram.Types.OutgoingMessage
 */
export type TelegramOutgoingMessage =
  | { type: 'text'; text: string }
  | { type: 'photo'; media: string; caption?: string }
  | { type: 'document'; media: string; filename: string }
  | { type: 'buttons'; text: string; buttons: TelegramInlineButton[][] };

/**
 * Inline keyboard button with callback data.
 */
export interface TelegramInlineButton {
  text: string;
  data: unknown;
}

/**
 * Incoming messages received from the user.
 * Mirrors Haskell: Tidepool.Telegram.Types.IncomingMessage
 */
export type TelegramIncomingMessage =
  | { type: 'text'; text: string }
  | { type: 'photo'; media: string; caption?: string }
  | { type: 'document'; media: string; filename: string }
  | { type: 'button_click'; data: unknown };

/**
 * Send a message (fire and forget).
 * Mirrors Haskell: Send :: OutgoingMessage -> Telegram m ()
 */
export interface TelegramSendEffect {
  type: "telegram_send"]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/protocol.ts" line="340">
              <codefragment><![CDATA[export interface GetTimeEffect {
  type: "GetTime";
}

// ═══════════════════════════════════════════════════════════════════════════
// TELEGRAM EFFECT TYPES (from tidepool-telegram-ts)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Outgoing messages that can be sent to the user.
 * Mirrors Haskell: Tidepool.Telegram.Types.OutgoingMessage
 */
export type TelegramOutgoingMessage =
  | { type: 'text'; text: string }
  | { type: 'photo'; media: string; caption?: string }
  | { type: 'document'; media: string; filename: string }
  | { type: 'buttons'; text: string; buttons: TelegramInlineButton[][] };

/**
 * Inline keyboard button with callback data.
 */
export interface TelegramInlineButton {
  text: string;
  data: unknown;
}

/**
 * Incoming messages received from the user.
 * Mirrors Haskell: Tidepool.Telegram.Types.IncomingMessage
 */
export type TelegramIncomingMessage =
  | { type: 'text'; text: string }
  | { type: 'photo'; media: string; caption?: string }
  | { type: 'document'; media: string; filename: string }
  | { type: 'button_click'; data: unknown };

/**
 * Send a message (fire and forget).
 * Mirrors Haskell: Send :: OutgoingMessage -> Telegram m ()
 */
export interface TelegramSendEffect {
  type: "TelegramSend"]]></codefragment>
            </file>
            <codefragment><![CDATA[export interface GetTimeEffect {
  type: "GetTime";
}

// ═══════════════════════════════════════════════════════════════════════════
// TELEGRAM EFFECT TYPES (from tidepool-telegram-ts)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Outgoing messages that can be sent to the user.
 * Mirrors Haskell: Tidepool.Telegram.Types.OutgoingMessage
 */
export type TelegramOutgoingMessage =
  | { type: 'text'; text: string }
  | { type: 'photo'; media: string; caption?: string }
  | { type: 'document'; media: string; filename: string }
  | { type: 'buttons'; text: string; buttons: TelegramInlineButton[][] };

/**
 * Inline keyboard button with callback data.
 */
export interface TelegramInlineButton {
  text: string;
  data: unknown;
}

/**
 * Incoming messages received from the user.
 * Mirrors Haskell: Tidepool.Telegram.Types.IncomingMessage
 */
export type TelegramIncomingMessage =
  | { type: 'text'; text: string }
  | { type: 'photo'; media: string; caption?: string }
  | { type: 'document'; media: string; filename: string }
  | { type: 'button_click'; data: unknown };

/**
 * Send a message (fire and forget).
 * Mirrors Haskell: Send :: OutgoingMessage -> Telegram m ()
 */
export interface TelegramSendEffect {
  type: "telegram_send"]]></codefragment>
        </duplication>
      
      <duplication lines="182">
            <file path="haskell/protocol/generated-ts/src/protocol.ts" line="492">
              <codefragment><![CDATA[// ═══════════════════════════════════════════════════════════════════════════
// EFFECT RESULTS (what TypeScript returns to WASM - matches Haskell EffectResult)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Result of effect execution.
 * Aeson TaggedObject puts single-field records directly at top level (no contents wrapper).
 * fieldLabelModifier drops "res" prefix: resValue -> value, resMessage -> message
 */
export type EffectResult =
  | { type: "success"; value: unknown }
  | { type: "error"; message: string };

// Helper to create success result
export function successResult(value: unknown): EffectResult {
  return { type: "success", value };
}

// Helper to create error result
export function errorResult(message: string): EffectResult {
  return { type: "error", message };
}

/**
 * Result from LLM call (for LlmComplete effect).
 * This is what goes in the `value` field of a success result.
 */
export interface LlmResult {
  /** Parsed output (matches schema) */
  output: unknown;
  /** Token usage (optional) */
  usage?: {
    inputTokens: number;
    outputTokens: number;
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// TELEGRAM EFFECT RESULTS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Result for TelegramSendEffectV2: unit (void).
 * Mirrors Haskell: UnitResult
 */
export interface TelegramUnitResult {
  type: 'unit';
}

/**
 * Result for TelegramReceiveEffect / TelegramTryReceiveEffect.
 * For Receive: guaranteed to have at least one message.
 * For TryReceive: may be empty.
 * Mirrors Haskell: MessagesResult
 */
export interface TelegramMessagesResult {
  type: 'messages';
  messages: TelegramIncomingMessage[];
}

/** Create a unit result. */
export function telegramUnitResult(): TelegramUnitResult {
  return { type: 'unit' };
}

/** Create a messages result. */
export function telegramMessagesResult(messages: TelegramIncomingMessage[]): TelegramMessagesResult {
  return { type: 'messages', messages };
}

// ═══════════════════════════════════════════════════════════════════════════
// STEP OUTPUT (response from WASM per step - matches Haskell StepOutput)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Output from each step of graph execution.
 * Matches Haskell StepOutput exactly.
 */
export interface StepOutput {
  /** Effect to execute, if any */
  effect: SerializableEffect | null;

  /** Is graph execution complete? */
  done: boolean;

  /** Final result (only when done=true, matches Exit type) */
  stepResult: unknown | null;

  /** Current graph execution state (for observability) */
  graphState: GraphState;
}

// ═══════════════════════════════════════════════════════════════════════════
// WASM MODULE INTERFACE (what the loaded module exposes)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * WASM exports from the Haskell graph machine.
 * Matches the exports defined in Haskell Machine.hs.
 */
export interface GraphMachineExports {
  /** Start graph execution with JSON input */
  initialize(input: string): Promise<string>; // → JSON StepOutput

  /** Continue execution with JSON EffectResult */
  step(result: string): Promise<string>; // → JSON StepOutput

  /** Get compile-time graph structure (returns simple GraphInfo from graphs.ts) */
  getGraphInfo(): string; // → JSON { id, name, nodes, edges }

  /** Get current runtime state */
  getGraphState(): string; // → JSON GraphState

  // GHC RTS exports
  memory: WebAssembly.Memory;
  hs_init(argc: number, argv: number): void;
}

// ═══════════════════════════════════════════════════════════════════════════
// RUNNER TYPES (TypeScript-side orchestration)
// ═══════════════════════════════════════════════════════════════════════════

/** Configuration for graph execution */
export interface GraphRunnerConfig {
  /** Maximum steps before timeout (default: 1000) */
  maxSteps?: number;
  /** Step callback for progress monitoring */
  onStep?: (output: StepOutput, stepNum: number) => void;
}

/** Result of running a graph to completion */
export interface GraphRunResult {
  /** Final output value (matches graph's Exit type) */
  result: unknown;
  /** Was execution successful? */
  success: boolean;
  /** Error message if failed */
  error?: string;
  /** Final graph state */
  finalState: GraphState;
  /** Number of steps taken */
  totalSteps: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// WEBSOCKET PROTOCOL (Client ↔ Server messages)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Messages sent from client to server.
 */
export type ClientMessage =
  | { type: 'init'; graphId: string; input: unknown }
  | { type: 'resume'; result: EffectResult }
  | { type: 'reconnect'; sessionId: string }
  | { type: 'ping' };

/**
 * Messages sent from server to client.
 */
export type ServerMessage =
  | { type: 'yield'; effect: SerializableEffect; sessionId: string }
  | { type: 'progress'; effect: SerializableEffect; status: string }
  | { type: 'done'; result: unknown }
  | { type: 'error'; message: string; recoverable: boolean; sessionId?: string }
  | { type: 'pong' };

/**
 * Session state stored in Durable Object storage for reconnection.
 */
export interface SessionState {
  /** Graph being executed */
  graphId: string;
  /** Serialized WASM machine state (opaque to TypeScript) */
  machineState: unknown;
  /** Effect waiting for client response, if any */
  pendingEffect: SerializableEffect | null;
  /** Last activity timestamp (Unix ms) */
  lastActivity: number;
}

/** Session timeout in milliseconds (5 minutes) */
export const SESSION_TIMEOUT_MS = 5 * 60 * 1000;]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/protocol.ts" line="451">
              <codefragment><![CDATA[// ═══════════════════════════════════════════════════════════════════════════
// EFFECT RESULTS (what TypeScript returns to WASM - matches Haskell EffectResult)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Result of effect execution.
 * Aeson TaggedObject puts single-field records directly at top level (no contents wrapper).
 * fieldLabelModifier drops "res" prefix: resValue -> value, resMessage -> message
 */
export type EffectResult =
  | { type: "success"; value: unknown }
  | { type: "error"; message: string };

// Helper to create success result
export function successResult(value: unknown): EffectResult {
  return { type: "success", value };
}

// Helper to create error result
export function errorResult(message: string): EffectResult {
  return { type: "error", message };
}

/**
 * Result from LLM call (for LlmComplete effect).
 * This is what goes in the `value` field of a success result.
 */
export interface LlmResult {
  /** Parsed output (matches schema) */
  output: unknown;
  /** Token usage (optional) */
  usage?: {
    inputTokens: number;
    outputTokens: number;
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// TELEGRAM EFFECT RESULTS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Result for TelegramSendEffectV2: unit (void).
 * Mirrors Haskell: UnitResult
 */
export interface TelegramUnitResult {
  type: 'unit';
}

/**
 * Result for TelegramReceiveEffect / TelegramTryReceiveEffect.
 * For Receive: guaranteed to have at least one message.
 * For TryReceive: may be empty.
 * Mirrors Haskell: MessagesResult
 */
export interface TelegramMessagesResult {
  type: 'messages';
  messages: TelegramIncomingMessage[];
}

/** Create a unit result. */
export function telegramUnitResult(): TelegramUnitResult {
  return { type: 'unit' };
}

/** Create a messages result. */
export function telegramMessagesResult(messages: TelegramIncomingMessage[]): TelegramMessagesResult {
  return { type: 'messages', messages };
}

// ═══════════════════════════════════════════════════════════════════════════
// STEP OUTPUT (response from WASM per step - matches Haskell StepOutput)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Output from each step of graph execution.
 * Matches Haskell StepOutput exactly.
 */
export interface StepOutput {
  /** Effect to execute, if any */
  effect: SerializableEffect | null;

  /** Is graph execution complete? */
  done: boolean;

  /** Final result (only when done=true, matches Exit type) */
  stepResult: unknown | null;

  /** Current graph execution state (for observability) */
  graphState: GraphState;
}

// ═══════════════════════════════════════════════════════════════════════════
// WASM MODULE INTERFACE (what the loaded module exposes)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * WASM exports from the Haskell graph machine.
 * Matches the exports defined in Haskell Machine.hs.
 */
export interface GraphMachineExports {
  /** Start graph execution with JSON input */
  initialize(input: string): Promise<string>; // → JSON StepOutput

  /** Continue execution with JSON EffectResult */
  step(result: string): Promise<string>; // → JSON StepOutput

  /** Get compile-time graph structure (returns simple GraphInfo from graphs.ts) */
  getGraphInfo(): string; // → JSON { id, name, nodes, edges }

  /** Get current runtime state */
  getGraphState(): string; // → JSON GraphState

  // GHC RTS exports
  memory: WebAssembly.Memory;
  hs_init(argc: number, argv: number): void;
}

// ═══════════════════════════════════════════════════════════════════════════
// RUNNER TYPES (TypeScript-side orchestration)
// ═══════════════════════════════════════════════════════════════════════════

/** Configuration for graph execution */
export interface GraphRunnerConfig {
  /** Maximum steps before timeout (default: 1000) */
  maxSteps?: number;
  /** Step callback for progress monitoring */
  onStep?: (output: StepOutput, stepNum: number) => void;
}

/** Result of running a graph to completion */
export interface GraphRunResult {
  /** Final output value (matches graph's Exit type) */
  result: unknown;
  /** Was execution successful? */
  success: boolean;
  /** Error message if failed */
  error?: string;
  /** Final graph state */
  finalState: GraphState;
  /** Number of steps taken */
  totalSteps: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// WEBSOCKET PROTOCOL (Client ↔ Server messages)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Messages sent from client to server.
 */
export type ClientMessage =
  | { type: 'init'; graphId: string; input: unknown }
  | { type: 'resume'; result: EffectResult }
  | { type: 'reconnect'; sessionId: string }
  | { type: 'ping' };

/**
 * Messages sent from server to client.
 */
export type ServerMessage =
  | { type: 'yield'; effect: SerializableEffect; sessionId: string }
  | { type: 'progress'; effect: SerializableEffect; status: string }
  | { type: 'done'; result: unknown }
  | { type: 'error'; message: string; recoverable: boolean; sessionId?: string }
  | { type: 'pong' };

/**
 * Session state stored in Durable Object storage for reconnection.
 */
export interface SessionState {
  /** Graph being executed */
  graphId: string;
  /** Serialized WASM machine state (opaque to TypeScript) */
  machineState: unknown;
  /** Effect waiting for client response, if any */
  pendingEffect: SerializableEffect | null;
  /** Last activity timestamp (Unix ms) */
  lastActivity: number;
}

/** Session timeout in milliseconds (5 minutes) */
export const SESSION_TIMEOUT_MS = 5 * 60 * 1000;]]></codefragment>
            </file>
            <codefragment><![CDATA[// ═══════════════════════════════════════════════════════════════════════════
// EFFECT RESULTS (what TypeScript returns to WASM - matches Haskell EffectResult)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Result of effect execution.
 * Aeson TaggedObject puts single-field records directly at top level (no contents wrapper).
 * fieldLabelModifier drops "res" prefix: resValue -> value, resMessage -> message
 */
export type EffectResult =
  | { type: "success"; value: unknown }
  | { type: "error"; message: string };

// Helper to create success result
export function successResult(value: unknown): EffectResult {
  return { type: "success", value };
}

// Helper to create error result
export function errorResult(message: string): EffectResult {
  return { type: "error", message };
}

/**
 * Result from LLM call (for LlmComplete effect).
 * This is what goes in the `value` field of a success result.
 */
export interface LlmResult {
  /** Parsed output (matches schema) */
  output: unknown;
  /** Token usage (optional) */
  usage?: {
    inputTokens: number;
    outputTokens: number;
  };
}

// ═══════════════════════════════════════════════════════════════════════════
// TELEGRAM EFFECT RESULTS
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Result for TelegramSendEffectV2: unit (void).
 * Mirrors Haskell: UnitResult
 */
export interface TelegramUnitResult {
  type: 'unit';
}

/**
 * Result for TelegramReceiveEffect / TelegramTryReceiveEffect.
 * For Receive: guaranteed to have at least one message.
 * For TryReceive: may be empty.
 * Mirrors Haskell: MessagesResult
 */
export interface TelegramMessagesResult {
  type: 'messages';
  messages: TelegramIncomingMessage[];
}

/** Create a unit result. */
export function telegramUnitResult(): TelegramUnitResult {
  return { type: 'unit' };
}

/** Create a messages result. */
export function telegramMessagesResult(messages: TelegramIncomingMessage[]): TelegramMessagesResult {
  return { type: 'messages', messages };
}

// ═══════════════════════════════════════════════════════════════════════════
// STEP OUTPUT (response from WASM per step - matches Haskell StepOutput)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Output from each step of graph execution.
 * Matches Haskell StepOutput exactly.
 */
export interface StepOutput {
  /** Effect to execute, if any */
  effect: SerializableEffect | null;

  /** Is graph execution complete? */
  done: boolean;

  /** Final result (only when done=true, matches Exit type) */
  stepResult: unknown | null;

  /** Current graph execution state (for observability) */
  graphState: GraphState;
}

// ═══════════════════════════════════════════════════════════════════════════
// WASM MODULE INTERFACE (what the loaded module exposes)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * WASM exports from the Haskell graph machine.
 * Matches the exports defined in Haskell Machine.hs.
 */
export interface GraphMachineExports {
  /** Start graph execution with JSON input */
  initialize(input: string): Promise<string>; // → JSON StepOutput

  /** Continue execution with JSON EffectResult */
  step(result: string): Promise<string>; // → JSON StepOutput

  /** Get compile-time graph structure (returns simple GraphInfo from graphs.ts) */
  getGraphInfo(): string; // → JSON { id, name, nodes, edges }

  /** Get current runtime state */
  getGraphState(): string; // → JSON GraphState

  // GHC RTS exports
  memory: WebAssembly.Memory;
  hs_init(argc: number, argv: number): void;
}

// ═══════════════════════════════════════════════════════════════════════════
// RUNNER TYPES (TypeScript-side orchestration)
// ═══════════════════════════════════════════════════════════════════════════

/** Configuration for graph execution */
export interface GraphRunnerConfig {
  /** Maximum steps before timeout (default: 1000) */
  maxSteps?: number;
  /** Step callback for progress monitoring */
  onStep?: (output: StepOutput, stepNum: number) => void;
}

/** Result of running a graph to completion */
export interface GraphRunResult {
  /** Final output value (matches graph's Exit type) */
  result: unknown;
  /** Was execution successful? */
  success: boolean;
  /** Error message if failed */
  error?: string;
  /** Final graph state */
  finalState: GraphState;
  /** Number of steps taken */
  totalSteps: number;
}

// ═══════════════════════════════════════════════════════════════════════════
// WEBSOCKET PROTOCOL (Client ↔ Server messages)
// ═══════════════════════════════════════════════════════════════════════════

/**
 * Messages sent from client to server.
 */
export type ClientMessage =
  | { type: 'init'; graphId: string; input: unknown }
  | { type: 'resume'; result: EffectResult }
  | { type: 'reconnect'; sessionId: string }
  | { type: 'ping' };

/**
 * Messages sent from server to client.
 */
export type ServerMessage =
  | { type: 'yield'; effect: SerializableEffect; sessionId: string }
  | { type: 'progress'; effect: SerializableEffect; status: string }
  | { type: 'done'; result: unknown }
  | { type: 'error'; message: string; recoverable: boolean; sessionId?: string }
  | { type: 'pong' };

/**
 * Session state stored in Durable Object storage for reconnection.
 */
export interface SessionState {
  /** Graph being executed */
  graphId: string;
  /** Serialized WASM machine state (opaque to TypeScript) */
  machineState: unknown;
  /** Effect waiting for client response, if any */
  pendingEffect: SerializableEffect | null;
  /** Last activity timestamp (Unix ms) */
  lastActivity: number;
}

/** Session timeout in milliseconds (5 minutes) */
export const SESSION_TIMEOUT_MS = 5 * 60 * 1000;]]></codefragment>
        </duplication>
      
      <duplication lines="60">
            <file path="haskell/protocol/generated-ts/src/loader.ts" line="10">
              <codefragment><![CDATA[import { WASI, File, OpenFile, ConsoleStdout } from "@bjorn3/browser_wasi_shim";
import { createJsFFI, type WasmExports } from "./jsffi.js";
import type {
  StepOutput,
  EffectResult,
  GraphState,
} from "./protocol.js";
import type { GraphInfo } from "./graphs.js";

// =============================================================================
// GraphMachine Interface (inline to avoid circular deps)
// =============================================================================

export interface GraphMachine {
  initialize(input: unknown): Promise<StepOutput>;
  step(result: EffectResult): Promise<StepOutput>;
  getGraphInfo(): Promise<GraphInfo>;
  getGraphState(): Promise<GraphState>;
}

// =============================================================================
// Cloudflare Workers Polyfills
// =============================================================================

// MessageChannel is not available in Workers - use setTimeout
if (typeof (globalThis as Record<string, unknown>).MessageChannel === "undefined") {
  (globalThis as Record<string, unknown>).MessageChannel = class {
    port1 = { postMessage: () => {} };
    port2 = { onmessage: null };
  };
}

// setImmediate polyfill for GHC WASM scheduler
if (typeof (globalThis as Record<string, unknown>).setImmediate === "undefined") {
  (globalThis as Record<string, unknown>).setImmediate = (fn: () => void) => setTimeout(fn, 0);
}

// FinalizationRegistry - no-op for short-lived Workers
if (typeof globalThis.FinalizationRegistry === "undefined") {
  // @ts-expect-error - Minimal polyfill, Workers requests are short-lived
  globalThis.FinalizationRegistry = class {
    register() {}
    unregister() {}
  };
}

// =============================================================================
// Loader Options
// =============================================================================

export interface LoaderOptions {
  /** The compiled WASM module */
  wasmModule: WebAssembly.Module;
  /** Graph ID to load (e.g., "test", "example", "habitica") */
  graphId: string;
  /** Enable debug logging */
  debug?: boolean;
}

// =============================================================================
// Loader Implementation]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/loader.ts" line="13">
              <codefragment><![CDATA[import { WASI, File, OpenFile, ConsoleStdout } from "@bjorn3/browser_wasi_shim";
import { createJsFFI, type WasmExports } from "./jsffi.js";
import type {
  StepOutput,
  EffectResult,
  GraphState,
} from "./protocol.js";
import type { GraphInfo } from "./graphs.js";

// =============================================================================
// GraphMachine Interface (inline to avoid circular deps)
// =============================================================================

export interface GraphMachine {
  initialize(input: unknown): Promise<StepOutput>;
  step(result: EffectResult): Promise<StepOutput>;
  getGraphInfo(): Promise<GraphInfo>;
  getGraphState(): Promise<GraphState>;
}

// =============================================================================
// Cloudflare Workers Polyfills
// =============================================================================

// MessageChannel is not available in Workers - use setTimeout
if (typeof (globalThis as Record<string, unknown>).MessageChannel === "undefined") {
  (globalThis as Record<string, unknown>).MessageChannel = class {
    port1 = { postMessage: () => {} };
    port2 = { onmessage: null };
  };
}

// setImmediate polyfill for GHC WASM scheduler
if (typeof (globalThis as Record<string, unknown>).setImmediate === "undefined") {
  (globalThis as Record<string, unknown>).setImmediate = (fn: () => void) => setTimeout(fn, 0);
}

// FinalizationRegistry - no-op for short-lived Workers
if (typeof globalThis.FinalizationRegistry === "undefined") {
  // @ts-expect-error - Minimal polyfill, Workers requests are short-lived
  globalThis.FinalizationRegistry = class {
    register() {}
    unregister() {}
  };
}

// =============================================================================
// Loader Options
// =============================================================================

export interface LoaderOptions {
  /** The compiled WASM module */
  wasmModule: WebAssembly.Module;
  /** Graph ID to load (e.g., "test", "example", "habitica") */
  graphId: string;
  /** Enable debug logging */
  debug?: boolean;
}

// =============================================================================
// Unified WASM Exports Interface]]></codefragment>
            </file>
            <codefragment><![CDATA[import { WASI, File, OpenFile, ConsoleStdout } from "@bjorn3/browser_wasi_shim";
import { createJsFFI, type WasmExports } from "./jsffi.js";
import type {
  StepOutput,
  EffectResult,
  GraphState,
} from "./protocol.js";
import type { GraphInfo } from "./graphs.js";

// =============================================================================
// GraphMachine Interface (inline to avoid circular deps)
// =============================================================================

export interface GraphMachine {
  initialize(input: unknown): Promise<StepOutput>;
  step(result: EffectResult): Promise<StepOutput>;
  getGraphInfo(): Promise<GraphInfo>;
  getGraphState(): Promise<GraphState>;
}

// =============================================================================
// Cloudflare Workers Polyfills
// =============================================================================

// MessageChannel is not available in Workers - use setTimeout
if (typeof (globalThis as Record<string, unknown>).MessageChannel === "undefined") {
  (globalThis as Record<string, unknown>).MessageChannel = class {
    port1 = { postMessage: () => {} };
    port2 = { onmessage: null };
  };
}

// setImmediate polyfill for GHC WASM scheduler
if (typeof (globalThis as Record<string, unknown>).setImmediate === "undefined") {
  (globalThis as Record<string, unknown>).setImmediate = (fn: () => void) => setTimeout(fn, 0);
}

// FinalizationRegistry - no-op for short-lived Workers
if (typeof globalThis.FinalizationRegistry === "undefined") {
  // @ts-expect-error - Minimal polyfill, Workers requests are short-lived
  globalThis.FinalizationRegistry = class {
    register() {}
    unregister() {}
  };
}

// =============================================================================
// Loader Options
// =============================================================================

export interface LoaderOptions {
  /** The compiled WASM module */
  wasmModule: WebAssembly.Module;
  /** Graph ID to load (e.g., "test", "example", "habitica") */
  graphId: string;
  /** Enable debug logging */
  debug?: boolean;
}

// =============================================================================
// Loader Implementation]]></codefragment>
        </duplication>
      
      <duplication lines="33">
            <file path="haskell/protocol/generated-ts/src/loader.ts" line="66">
              <codefragment><![CDATA[;
}

// =============================================================================
// Loader Implementation
// =============================================================================

export async function loadMachine(options: LoaderOptions): Promise<GraphMachine> {
  const { wasmModule, graphId, debug = false } = options;

  // Set up WASI with minimal filesystem (stdout/stderr only)
  const fds = [
    new OpenFile(new File([])), // stdin (empty)
    ConsoleStdout.lineBuffered((msg) => console.log(`[WASM stdout] ${msg}`)),
    ConsoleStdout.lineBuffered((msg) => console.error(`[WASM stderr] ${msg}`)),
  ];

  const wasi = new WASI([], [], fds, { debug });

  // Create exports object for knot-tying pattern
  const __exports: Partial<WasmExports> = {};

  // Create JSFFI imports
  const { imports: jsFFIImports } = createJsFFI(__exports);

  // Instantiate WASM module
  const instance = await WebAssembly.instantiate(wasmModule, {
    wasi_snapshot_preview1: wasi.wasiImport,
    ghc_wasm_jsffi: jsFFIImports as WebAssembly.ModuleImports,
  });

  // Fill in exports (completes the knot)
  Object.assign(__exports, instance.exports);
  const exports = instance.exports as unknown as WasmExports]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/loader.ts" line="89">
              <codefragment><![CDATA[;
}

// =============================================================================
// Loader Implementation
// =============================================================================

export async function loadMachine(options: LoaderOptions): Promise<GraphMachine> {
  const { wasmModule, graphId, debug = false } = options;

  // Set up WASI with minimal filesystem (stdout/stderr only)
  const fds = [
    new OpenFile(new File([])), // stdin (empty)
    ConsoleStdout.lineBuffered((msg) => console.log(`[WASM stdout] ${msg}`)),
    ConsoleStdout.lineBuffered((msg) => console.error(`[WASM stderr] ${msg}`)),
  ];

  const wasi = new WASI([], [], fds, { debug });

  // Create exports object for knot-tying pattern
  const __exports: Partial<WasmExports> = {};

  // Create JSFFI imports
  const { imports: jsFFIImports } = createJsFFI(__exports);

  // Instantiate WASM module
  const instance = await WebAssembly.instantiate(wasmModule, {
    wasi_snapshot_preview1: wasi.wasiImport,
    ghc_wasm_jsffi: jsFFIImports as WebAssembly.ModuleImports,
  });

  // Fill in exports (completes the knot)
  Object.assign(__exports, instance.exports);
  const exports = instance.exports as unknown as UnifiedWasmExports]]></codefragment>
            </file>
            <codefragment><![CDATA[;
}

// =============================================================================
// Loader Implementation
// =============================================================================

export async function loadMachine(options: LoaderOptions): Promise<GraphMachine> {
  const { wasmModule, graphId, debug = false } = options;

  // Set up WASI with minimal filesystem (stdout/stderr only)
  const fds = [
    new OpenFile(new File([])), // stdin (empty)
    ConsoleStdout.lineBuffered((msg) => console.log(`[WASM stdout] ${msg}`)),
    ConsoleStdout.lineBuffered((msg) => console.error(`[WASM stderr] ${msg}`)),
  ];

  const wasi = new WASI([], [], fds, { debug });

  // Create exports object for knot-tying pattern
  const __exports: Partial<WasmExports> = {};

  // Create JSFFI imports
  const { imports: jsFFIImports } = createJsFFI(__exports);

  // Instantiate WASM module
  const instance = await WebAssembly.instantiate(wasmModule, {
    wasi_snapshot_preview1: wasi.wasiImport,
    ghc_wasm_jsffi: jsFFIImports as WebAssembly.ModuleImports,
  });

  // Fill in exports (completes the knot)
  Object.assign(__exports, instance.exports);
  const exports = instance.exports as unknown as WasmExports]]></codefragment>
        </duplication>
      
      <duplication lines="17">
            <file path="haskell/protocol/generated-ts/src/loader.ts" line="99">
              <codefragment><![CDATA[;

  // Initialize WASI for reactor module
  wasi.initialize({
    exports: {
      memory: exports.memory,
      _initialize: exports._initialize,
    },
  });

  // Initialize GHC runtime
  exports.hs_init(0, 0);

  if (debug) {
    console.log(`[Tidepool] WASM module loaded for graph: ${graphId}`);
  }

  // Get graph-specific function names]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/loader.ts" line="122">
              <codefragment><![CDATA[;

  // Initialize WASI for reactor module
  wasi.initialize({
    exports: {
      memory: exports.memory,
      _initialize: exports._initialize,
    },
  });

  // Initialize GHC runtime
  exports.hs_init(0, 0);

  if (debug) {
    console.log(`[Tidepool] WASM module loaded for graph: ${graphId}`);
  }

  // Verify unified FFI exports exist]]></codefragment>
            </file>
            <codefragment><![CDATA[;

  // Initialize WASI for reactor module
  wasi.initialize({
    exports: {
      memory: exports.memory,
      _initialize: exports._initialize,
    },
  });

  // Initialize GHC runtime
  exports.hs_init(0, 0);

  if (debug) {
    console.log(`[Tidepool] WASM module loaded for graph: ${graphId}`);
  }

  // Get graph-specific function names]]></codefragment>
        </duplication>
      
      <duplication lines="14">
            <file path="haskell/protocol/generated-ts/src/loader.ts" line="137">
              <codefragment><![CDATA[inputJson);

      const result: StepOutput = typeof resultStr === "string"
        ? JSON.parse(resultStr)
        : { effect: null, done: true, stepResult: null, graphState: { phase: { type: "idle" } as const, completedNodes: [] } };

      if (debug) console.log(`[Tidepool:${graphId}] initialize result:`, JSON.stringify(result, null, 2));
      return result;
    },

    async step(result: EffectResult): Promise<StepOutput> {
      const resultJson = JSON.stringify(result);
      if (debug) console.log(`[Tidepool:${graphId}] step:`, resultJson);

      const stepFn]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/loader.ts" line="149">
              <codefragment><![CDATA[inputJson);

      const result: StepOutput = typeof resultStr === "string"
        ? JSON.parse(resultStr)
        : { effect: null, done: true, stepResult: null, graphState: { phase: { type: "idle" } as const, completedNodes: [] } };

      if (debug) console.log(`[Tidepool:${graphId}] initialize result:`, JSON.stringify(result, null, 2));
      return result;
    },

    async step(result: EffectResult): Promise<StepOutput> {
      const resultJson = JSON.stringify(result);
      if (debug) console.log(`[Tidepool:${graphId}] step:`, resultJson);

      const outputStr]]></codefragment>
            </file>
            <codefragment><![CDATA[inputJson);

      const result: StepOutput = typeof resultStr === "string"
        ? JSON.parse(resultStr)
        : { effect: null, done: true, stepResult: null, graphState: { phase: { type: "idle" } as const, completedNodes: [] } };

      if (debug) console.log(`[Tidepool:${graphId}] initialize result:`, JSON.stringify(result, null, 2));
      return result;
    },

    async step(result: EffectResult): Promise<StepOutput> {
      const resultJson = JSON.stringify(result);
      if (debug) console.log(`[Tidepool:${graphId}] step:`, resultJson);

      const stepFn]]></codefragment>
        </duplication>
      
      <duplication lines="11">
            <file path="haskell/protocol/generated-ts/src/loader.ts" line="152">
              <codefragment><![CDATA[resultJson);

      const output: StepOutput = typeof outputStr === "string"
        ? JSON.parse(outputStr)
        : { effect: null, done: true, stepResult: null, graphState: { phase: { type: "idle" } as const, completedNodes: [] } };

      if (debug) console.log(`[Tidepool:${graphId}] step result:`, JSON.stringify(output, null, 2));
      return output;
    },

    async getGraphInfo(): Promise<GraphInfo> {
      const fn]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/loader.ts" line="163">
              <codefragment><![CDATA[resultJson);

      const output: StepOutput = typeof outputStr === "string"
        ? JSON.parse(outputStr)
        : { effect: null, done: true, stepResult: null, graphState: { phase: { type: "idle" } as const, completedNodes: [] } };

      if (debug) console.log(`[Tidepool:${graphId}] step result:`, JSON.stringify(output, null, 2));
      return output;
    },

    async getGraphInfo(): Promise<GraphInfo> {
      const str]]></codefragment>
            </file>
            <codefragment><![CDATA[resultJson);

      const output: StepOutput = typeof outputStr === "string"
        ? JSON.parse(outputStr)
        : { effect: null, done: true, stepResult: null, graphState: { phase: { type: "idle" } as const, completedNodes: [] } };

      if (debug) console.log(`[Tidepool:${graphId}] step result:`, JSON.stringify(output, null, 2));
      return output;
    },

    async getGraphInfo(): Promise<GraphInfo> {
      const fn]]></codefragment>
        </duplication>
      
      <duplication lines="159">
            <file path="haskell/protocol/generated-ts/src/jsffi.ts" line="14">
              <codefragment><![CDATA[// GHC WASM exports use externref - JS values passed directly
  initialize: (input: string) => Promise<string>;
  step: (result: string) => Promise<string>;
  // RTS exports for JSFFI
  rts_schedulerLoop: () => void;
  rts_freeStablePtr: (sp: number) => void;
  rts_promiseResolveUnit: (p: number) => void;
  rts_promiseResolveJSVal: (p: number, val: number) => void;
  rts_promiseReject: (p: number, err: unknown) => void;
  rts_promiseThrowTo: (p: number, err: unknown) => void;
}

interface PromiseWithResolvers<T> extends Promise<T> {
  resolve: (value: T) => void;
  reject: (reason: unknown) => void;
  throwTo: (err: unknown) => void;
}

/**
 * Create the ghc_wasm_jsffi import object for WebAssembly.instantiate.
 * Uses a "knot-tying" pattern - pass an empty exports object that gets
 * filled in after instantiation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type JsFFIFunction = (...args: any[]) => any;

const DEBUG_JSFFI = false;

function logCall(name: string, args: unknown[]): void {
  if (DEBUG_JSFFI) {
    console.log(`[JSFFI] ${name}(${args.map(a => typeof a === 'object' ? '[obj]' : a).join(', ')})`);
  }
}

/** Access to the JSVal table for the loader */
export interface JsValTable {
  newJSVal(val: unknown): number;
  freeJSVal(id: number): void;
  getJSVal(id: number): unknown;
}

export interface JsFFIResult {
  imports: Record<string, JsFFIFunction>;
  jsvalTable: JsValTable;
}

export function createJsFFI(
  __exports: Partial<WasmExports>
): JsFFIResult {
  // Finalization registry for automatic cleanup of Haskell stable pointers
  const __ghc_wasm_jsffi_finalization_registry = new FinalizationRegistry(
    (sp: number) => {
      __exports.rts_freeStablePtr?.(sp);
    }
  );

  // JSVal table - maps integer handles to JavaScript values
  const jsvalTable = new Map<number, unknown>();
  let nextJsvalId = 1;

  // JSVal manipulation functions (used by both JSFFI imports and loader)
  const jsvalFunctions: JsValTable = {
    newJSVal: (val: unknown): number => {
      const id = nextJsvalId++;
      jsvalTable.set(id, val);
      return id;
    },
    freeJSVal: (id: number): void => {
      jsvalTable.delete(id);
    },
    getJSVal: (id: number): unknown => {
      return jsvalTable.get(id);
    },
  };

  // Wrap each function with logging and error catching
  function wrap<T extends JsFFIFunction>(name: string, fn: T): T {
    return ((...args: unknown[]) => {
      logCall(name, args);
      try {
        const result = fn(...args);
        if (DEBUG_JSFFI && result !== undefined) {
          console.log(`[JSFFI] ${name} => ${typeof result === 'object' ? '[obj]' : result}`);
        }
        return result;
      } catch (err) {
        console.error(`[JSFFI] ${name} ERROR:`, err);
        throw err;
      }
    }) as T;
  }

  const ffi: Record<string, JsFFIFunction> = {
    // =========================================================================
    // Core JSVal Management
    // =========================================================================

    newJSVal: jsvalFunctions.newJSVal,
    freeJSVal: jsvalFunctions.freeJSVal,
    getJSVal: jsvalFunctions.getJSVal,

    // =========================================================================
    // Scheduler
    // =========================================================================

    scheduleWork: (): void => {
      queueMicrotask(() => {
        __exports.rts_schedulerLoop?.();
      });
    },

    // =========================================================================
    // Types - String encoding/decoding
    // =========================================================================

    // ZC0: Error stringification
    "ZC0ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (err: Error): string => {
        return err.stack ? err.stack : String(err);
      },

    // ZC1: Decode UTF-8 string from WASM memory
    "ZC1ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (ptr: number, len: number): string => {
        const memory = __exports.memory!;
        const bytes = new Uint8Array(memory.buffer, ptr, len);
        return new TextDecoder("utf-8", { fatal: true } as TextDecoderConstructorOptions).decode(bytes);
      },

    // ZC2: Encode string into WASM memory, return bytes written
    "ZC2ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (str: string, ptr: number, len: number): number => {
        const memory = __exports.memory!;
        const bytes = new Uint8Array(memory.buffer, ptr, len);
        return new TextEncoder().encodeInto(str, bytes).written ?? 0;
      },

    // ZC3: Get string length
    "ZC3ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (str: string): number => str.length,

    // ZC4: Unregister from finalization registry
    "ZC4ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (val: object): void => {
        try {
          __ghc_wasm_jsffi_finalization_registry.unregister(val);
        } catch { /* ignore */ }
      },

    // =========================================================================
    // Exports - Promise operations
    // =========================================================================

    // ZC0: Reject promise with RuntimeError
    "ZC0ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (p: PromiseWithResolvers<unknown>, msg: string): void => {
        p.reject(new WebAssembly.RuntimeError(msg));
      },

    // ZC1-18: Resolve promise with typed value (all same implementation)]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/jsffi.ts" line="15">
              <codefragment><![CDATA[// GHC WASM exports use externref - JS values passed directly
  initialize: (input: string) => Promise<string>;
  step: (result: string) => Promise<string>;
  // RTS exports for JSFFI
  rts_schedulerLoop: () => void;
  rts_freeStablePtr: (sp: number) => void;
  rts_promiseResolveUnit: (p: number) => void;
  rts_promiseResolveJSVal: (p: number, val: number) => void;
  rts_promiseReject: (p: number, err: unknown) => void;
  rts_promiseThrowTo: (p: number, err: unknown) => void;
}

interface PromiseWithResolvers<T> extends Promise<T> {
  resolve: (value: T) => void;
  reject: (reason: unknown) => void;
  throwTo: (err: unknown) => void;
}

/**
 * Create the ghc_wasm_jsffi import object for WebAssembly.instantiate.
 * Uses a "knot-tying" pattern - pass an empty exports object that gets
 * filled in after instantiation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type JsFFIFunction = (...args: any[]) => any;

const DEBUG_JSFFI = false;

function logCall(name: string, args: unknown[]): void {
  if (DEBUG_JSFFI) {
    console.log(`[JSFFI] ${name}(${args.map(a => typeof a === 'object' ? '[obj]' : a).join(', ')})`);
  }
}

/** Access to the JSVal table for the loader */
export interface JsValTable {
  newJSVal(val: unknown): number;
  freeJSVal(id: number): void;
  getJSVal(id: number): unknown;
}

export interface JsFFIResult {
  imports: Record<string, JsFFIFunction>;
  jsvalTable: JsValTable;
}

export function createJsFFI(
  __exports: Partial<WasmExports>
): JsFFIResult {
  // Finalization registry for automatic cleanup of Haskell stable pointers
  const __ghc_wasm_jsffi_finalization_registry = new FinalizationRegistry(
    (sp: number) => {
      __exports.rts_freeStablePtr?.(sp);
    }
  );

  // JSVal table - maps integer handles to JavaScript values
  const jsvalTable = new Map<number, unknown>();
  let nextJsvalId = 1;

  // JSVal manipulation functions (used by both JSFFI imports and loader)
  const jsvalFunctions: JsValTable = {
    newJSVal: (val: unknown): number => {
      const id = nextJsvalId++;
      jsvalTable.set(id, val);
      return id;
    },
    freeJSVal: (id: number): void => {
      jsvalTable.delete(id);
    },
    getJSVal: (id: number): unknown => {
      return jsvalTable.get(id);
    },
  };

  // Wrap each function with logging and error catching
  function wrap<T extends JsFFIFunction>(name: string, fn: T): T {
    return ((...args: unknown[]) => {
      logCall(name, args);
      try {
        const result = fn(...args);
        if (DEBUG_JSFFI && result !== undefined) {
          console.log(`[JSFFI] ${name} => ${typeof result === 'object' ? '[obj]' : result}`);
        }
        return result;
      } catch (err) {
        console.error(`[JSFFI] ${name} ERROR:`, err);
        throw err;
      }
    }) as T;
  }

  const ffi: Record<string, JsFFIFunction> = {
    // =========================================================================
    // Core JSVal Management
    // =========================================================================

    newJSVal: jsvalFunctions.newJSVal,
    freeJSVal: jsvalFunctions.freeJSVal,
    getJSVal: jsvalFunctions.getJSVal,

    // =========================================================================
    // Scheduler
    // =========================================================================

    scheduleWork: (): void => {
      queueMicrotask(() => {
        __exports.rts_schedulerLoop?.();
      });
    },

    // =========================================================================
    // Types - String encoding/decoding
    // =========================================================================

    // ZC0: Error stringification
    "ZC0ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (err: Error): string => {
        return err.stack ? err.stack : String(err);
      },

    // ZC1: Decode UTF-8 string from WASM memory
    "ZC1ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (ptr: number, len: number): string => {
        const memory = __exports.memory!;
        const bytes = new Uint8Array(memory.buffer, ptr, len);
        return new TextDecoder("utf-8", { fatal: true } as TextDecoderConstructorOptions).decode(bytes);
      },

    // ZC2: Encode string into WASM memory, return bytes written
    "ZC2ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (str: string, ptr: number, len: number): number => {
        const memory = __exports.memory!;
        const bytes = new Uint8Array(memory.buffer, ptr, len);
        return new TextEncoder().encodeInto(str, bytes).written ?? 0;
      },

    // ZC3: Get string length
    "ZC3ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (str: string): number => str.length,

    // ZC4: Unregister from finalization registry
    "ZC4ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (val: object): void => {
        try {
          __ghc_wasm_jsffi_finalization_registry.unregister(val);
        } catch { /* ignore */ }
      },

    // =========================================================================
    // Exports - Promise operations
    // =========================================================================

    // ZC0: Reject promise with RuntimeError
    "ZC0ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (p: PromiseWithResolvers<unknown>, msg: string): void => {
        p.reject(new WebAssembly.RuntimeError(msg));
      },

    // ZC1-19: Resolve promise with typed value]]></codefragment>
            </file>
            <codefragment><![CDATA[// GHC WASM exports use externref - JS values passed directly
  initialize: (input: string) => Promise<string>;
  step: (result: string) => Promise<string>;
  // RTS exports for JSFFI
  rts_schedulerLoop: () => void;
  rts_freeStablePtr: (sp: number) => void;
  rts_promiseResolveUnit: (p: number) => void;
  rts_promiseResolveJSVal: (p: number, val: number) => void;
  rts_promiseReject: (p: number, err: unknown) => void;
  rts_promiseThrowTo: (p: number, err: unknown) => void;
}

interface PromiseWithResolvers<T> extends Promise<T> {
  resolve: (value: T) => void;
  reject: (reason: unknown) => void;
  throwTo: (err: unknown) => void;
}

/**
 * Create the ghc_wasm_jsffi import object for WebAssembly.instantiate.
 * Uses a "knot-tying" pattern - pass an empty exports object that gets
 * filled in after instantiation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
type JsFFIFunction = (...args: any[]) => any;

const DEBUG_JSFFI = false;

function logCall(name: string, args: unknown[]): void {
  if (DEBUG_JSFFI) {
    console.log(`[JSFFI] ${name}(${args.map(a => typeof a === 'object' ? '[obj]' : a).join(', ')})`);
  }
}

/** Access to the JSVal table for the loader */
export interface JsValTable {
  newJSVal(val: unknown): number;
  freeJSVal(id: number): void;
  getJSVal(id: number): unknown;
}

export interface JsFFIResult {
  imports: Record<string, JsFFIFunction>;
  jsvalTable: JsValTable;
}

export function createJsFFI(
  __exports: Partial<WasmExports>
): JsFFIResult {
  // Finalization registry for automatic cleanup of Haskell stable pointers
  const __ghc_wasm_jsffi_finalization_registry = new FinalizationRegistry(
    (sp: number) => {
      __exports.rts_freeStablePtr?.(sp);
    }
  );

  // JSVal table - maps integer handles to JavaScript values
  const jsvalTable = new Map<number, unknown>();
  let nextJsvalId = 1;

  // JSVal manipulation functions (used by both JSFFI imports and loader)
  const jsvalFunctions: JsValTable = {
    newJSVal: (val: unknown): number => {
      const id = nextJsvalId++;
      jsvalTable.set(id, val);
      return id;
    },
    freeJSVal: (id: number): void => {
      jsvalTable.delete(id);
    },
    getJSVal: (id: number): unknown => {
      return jsvalTable.get(id);
    },
  };

  // Wrap each function with logging and error catching
  function wrap<T extends JsFFIFunction>(name: string, fn: T): T {
    return ((...args: unknown[]) => {
      logCall(name, args);
      try {
        const result = fn(...args);
        if (DEBUG_JSFFI && result !== undefined) {
          console.log(`[JSFFI] ${name} => ${typeof result === 'object' ? '[obj]' : result}`);
        }
        return result;
      } catch (err) {
        console.error(`[JSFFI] ${name} ERROR:`, err);
        throw err;
      }
    }) as T;
  }

  const ffi: Record<string, JsFFIFunction> = {
    // =========================================================================
    // Core JSVal Management
    // =========================================================================

    newJSVal: jsvalFunctions.newJSVal,
    freeJSVal: jsvalFunctions.freeJSVal,
    getJSVal: jsvalFunctions.getJSVal,

    // =========================================================================
    // Scheduler
    // =========================================================================

    scheduleWork: (): void => {
      queueMicrotask(() => {
        __exports.rts_schedulerLoop?.();
      });
    },

    // =========================================================================
    // Types - String encoding/decoding
    // =========================================================================

    // ZC0: Error stringification
    "ZC0ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (err: Error): string => {
        return err.stack ? err.stack : String(err);
      },

    // ZC1: Decode UTF-8 string from WASM memory
    "ZC1ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (ptr: number, len: number): string => {
        const memory = __exports.memory!;
        const bytes = new Uint8Array(memory.buffer, ptr, len);
        return new TextDecoder("utf-8", { fatal: true } as TextDecoderConstructorOptions).decode(bytes);
      },

    // ZC2: Encode string into WASM memory, return bytes written
    "ZC2ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (str: string, ptr: number, len: number): number => {
        const memory = __exports.memory!;
        const bytes = new Uint8Array(memory.buffer, ptr, len);
        return new TextEncoder().encodeInto(str, bytes).written ?? 0;
      },

    // ZC3: Get string length
    "ZC3ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (str: string): number => str.length,

    // ZC4: Unregister from finalization registry
    "ZC4ZCghczminternalZCGHCziInternalziWasmziPrimziTypesZC":
      (val: object): void => {
        try {
          __ghc_wasm_jsffi_finalization_registry.unregister(val);
        } catch { /* ignore */ }
      },

    // =========================================================================
    // Exports - Promise operations
    // =========================================================================

    // ZC0: Reject promise with RuntimeError
    "ZC0ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (p: PromiseWithResolvers<unknown>, msg: string): void => {
        p.reject(new WebAssembly.RuntimeError(msg));
      },

    // ZC1-18: Resolve promise with typed value (all same implementation)]]></codefragment>
        </duplication>
      
      <duplication lines="61">
            <file path="haskell/protocol/generated-ts/src/jsffi.ts" line="177">
              <codefragment><![CDATA[,

    // ZC20: Set empty throwTo handler
    "ZC20ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (p: PromiseWithResolvers<unknown>): void => {
        p.throwTo = () => {};
      },

    // ZC21: Set throwTo handler that calls rts_promiseThrowTo
    "ZC21ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (p: PromiseWithResolvers<unknown>, sp: number): void => {
        p.throwTo = (err: unknown) => {
          __exports.rts_promiseThrowTo?.(sp, err);
        };
      },

    // ZC22: Create promise with resolve/reject attached
    "ZC22ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (): PromiseWithResolvers<unknown> => {
        let resolve: (v: unknown) => void;
        let reject: (e: unknown) => void;
        const p = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        }) as PromiseWithResolvers<unknown>;
        p.resolve = resolve!;
        p.reject = reject!;
        p.throwTo = () => {};
        return p;
      },

    // =========================================================================
    // Imports - Promise await handlers
    // =========================================================================

    // ZC18: Await promise that resolves to unit
    "ZC18ZCghczminternalZCGHCziInternalziWasmziPrimziImportsZC":
      (promise: Promise<void>, sp: number): void => {
        promise.then(
          () => __exports.rts_promiseResolveUnit?.(sp),
          (err) => __exports.rts_promiseReject?.(sp, err)
        );
      },

    // =========================================================================
    // Concurrency - Delay/sleep
    // =========================================================================

    // ZC0: Async delay (microseconds)
    "ZC0ZCghczminternalZCGHCziInternalziWasmziPrimziConcziInternalZC":
      async (delayMicros: number): Promise<void> => {
        await new Promise(resolve => setTimeout(resolve, delayMicros / 1000));
      },
  };

  // Wrap all functions with logging
  const wrapped: Record<string, JsFFIFunction> = {};
  for (const [name, fn] of Object.entries(ffi)) {
    wrapped[name] = wrap(name, fn);
  }
  return { imports: wrapped, jsvalTable: jsvalFunctions };
}]]></codefragment>
            </file>
            <file path="haskell/protocol/generated-ts/static/jsffi.ts" line="184">
              <codefragment><![CDATA[,

    // ZC20: Set empty throwTo handler
    "ZC20ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (p: PromiseWithResolvers<unknown>): void => {
        p.throwTo = () => {};
      },

    // ZC21: Set throwTo handler that calls rts_promiseThrowTo
    "ZC21ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (p: PromiseWithResolvers<unknown>, sp: number): void => {
        p.throwTo = (err: unknown) => {
          __exports.rts_promiseThrowTo?.(sp, err);
        };
      },

    // ZC22: Create promise with resolve/reject attached
    "ZC22ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (): PromiseWithResolvers<unknown> => {
        let resolve: (v: unknown) => void;
        let reject: (e: unknown) => void;
        const p = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        }) as PromiseWithResolvers<unknown>;
        p.resolve = resolve!;
        p.reject = reject!;
        p.throwTo = () => {};
        return p;
      },

    // =========================================================================
    // Imports - Promise await handlers
    // =========================================================================

    // ZC18: Await promise that resolves to unit
    "ZC18ZCghczminternalZCGHCziInternalziWasmziPrimziImportsZC":
      (promise: Promise<void>, sp: number): void => {
        promise.then(
          () => __exports.rts_promiseResolveUnit?.(sp),
          (err) => __exports.rts_promiseReject?.(sp, err)
        );
      },

    // =========================================================================
    // Concurrency - Delay/sleep
    // =========================================================================

    // ZC0: Async delay (microseconds)
    "ZC0ZCghczminternalZCGHCziInternalziWasmziPrimziConcziInternalZC":
      async (delayMicros: number): Promise<void> => {
        await new Promise(resolve => setTimeout(resolve, delayMicros / 1000));
      },
  };

  // Wrap all functions with logging
  const wrapped: Record<string, JsFFIFunction> = {};
  for (const [name, fn] of Object.entries(ffi)) {
    wrapped[name] = wrap(name, fn);
  }
  return { imports: wrapped, jsvalTable: jsvalFunctions };
}]]></codefragment>
            </file>
            <codefragment><![CDATA[,

    // ZC20: Set empty throwTo handler
    "ZC20ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (p: PromiseWithResolvers<unknown>): void => {
        p.throwTo = () => {};
      },

    // ZC21: Set throwTo handler that calls rts_promiseThrowTo
    "ZC21ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (p: PromiseWithResolvers<unknown>, sp: number): void => {
        p.throwTo = (err: unknown) => {
          __exports.rts_promiseThrowTo?.(sp, err);
        };
      },

    // ZC22: Create promise with resolve/reject attached
    "ZC22ZCghczminternalZCGHCziInternalziWasmziPrimziExportsZC":
      (): PromiseWithResolvers<unknown> => {
        let resolve: (v: unknown) => void;
        let reject: (e: unknown) => void;
        const p = new Promise((res, rej) => {
          resolve = res;
          reject = rej;
        }) as PromiseWithResolvers<unknown>;
        p.resolve = resolve!;
        p.reject = reject!;
        p.throwTo = () => {};
        return p;
      },

    // =========================================================================
    // Imports - Promise await handlers
    // =========================================================================

    // ZC18: Await promise that resolves to unit
    "ZC18ZCghczminternalZCGHCziInternalziWasmziPrimziImportsZC":
      (promise: Promise<void>, sp: number): void => {
        promise.then(
          () => __exports.rts_promiseResolveUnit?.(sp),
          (err) => __exports.rts_promiseReject?.(sp, err)
        );
      },

    // =========================================================================
    // Concurrency - Delay/sleep
    // =========================================================================

    // ZC0: Async delay (microseconds)
    "ZC0ZCghczminternalZCGHCziInternalziWasmziPrimziConcziInternalZC":
      async (delayMicros: number): Promise<void> => {
        await new Promise(resolve => setTimeout(resolve, delayMicros / 1000));
      },
  };

  // Wrap all functions with logging
  const wrapped: Record<string, JsFFIFunction> = {};
  for (const [name, fn] of Object.entries(ffi)) {
    wrapped[name] = wrap(name, fn);
  }
  return { imports: wrapped, jsvalTable: jsvalFunctions };
}]]></codefragment>
        </duplication>
      
      <duplication lines="19">
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="167">
              <codefragment><![CDATA[,
      "options": {
        "legend": {
          "calcs": ["sum"],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "mode": "single",
          "sort": "none"
        }
      },
      "targets": [
        {
          "datasource": {
            "type": "loki",
            "uid": "${datasource}"
          },
          "expr": "count_over_time({job=\"tidepool-native\", event_type=\"error\"} [$__interval])"]]></codefragment>
            </file>
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="74">
              <codefragment><![CDATA[,
      "options": {
        "legend": {
          "calcs": ["sum"],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "mode": "single",
          "sort": "none"
        }
      },
      "targets": [
        {
          "datasource": {
            "type": "loki",
            "uid": "${datasource}"
          },
          "expr": "sum by (event_type) (count_over_time({job=\"tidepool-native\"} [$__interval]))"]]></codefragment>
            </file>
            <codefragment><![CDATA[,
      "options": {
        "legend": {
          "calcs": ["sum"],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "mode": "single",
          "sort": "none"
        }
      },
      "targets": [
        {
          "datasource": {
            "type": "loki",
            "uid": "${datasource}"
          },
          "expr": "count_over_time({job=\"tidepool-native\", event_type=\"error\"} [$__interval])"]]></codefragment>
        </duplication>
      
      <duplication lines="24">
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="219">
              <codefragment><![CDATA[,
            "lineWidth": 2,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              }
            ]]]></codefragment>
            </file>
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="127">
              <codefragment><![CDATA[,
            "lineWidth": 2,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },]]></codefragment>
            </file>
            <codefragment><![CDATA[,
            "lineWidth": 2,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              }
            ]]]></codefragment>
        </duplication>
      
      <duplication lines="40">
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="296">
              <codefragment><![CDATA[,
            "axisPlacement": "auto",
            "barAlignment": 0,
            "drawStyle": "bars",
            "fillOpacity": 80,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "lineInterpolation": "linear",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "normal"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              }
            ]
          },
          "unit": "short"
        },
        "overrides": [
          {]]></codefragment>
            </file>
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="27">
              <codefragment><![CDATA[,
            "axisPlacement": "auto",
            "barAlignment": 0,
            "drawStyle": "bars",
            "fillOpacity": 80,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "lineInterpolation": "linear",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "normal"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              }
            ]
          },
          "unit": "short"
        },
        "overrides": []]]></codefragment>
            </file>
            <codefragment><![CDATA[,
            "axisPlacement": "auto",
            "barAlignment": 0,
            "drawStyle": "bars",
            "fillOpacity": 80,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "lineInterpolation": "linear",
            "lineWidth": 1,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "normal"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              }
            ]
          },
          "unit": "short"
        },
        "overrides": [
          {]]></codefragment>
        </duplication>
      
      <duplication lines="17">
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="508">
              <codefragment><![CDATA[,
      "options": {
        "cellHeight": "sm",
        "footer": {
          "countRows": false,
          "fields": "",
          "reducer": ["sum"],
          "show": false
        },
        "showHeader": true
      },
      "targets": [
        {
          "datasource": {
            "type": "loki",
            "uid": "${datasource}"
          },
          "expr": "{job=\"tidepool-native\", event_type=\"error\"} | json | line_format \"{{.message}}\""]]></codefragment>
            </file>
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="447">
              <codefragment><![CDATA[,
      "options": {
        "cellHeight": "sm",
        "footer": {
          "countRows": false,
          "fields": "",
          "reducer": ["sum"],
          "show": false
        },
        "showHeader": true
      },
      "targets": [
        {
          "datasource": {
            "type": "loki",
            "uid": "${datasource}"
          },
          "expr": "{job=\"tidepool-native\", event_type=\"graph_transition\"} | json | line_format \"{{.from}} → {{.to}} ({{.trigger}})\""]]></codefragment>
            </file>
            <codefragment><![CDATA[,
      "options": {
        "cellHeight": "sm",
        "footer": {
          "countRows": false,
          "fields": "",
          "reducer": ["sum"],
          "show": false
        },
        "showHeader": true
      },
      "targets": [
        {
          "datasource": {
            "type": "loki",
            "uid": "${datasource}"
          },
          "expr": "{job=\"tidepool-native\", event_type=\"error\"} | json | line_format \"{{.message}}\""]]></codefragment>
        </duplication>
      
      <duplication lines="26">
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="563">
              <codefragment><![CDATA[,
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              }
            ]
          },
          "unit": "ms"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 24]]></codefragment>
            </file>
            <file path="haskell/effects/observability-executor/dashboards/tidepool-native.json" line="133">
              <codefragment><![CDATA[,
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              },
              {
                "color": "red",
                "value": 1
              }
            ]
          },
          "unit": "short"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 12,
        "x": 12,
        "y": 0
      },
      "id": 2,
      "options": {
        "legend": {
          "calcs": ["sum"],
          "displayMode": "list",
          "placement": "bottom",
          "showLegend": true
        },
        "tooltip": {
          "mode": "single",
          "sort": "none"
        }
      },
      "targets": [
        {
          "datasource": {
            "type": "loki",
            "uid": "${datasource}"
          },
          "expr": "count_over_time({job=\"tidepool-native\", event_type=\"error\"} [$__interval])",
          "legendFormat": "Errors",
          "refId": "A"
        }
      ],
      "title": "Error Rate",
      "type": "timeseries"
    },
    {
      "datasource": {
        "type": "loki",
        "uid": "${datasource}"
      },
      "description": "LLM call latency distribution",
      "fieldConfig": {
        "defaults": {
          "color": {
            "mode": "palette-classic"
          },
          "custom": {
            "axisCenteredZero": false,
            "axisColorMode": "text",
            "axisLabel": "Latency (ms)",
            "axisPlacement": "auto",
            "barAlignment": 0,
            "drawStyle": "line",
            "fillOpacity": 10,
            "gradientMode": "none",
            "hideFrom": {
              "legend": false,
              "tooltip": false,
              "viz": false
            },
            "lineInterpolation": "smooth",
            "lineWidth": 2,
            "pointSize": 5,
            "scaleDistribution": {
              "type": "linear"
            },
            "showPoints": "auto",
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              }
            ]
          },
          "unit": "ms"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 12]]></codefragment>
            </file>
            <codefragment><![CDATA[,
            "spanNulls": false,
            "stacking": {
              "group": "A",
              "mode": "none"
            },
            "thresholdsStyle": {
              "mode": "off"
            }
          },
          "mappings": [],
          "thresholds": {
            "mode": "absolute",
            "steps": [
              {
                "color": "green",
                "value": null
              }
            ]
          },
          "unit": "ms"
        },
        "overrides": []
      },
      "gridPos": {
        "h": 8,
        "w": 24]]></codefragment>
        </duplication>
      
      <duplication lines="11">
            <file path="haskell/native-server/test/WebSocketSpec.hs" line="77">
              <codefragment><![CDATA[WS.sendTextData conn (encode action)

          -- Receive response
          msg <- WS.receiveData conn
          case decode msg of
            Just state -> atomically $ writeTVar responseState (Just state)
            Nothing -> pure ()

        result <- atomically $ readTVar responseState
        case result of
          Just (state :: UIState) -> do
            usGraphNode state `shouldBe` "button"]]></codefragment>
            </file>
            <file path="haskell/native-server/test/WebSocketSpec.hs" line="51">
              <codefragment><![CDATA[WS.sendTextData conn (encode action)

          -- Receive response
          msg <- WS.receiveData conn
          case decode msg of
            Just state -> atomically $ writeTVar responseState (Just state)
            Nothing -> pure ()

        result <- atomically $ readTVar responseState
        case result of
          Just (state :: UIState) -> do
            usGraphNode state `shouldBe` "echo"]]></codefragment>
            </file>
            <codefragment><![CDATA[WS.sendTextData conn (encode action)

          -- Receive response
          msg <- WS.receiveData conn
          case decode msg of
            Just state -> atomically $ writeTVar responseState (Just state)
            Nothing -> pure ()

        result <- atomically $ readTVar responseState
        case result of
          Just (state :: UIState) -> do
            usGraphNode state `shouldBe` "button"]]></codefragment>
        </duplication>
      
      <duplication lines="11">
            <file path="haskell/native-server/test/WebSocketSpec.hs" line="100">
              <codefragment><![CDATA[WS.sendTextData conn (encode action)

          -- Receive response
          msg <- WS.receiveData conn
          case decode msg of
            Just state -> atomically $ writeTVar responseState (Just state)
            Nothing -> pure ()

        result <- atomically $ readTVar responseState
        case result of
          Just (state :: UIState) -> do
            usGraphNode state `shouldBe` "photo"]]></codefragment>
            </file>
            <file path="haskell/native-server/test/WebSocketSpec.hs" line="51">
              <codefragment><![CDATA[WS.sendTextData conn (encode action)

          -- Receive response
          msg <- WS.receiveData conn
          case decode msg of
            Just state -> atomically $ writeTVar responseState (Just state)
            Nothing -> pure ()

        result <- atomically $ readTVar responseState
        case result of
          Just (state :: UIState) -> do
            usGraphNode state `shouldBe` "echo"]]></codefragment>
            </file>
            <codefragment><![CDATA[WS.sendTextData conn (encode action)

          -- Receive response
          msg <- WS.receiveData conn
          case decode msg of
            Just state -> atomically $ writeTVar responseState (Just state)
            Nothing -> pure ()

        result <- atomically $ readTVar responseState
        case result of
          Just (state :: UIState) -> do
            usGraphNode state `shouldBe` "photo"]]></codefragment>
        </duplication>
      </pmd-cpd>